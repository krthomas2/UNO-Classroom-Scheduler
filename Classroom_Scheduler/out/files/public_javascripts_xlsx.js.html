<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public\javascripts\xlsx.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: public\javascripts\xlsx.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* xlsx.js (C) 2013-2015 SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*jshint -W041 */
/*jshint funcscope:true, eqnull:true */
var XLSX = {};
(function make_xlsx(XLSX){
XLSX.version = &#x27;0.8.0&#x27;;
var current_codepage = 1200, current_cptable;
if(typeof module !== &quot;undefined&quot; &amp;&amp; typeof require !== &#x27;undefined&#x27;) {
	if(typeof cptable === &#x27;undefined&#x27;) cptable = require(&#x27;./dist/cpexcel&#x27;);
	current_cptable = cptable[current_codepage];
}
function reset_cp() { set_cp(1200); }
var set_cp = function(cp) { current_codepage = cp; };

function char_codes(data) { var o = []; for(var i = 0, len = data.length; i &lt; len; ++i) o[i] = data.charCodeAt(i); return o; }
var debom_xml = function(data) { return data; };

var _getchar = function _gc1(x) { return String.fromCharCode(x); };
if(typeof cptable !== &#x27;undefined&#x27;) {
	set_cp = function(cp) { current_codepage = cp; current_cptable = cptable[cp]; };
	debom_xml = function(data) {
		if(data.charCodeAt(0) === 0xFF &amp;&amp; data.charCodeAt(1) === 0xFE) { return cptable.utils.decode(1200, char_codes(data.substr(2))); }
		return data;
	};
	_getchar = function _gc2(x) {
		if(current_codepage === 1200) return String.fromCharCode(x);
		return cptable.utils.decode(current_codepage, [x&amp;255,x&gt;&gt;8])[0];
	};
}
var Base64 = (function make_b64(){
	var map = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;
	return {
		encode: function(input, utf8) {
			var o = &quot;&quot;;
			var c1, c2, c3, e1, e2, e3, e4;
			for(var i = 0; i &lt; input.length; ) {
				c1 = input.charCodeAt(i++);
				c2 = input.charCodeAt(i++);
				c3 = input.charCodeAt(i++);
				e1 = c1 &gt;&gt; 2;
				e2 = (c1 &amp; 3) &lt;&lt; 4 | c2 &gt;&gt; 4;
				e3 = (c2 &amp; 15) &lt;&lt; 2 | c3 &gt;&gt; 6;
				e4 = c3 &amp; 63;
				if (isNaN(c2)) { e3 = e4 = 64; }
				else if (isNaN(c3)) { e4 = 64; }
				o += map.charAt(e1) + map.charAt(e2) + map.charAt(e3) + map.charAt(e4);
			}
			return o;
		},
		decode: function b64_decode(input, utf8) {
			var o = &quot;&quot;;
			var c1, c2, c3;
			var e1, e2, e3, e4;
			input = input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;);
			for(var i = 0; i &lt; input.length;) {
				e1 = map.indexOf(input.charAt(i++));
				e2 = map.indexOf(input.charAt(i++));
				e3 = map.indexOf(input.charAt(i++));
				e4 = map.indexOf(input.charAt(i++));
				c1 = e1 &lt;&lt; 2 | e2 &gt;&gt; 4;
				c2 = (e2 &amp; 15) &lt;&lt; 4 | e3 &gt;&gt; 2;
				c3 = (e3 &amp; 3) &lt;&lt; 6 | e4;
				o += String.fromCharCode(c1);
				if (e3 != 64) { o += String.fromCharCode(c2); }
				if (e4 != 64) { o += String.fromCharCode(c3); }
			}
			return o;
		}
	};
})();
var has_buf = (typeof Buffer !== &#x27;undefined&#x27;);

function new_raw_buf(len) {
	/* jshint -W056 */
	return new (has_buf ? Buffer : Array)(len);
	/* jshint +W056 */
}

function s2a(s) {
	if(has_buf) return new Buffer(s, &quot;binary&quot;);
	return s.split(&quot;&quot;).map(function(x){ return x.charCodeAt(0) &amp; 0xff; });
}

var bconcat = function(bufs) { return [].concat.apply([], bufs); };

var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/;
/* ssf.js (C) 2013-2014 SheetJS -- http://sheetjs.com */
/*jshint -W041 */
var SSF = {};
var make_ssf = function make_ssf(SSF){
SSF.version = &#x27;0.8.1&#x27;;
function _strrev(x) { var o = &quot;&quot;, i = x.length-1; while(i&gt;=0) o += x.charAt(i--); return o; }
function fill(c,l) { var o = &quot;&quot;; while(o.length &lt; l) o+=c; return o; }
function pad0(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:fill(&#x27;0&#x27;,d-t.length)+t;}
function pad_(v,d){var t=&quot;&quot;+v;return t.length&gt;=d?t:fill(&#x27; &#x27;,d-t.length)+t;}
function rpad_(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:t+fill(&#x27; &#x27;,d-t.length);}
function pad0r1(v,d){var t=&quot;&quot;+Math.round(v); return t.length&gt;=d?t:fill(&#x27;0&#x27;,d-t.length)+t;}
function pad0r2(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:fill(&#x27;0&#x27;,d-t.length)+t;}
var p2_32 = Math.pow(2,32);
function pad0r(v,d){if(v&gt;p2_32||v&lt;-p2_32) return pad0r1(v,d); var i = Math.round(v); return pad0r2(i,d); }
function isgeneral(s, i) { return s.length &gt;= 7 + i &amp;&amp; (s.charCodeAt(i)|32) === 103 &amp;&amp; (s.charCodeAt(i+1)|32) === 101 &amp;&amp; (s.charCodeAt(i+2)|32) === 110 &amp;&amp; (s.charCodeAt(i+3)|32) === 101 &amp;&amp; (s.charCodeAt(i+4)|32) === 114 &amp;&amp; (s.charCodeAt(i+5)|32) === 97 &amp;&amp; (s.charCodeAt(i+6)|32) === 108; }
/* Options */
var opts_fmt = [
	[&quot;date1904&quot;, 0],
	[&quot;output&quot;, &quot;&quot;],
	[&quot;WTF&quot;, false]
];
function fixopts(o){
	for(var y = 0; y != opts_fmt.length; ++y) if(o[opts_fmt[y][0]]===undefined) o[opts_fmt[y][0]]=opts_fmt[y][1];
}
SSF.opts = opts_fmt;
var table_fmt = {
	0:  &#x27;General&#x27;,
	1:  &#x27;0&#x27;,
	2:  &#x27;0.00&#x27;,
	3:  &#x27;#,##0&#x27;,
	4:  &#x27;#,##0.00&#x27;,
	9:  &#x27;0%&#x27;,
	10: &#x27;0.00%&#x27;,
	11: &#x27;0.00E+00&#x27;,
	12: &#x27;# ?/?&#x27;,
	13: &#x27;# ??/??&#x27;,
	14: &#x27;m/d/yy&#x27;,
	15: &#x27;d-mmm-yy&#x27;,
	16: &#x27;d-mmm&#x27;,
	17: &#x27;mmm-yy&#x27;,
	18: &#x27;h:mm AM/PM&#x27;,
	19: &#x27;h:mm:ss AM/PM&#x27;,
	20: &#x27;h:mm&#x27;,
	21: &#x27;h:mm:ss&#x27;,
	22: &#x27;m/d/yy h:mm&#x27;,
	37: &#x27;#,##0 ;(#,##0)&#x27;,
	38: &#x27;#,##0 ;[Red](#,##0)&#x27;,
	39: &#x27;#,##0.00;(#,##0.00)&#x27;,
	40: &#x27;#,##0.00;[Red](#,##0.00)&#x27;,
	45: &#x27;mm:ss&#x27;,
	46: &#x27;[h]:mm:ss&#x27;,
	47: &#x27;mmss.0&#x27;,
	48: &#x27;##0.0E+0&#x27;,
	49: &#x27;@&#x27;,
	56: &#x27;&quot;上午/下午 &quot;hh&quot;時&quot;mm&quot;分&quot;ss&quot;秒 &quot;&#x27;,
	65535: &#x27;General&#x27;
};
var days = [
	[&#x27;Sun&#x27;, &#x27;Sunday&#x27;],
	[&#x27;Mon&#x27;, &#x27;Monday&#x27;],
	[&#x27;Tue&#x27;, &#x27;Tuesday&#x27;],
	[&#x27;Wed&#x27;, &#x27;Wednesday&#x27;],
	[&#x27;Thu&#x27;, &#x27;Thursday&#x27;],
	[&#x27;Fri&#x27;, &#x27;Friday&#x27;],
	[&#x27;Sat&#x27;, &#x27;Saturday&#x27;]
];
var months = [
	[&#x27;J&#x27;, &#x27;Jan&#x27;, &#x27;January&#x27;],
	[&#x27;F&#x27;, &#x27;Feb&#x27;, &#x27;February&#x27;],
	[&#x27;M&#x27;, &#x27;Mar&#x27;, &#x27;March&#x27;],
	[&#x27;A&#x27;, &#x27;Apr&#x27;, &#x27;April&#x27;],
	[&#x27;M&#x27;, &#x27;May&#x27;, &#x27;May&#x27;],
	[&#x27;J&#x27;, &#x27;Jun&#x27;, &#x27;June&#x27;],
	[&#x27;J&#x27;, &#x27;Jul&#x27;, &#x27;July&#x27;],
	[&#x27;A&#x27;, &#x27;Aug&#x27;, &#x27;August&#x27;],
	[&#x27;S&#x27;, &#x27;Sep&#x27;, &#x27;September&#x27;],
	[&#x27;O&#x27;, &#x27;Oct&#x27;, &#x27;October&#x27;],
	[&#x27;N&#x27;, &#x27;Nov&#x27;, &#x27;November&#x27;],
	[&#x27;D&#x27;, &#x27;Dec&#x27;, &#x27;December&#x27;]
];
function frac(x, D, mixed) {
	var sgn = x &lt; 0 ? -1 : 1;
	var B = x * sgn;
	var P_2 = 0, P_1 = 1, P = 0;
	var Q_2 = 1, Q_1 = 0, Q = 0;
	var A = Math.floor(B);
	while(Q_1 &lt; D) {
		A = Math.floor(B);
		P = A * P_1 + P_2;
		Q = A * Q_1 + Q_2;
		if((B - A) &lt; 0.0000000005) break;
		B = 1 / (B - A);
		P_2 = P_1; P_1 = P;
		Q_2 = Q_1; Q_1 = Q;
	}
	if(Q &gt; D) { Q = Q_1; P = P_1; }
	if(Q &gt; D) { Q = Q_2; P = P_2; }
	if(!mixed) return [0, sgn * P, Q];
	if(Q===0) throw &quot;Unexpected state: &quot;+P+&quot; &quot;+P_1+&quot; &quot;+P_2+&quot; &quot;+Q+&quot; &quot;+Q_1+&quot; &quot;+Q_2;
	var q = Math.floor(sgn * P/Q);
	return [q, sgn*P - q*Q, Q];
}
function general_fmt_int(v, opts) { return &quot;&quot;+v; }
SSF._general_int = general_fmt_int;
var general_fmt_num = (function make_general_fmt_num() {
var gnr1 = /\.(\d*[1-9])0+$/, gnr2 = /\.0*$/, gnr4 = /\.(\d*[1-9])0+/, gnr5 = /\.0*[Ee]/, gnr6 = /(E[+-])(\d)$/;
function gfn2(v) {
	var w = (v&lt;0?12:11);
	var o = gfn5(v.toFixed(12)); if(o.length &lt;= w) return o;
	o = v.toPrecision(10); if(o.length &lt;= w) return o;
	return v.toExponential(5);
}
function gfn3(v) {
	var o = v.toFixed(11).replace(gnr1,&quot;.$1&quot;);
	if(o.length &gt; (v&lt;0?12:11)) o = v.toPrecision(6);
	return o;
}
function gfn4(o) {
	for(var i = 0; i != o.length; ++i) if((o.charCodeAt(i) | 0x20) === 101) return o.replace(gnr4,&quot;.$1&quot;).replace(gnr5,&quot;E&quot;).replace(&quot;e&quot;,&quot;E&quot;).replace(gnr6,&quot;$10$2&quot;);
	return o;
}
function gfn5(o) {
	//for(var i = 0; i != o.length; ++i) if(o.charCodeAt(i) === 46) return o.replace(gnr2,&quot;&quot;).replace(gnr1,&quot;.$1&quot;);
	//return o;
	return o.indexOf(&quot;.&quot;) &gt; -1 ? o.replace(gnr2,&quot;&quot;).replace(gnr1,&quot;.$1&quot;) : o;
}
return function general_fmt_num(v, opts) {
	var V = Math.floor(Math.log(Math.abs(v))*Math.LOG10E), o;
	if(V &gt;= -4 &amp;&amp; V &lt;= -1) o = v.toPrecision(10+V);
	else if(Math.abs(V) &lt;= 9) o = gfn2(v);
	else if(V === 10) o = v.toFixed(10).substr(0,12);
	else o = gfn3(v);
	return gfn5(gfn4(o));
};})();
SSF._general_num = general_fmt_num;
function general_fmt(v, opts) {
	switch(typeof v) {
		case &#x27;string&#x27;: return v;
		case &#x27;boolean&#x27;: return v ? &quot;TRUE&quot; : &quot;FALSE&quot;;
		case &#x27;number&#x27;: return (v|0) === v ? general_fmt_int(v, opts) : general_fmt_num(v, opts);
	}
	throw new Error(&quot;unsupported value in General format: &quot; + v);
}
SSF._general = general_fmt;
function fix_hijri(date, o) { return 0; }
function parse_date_code(v,opts,b2) {
	if(v &gt; 2958465 || v &lt; 0) return null;
	var date = (v|0), time = Math.floor(86400 * (v - date)), dow=0;
	var dout=[];
	var out={D:date, T:time, u:86400*(v-date)-time,y:0,m:0,d:0,H:0,M:0,S:0,q:0};
	if(Math.abs(out.u) &lt; 1e-6) out.u = 0;
	fixopts(opts != null ? opts : (opts=[]));
	if(opts.date1904) date += 1462;
	if(out.u &gt; 0.999) {
		out.u = 0;
		if(++time == 86400) { time = 0; ++date; }
	}
	if(date === 60) {dout = b2 ? [1317,10,29] : [1900,2,29]; dow=3;}
	else if(date === 0) {dout = b2 ? [1317,8,29] : [1900,1,0]; dow=6;}
	else {
		if(date &gt; 60) --date;
		/* 1 = Jan 1 1900 */
		var d = new Date(1900,0,1);
		d.setDate(d.getDate() + date - 1);
		dout = [d.getFullYear(), d.getMonth()+1,d.getDate()];
		dow = d.getDay();
		if(date &lt; 60) dow = (dow + 6) % 7;
		if(b2) dow = fix_hijri(d, dout);
	}
	out.y = dout[0]; out.m = dout[1]; out.d = dout[2];
	out.S = time % 60; time = Math.floor(time / 60);
	out.M = time % 60; time = Math.floor(time / 60);
	out.H = time;
	out.q = dow;
	return out;
}
SSF.parse_date_code = parse_date_code;
/*jshint -W086 */
function write_date(type, fmt, val, ss0) {
	var o=&quot;&quot;, ss=0, tt=0, y = val.y, out, outl = 0;
	switch(type) {
		case 98: /* &#x27;b&#x27; buddhist year */
			y = val.y + 543;
			/* falls through */
		case 121: /* &#x27;y&#x27; year */
		switch(fmt.length) {
			case 1: case 2: out = y % 100; outl = 2; break;
			default: out = y % 10000; outl = 4; break;
		} break;
		case 109: /* &#x27;m&#x27; month */
		switch(fmt.length) {
			case 1: case 2: out = val.m; outl = fmt.length; break;
			case 3: return months[val.m-1][1];
			case 5: return months[val.m-1][0];
			default: return months[val.m-1][2];
		} break;
		case 100: /* &#x27;d&#x27; day */
		switch(fmt.length) {
			case 1: case 2: out = val.d; outl = fmt.length; break;
			case 3: return days[val.q][0];
			default: return days[val.q][1];
		} break;
		case 104: /* &#x27;h&#x27; 12-hour */
		switch(fmt.length) {
			case 1: case 2: out = 1+(val.H+11)%12; outl = fmt.length; break;
			default: throw &#x27;bad hour format: &#x27; + fmt;
		} break;
		case 72: /* &#x27;H&#x27; 24-hour */
		switch(fmt.length) {
			case 1: case 2: out = val.H; outl = fmt.length; break;
			default: throw &#x27;bad hour format: &#x27; + fmt;
		} break;
		case 77: /* &#x27;M&#x27; minutes */
		switch(fmt.length) {
			case 1: case 2: out = val.M; outl = fmt.length; break;
			default: throw &#x27;bad minute format: &#x27; + fmt;
		} break;
		case 115: /* &#x27;s&#x27; seconds */
		if(val.u === 0) switch(fmt) {
			case &#x27;s&#x27;: case &#x27;ss&#x27;: return pad0(val.S, fmt.length);
			case &#x27;.0&#x27;: case &#x27;.00&#x27;: case &#x27;.000&#x27;:
		}
		switch(fmt) {
			case &#x27;s&#x27;: case &#x27;ss&#x27;: case &#x27;.0&#x27;: case &#x27;.00&#x27;: case &#x27;.000&#x27;:
				if(ss0 &gt;= 2) tt = ss0 === 3 ? 1000 : 100;
				else tt = ss0 === 1 ? 10 : 1;
				ss = Math.round((tt)*(val.S + val.u));
				if(ss &gt;= 60*tt) ss = 0;
				if(fmt === &#x27;s&#x27;) return ss === 0 ? &quot;0&quot; : &quot;&quot;+ss/tt;
				o = pad0(ss,2 + ss0);
				if(fmt === &#x27;ss&#x27;) return o.substr(0,2);
				return &quot;.&quot; + o.substr(2,fmt.length-1);
			default: throw &#x27;bad second format: &#x27; + fmt;
		}
		case 90: /* &#x27;Z&#x27; absolute time */
		switch(fmt) {
			case &#x27;[h]&#x27;: case &#x27;[hh]&#x27;: out = val.D*24+val.H; break;
			case &#x27;[m]&#x27;: case &#x27;[mm]&#x27;: out = (val.D*24+val.H)*60+val.M; break;
			case &#x27;[s]&#x27;: case &#x27;[ss]&#x27;: out = ((val.D*24+val.H)*60+val.M)*60+Math.round(val.S+val.u); break;
			default: throw &#x27;bad abstime format: &#x27; + fmt;
		} outl = fmt.length === 3 ? 1 : 2; break;
		case 101: /* &#x27;e&#x27; era */
			out = y; outl = 1;
	}
	if(outl &gt; 0) return pad0(out, outl); else return &quot;&quot;;
}
/*jshint +W086 */
function commaify(s) {
	if(s.length &lt;= 3) return s;
	var j = (s.length % 3), o = s.substr(0,j);
	for(; j!=s.length; j+=3) o+=(o.length &gt; 0 ? &quot;,&quot; : &quot;&quot;) + s.substr(j,3);
	return o;
}
var write_num = (function make_write_num(){
var pct1 = /%/g;
function write_num_pct(type, fmt, val){
	var sfmt = fmt.replace(pct1,&quot;&quot;), mul = fmt.length - sfmt.length;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill(&quot;%&quot;,mul);
}
function write_num_cm(type, fmt, val){
	var idx = fmt.length - 1;
	while(fmt.charCodeAt(idx-1) === 44) --idx;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));
}
function write_num_exp(fmt, val){
	var o;
	var idx = fmt.indexOf(&quot;E&quot;) - fmt.indexOf(&quot;.&quot;) - 1;
	if(fmt.match(/^#+0.0E\+0$/)) {
		var period = fmt.indexOf(&quot;.&quot;); if(period === -1) period=fmt.indexOf(&#x27;E&#x27;);
		var ee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E)%period;
		if(ee &lt; 0) ee += period;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
		if(o.indexOf(&quot;e&quot;) === -1) {
			var fakee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E);
			if(o.indexOf(&quot;.&quot;) === -1) o = o[0] + &quot;.&quot; + o.substr(1) + &quot;E+&quot; + (fakee - o.length+ee);
			else o += &quot;E+&quot; + (fakee - ee);
			while(o.substr(0,2) === &quot;0.&quot;) {
				o = o[0] + o.substr(2,period) + &quot;.&quot; + o.substr(2+period);
				o = o.replace(/^0+([1-9])/,&quot;$1&quot;).replace(/^0+\./,&quot;0.&quot;);
			}
			o = o.replace(/\+-/,&quot;-&quot;);
		}
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + &quot;.&quot; + $3.substr(ee) + &quot;E&quot;; });
	} else o = val.toExponential(idx);
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + &quot;0&quot; + o[o.length-1];
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,&quot;e&quot;);
	return o.replace(&quot;e&quot;,&quot;E&quot;);
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign) {
	var den = parseInt(r[4]), rr = Math.round(aval * den), base = Math.floor(rr/den);
	var myn = (rr - base*den), myd = den;
	return sign + (base === 0 ? &quot;&quot; : &quot;&quot;+base) + &quot; &quot; + (myn === 0 ? fill(&quot; &quot;, r[1].length + 1 + r[4].length) : pad_(myn,r[1].length) + r[2] + &quot;/&quot; + r[3] + pad0(myd,r[4].length));
}
function write_num_f2(r, aval, sign) {
	return sign + (aval === 0 ? &quot;&quot; : &quot;&quot;+aval) + fill(&quot; &quot;, r[1].length + 2 + r[4].length);
}
var dec1 = /^#*0*\.(0+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
	var o = &quot;&quot;, cc;
	for(var i = 0; i != str.length; ++i) switch((cc=str.charCodeAt(i))) {
		case 35: break;
		case 63: o+= &quot; &quot;; break;
		case 48: o+= &quot;0&quot;; break;
		default: o+= String.fromCharCode(cc);
	}
	return o;
}
function rnd(val, d) { var dd = Math.pow(10,d); return &quot;&quot;+(Math.round(val * dd)/dd); }
function dec(val, d) { return Math.round((val-Math.floor(val))*Math.pow(10,d)); }
function flr(val) { if(val &lt; 2147483647 &amp;&amp; val &gt; -2147483648) return &quot;&quot;+(val &gt;= 0 ? (val|0) : (val-1|0)); return &quot;&quot;+Math.floor(val); }
function write_num_flt(type, fmt, val) {
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {
		var ffmt = fmt.replace(/\( */,&quot;&quot;).replace(/ \)/,&quot;&quot;).replace(/\)/,&quot;&quot;);
		if(val &gt;= 0) return write_num_flt(&#x27;n&#x27;, ffmt, val);
		return &#x27;(&#x27; + write_num_flt(&#x27;n&#x27;, ffmt, -val) + &#x27;)&#x27;;
	}
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
	if(fmt.indexOf(&#x27;%&#x27;) !== -1) return write_num_pct(type, fmt, val);
	if(fmt.indexOf(&#x27;E&#x27;) !== -1) return write_num_exp(fmt, val);
	if(fmt.charCodeAt(0) === 36) return &quot;$&quot;+write_num_flt(type,fmt.substr(fmt[1]==&#x27; &#x27;?2:1),val);
	var o, oo;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? &quot;-&quot; : &quot;&quot;;
	if(fmt.match(/^00+$/)) return sign + pad0r(aval,fmt.length);
	if(fmt.match(/^[#?]+$/)) {
		o = pad0r(val,0); if(o === &quot;0&quot;) o = &quot;&quot;;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
	}
	if((r = fmt.match(frac1)) !== null) return write_num_f1(r, aval, sign);
	if(fmt.match(/^#+0+$/) !== null) return sign + pad0r(aval,fmt.length - fmt.indexOf(&quot;0&quot;));
	if((r = fmt.match(dec1)) !== null) {
		o = rnd(val, r[1].length).replace(/^([^\.]+)$/,&quot;$1.&quot;+r[1]).replace(/\.$/,&quot;.&quot;+r[1]).replace(/\.(\d*)$/,function($$, $1) { return &quot;.&quot; + $1 + fill(&quot;0&quot;, r[1].length-$1.length); });
		return fmt.indexOf(&quot;0.&quot;) !== -1 ? o : o.replace(/^0\./,&quot;.&quot;);
	}
	fmt = fmt.replace(/^#+([0.])/, &quot;$1&quot;);
	if((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
		return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/,&quot;.$1&quot;).replace(/^(-?\d*)$/,&quot;$1.&quot;).replace(/^0\./,r[1].length?&quot;0.&quot;:&quot;.&quot;);
	}
	if((r = fmt.match(/^#,##0(\.?)$/)) !== null) return sign + commaify(pad0r(aval,0));
	if((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
		return val &lt; 0 ? &quot;-&quot; + write_num_flt(type, fmt, -val) : commaify(&quot;&quot;+(Math.floor(val))) + &quot;.&quot; + pad0(dec(val, r[1].length),r[1].length);
	}
	if((r = fmt.match(/^#,#*,#0/)) !== null) return write_num_flt(type,fmt.replace(/^#,#*,/,&quot;&quot;),val);
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
		o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g,&quot;&quot;), val));
		ri = 0;
		return _strrev(_strrev(fmt.replace(/\\/g,&quot;&quot;)).replace(/[0#]/g,function(x){return ri&lt;o.length?o[ri++]:x===&#x27;0&#x27;?&#x27;0&#x27;:&quot;&quot;;}));
	}
	if(fmt.match(phone) !== null) {
		o = write_num_flt(type, &quot;##########&quot;, val);
		return &quot;(&quot; + o.substr(0,3) + &quot;) &quot; + o.substr(3, 3) + &quot;-&quot; + o.substr(6);
	}
	var oa = &quot;&quot;;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
		ri = Math.min(r[4].length,7);
		ff = frac(aval, Math.pow(10,ri)-1, false);
		o = &quot;&quot; + sign;
		oa = write_num(&quot;n&quot;, r[1], ff[1]);
		if(oa[oa.length-1] == &quot; &quot;) oa = oa.substr(0,oa.length-1) + &quot;0&quot;;
		o += oa + r[2] + &quot;/&quot; + r[3];
		oa = rpad_(ff[2],ri);
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
		o += oa;
		return o;
	}
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
		ri = Math.min(Math.max(r[1].length, r[4].length),7);
		ff = frac(aval, Math.pow(10,ri)-1, true);
		return sign + (ff[0]||(ff[1] ? &quot;&quot; : &quot;0&quot;)) + &quot; &quot; + (ff[1] ? pad_(ff[1],ri) + r[2] + &quot;/&quot; + r[3] + rpad_(ff[2],ri): fill(&quot; &quot;, 2*ri+1 + r[2].length + r[3].length));
	}
	if((r = fmt.match(/^[#0?]+$/)) !== null) {
		o = pad0r(val, 0);
		if(fmt.length &lt;= o.length) return o;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;
	}
  if((r = fmt.match(/^([#0?]+)\.([#0]+)$/)) !== null) {
		o = &quot;&quot; + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,&quot;$1&quot;);
		ri = o.indexOf(&quot;.&quot;);
		var lres = fmt.indexOf(&quot;.&quot;) - ri, rres = fmt.length - o.length - lres;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
	}
	if((r = fmt.match(/^00,000\.([#0]*0)$/)) !== null) {
		ri = dec(val, r[1].length);
		return val &lt; 0 ? &quot;-&quot; + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/,&quot;0$&amp;&quot;).replace(/^\d*$/,function($$) { return &quot;00,&quot; + ($$.length &lt; 3 ? pad0(0,3-$$.length) : &quot;&quot;) + $$; }) + &quot;.&quot; + pad0(ri,r[1].length);
	}
	switch(fmt) {
		case &quot;#,###&quot;: var x = commaify(pad0r(aval,0)); return x !== &quot;0&quot; ? sign + x : &quot;&quot;;
		default:
	}
	throw new Error(&quot;unsupported format |&quot; + fmt + &quot;|&quot;);
}
function write_num_cm2(type, fmt, val){
	var idx = fmt.length - 1;
	while(fmt.charCodeAt(idx-1) === 44) --idx;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));
}
function write_num_pct2(type, fmt, val){
	var sfmt = fmt.replace(pct1,&quot;&quot;), mul = fmt.length - sfmt.length;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill(&quot;%&quot;,mul);
}
function write_num_exp2(fmt, val){
	var o;
	var idx = fmt.indexOf(&quot;E&quot;) - fmt.indexOf(&quot;.&quot;) - 1;
	if(fmt.match(/^#+0.0E\+0$/)) {
		var period = fmt.indexOf(&quot;.&quot;); if(period === -1) period=fmt.indexOf(&#x27;E&#x27;);
		var ee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E)%period;
		if(ee &lt; 0) ee += period;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
		if(!o.match(/[Ee]/)) {
			var fakee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E);
			if(o.indexOf(&quot;.&quot;) === -1) o = o[0] + &quot;.&quot; + o.substr(1) + &quot;E+&quot; + (fakee - o.length+ee);
			else o += &quot;E+&quot; + (fakee - ee);
			o = o.replace(/\+-/,&quot;-&quot;);
		}
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + &quot;.&quot; + $3.substr(ee) + &quot;E&quot;; });
	} else o = val.toExponential(idx);
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + &quot;0&quot; + o[o.length-1];
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,&quot;e&quot;);
	return o.replace(&quot;e&quot;,&quot;E&quot;);
}
function write_num_int(type, fmt, val) {
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {
		var ffmt = fmt.replace(/\( */,&quot;&quot;).replace(/ \)/,&quot;&quot;).replace(/\)/,&quot;&quot;);
		if(val &gt;= 0) return write_num_int(&#x27;n&#x27;, ffmt, val);
		return &#x27;(&#x27; + write_num_int(&#x27;n&#x27;, ffmt, -val) + &#x27;)&#x27;;
	}
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
	if(fmt.indexOf(&#x27;%&#x27;) !== -1) return write_num_pct2(type, fmt, val);
	if(fmt.indexOf(&#x27;E&#x27;) !== -1) return write_num_exp2(fmt, val);
	if(fmt.charCodeAt(0) === 36) return &quot;$&quot;+write_num_int(type,fmt.substr(fmt[1]==&#x27; &#x27;?2:1),val);
	var o;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? &quot;-&quot; : &quot;&quot;;
	if(fmt.match(/^00+$/)) return sign + pad0(aval,fmt.length);
	if(fmt.match(/^[#?]+$/)) {
		o = (&quot;&quot;+val); if(val === 0) o = &quot;&quot;;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
	}
	if((r = fmt.match(frac1)) !== null) return write_num_f2(r, aval, sign);
	if(fmt.match(/^#+0+$/) !== null) return sign + pad0(aval,fmt.length - fmt.indexOf(&quot;0&quot;));
	if((r = fmt.match(dec1)) !== null) {
		o = (&quot;&quot;+val).replace(/^([^\.]+)$/,&quot;$1.&quot;+r[1]).replace(/\.$/,&quot;.&quot;+r[1]).replace(/\.(\d*)$/,function($$, $1) { return &quot;.&quot; + $1 + fill(&quot;0&quot;, r[1].length-$1.length); });
		return fmt.indexOf(&quot;0.&quot;) !== -1 ? o : o.replace(/^0\./,&quot;.&quot;);
	}
	fmt = fmt.replace(/^#+([0.])/, &quot;$1&quot;);
	if((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
		return sign + (&quot;&quot;+aval).replace(/\.(\d*[1-9])0*$/,&quot;.$1&quot;).replace(/^(-?\d*)$/,&quot;$1.&quot;).replace(/^0\./,r[1].length?&quot;0.&quot;:&quot;.&quot;);
	}
	if((r = fmt.match(/^#,##0(\.?)$/)) !== null) return sign + commaify((&quot;&quot;+aval));
	if((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
		return val &lt; 0 ? &quot;-&quot; + write_num_int(type, fmt, -val) : commaify((&quot;&quot;+val)) + &quot;.&quot; + fill(&#x27;0&#x27;,r[1].length);
	}
	if((r = fmt.match(/^#,#*,#0/)) !== null) return write_num_int(type,fmt.replace(/^#,#*,/,&quot;&quot;),val);
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
		o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g,&quot;&quot;), val));
		ri = 0;
		return _strrev(_strrev(fmt.replace(/\\/g,&quot;&quot;)).replace(/[0#]/g,function(x){return ri&lt;o.length?o[ri++]:x===&#x27;0&#x27;?&#x27;0&#x27;:&quot;&quot;;}));
	}
	if(fmt.match(phone) !== null) {
		o = write_num_int(type, &quot;##########&quot;, val);
		return &quot;(&quot; + o.substr(0,3) + &quot;) &quot; + o.substr(3, 3) + &quot;-&quot; + o.substr(6);
	}
	var oa = &quot;&quot;;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
		ri = Math.min(r[4].length,7);
		ff = frac(aval, Math.pow(10,ri)-1, false);
		o = &quot;&quot; + sign;
		oa = write_num(&quot;n&quot;, r[1], ff[1]);
		if(oa[oa.length-1] == &quot; &quot;) oa = oa.substr(0,oa.length-1) + &quot;0&quot;;
		o += oa + r[2] + &quot;/&quot; + r[3];
		oa = rpad_(ff[2],ri);
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
		o += oa;
		return o;
	}
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
		ri = Math.min(Math.max(r[1].length, r[4].length),7);
		ff = frac(aval, Math.pow(10,ri)-1, true);
		return sign + (ff[0]||(ff[1] ? &quot;&quot; : &quot;0&quot;)) + &quot; &quot; + (ff[1] ? pad_(ff[1],ri) + r[2] + &quot;/&quot; + r[3] + rpad_(ff[2],ri): fill(&quot; &quot;, 2*ri+1 + r[2].length + r[3].length));
	}
	if((r = fmt.match(/^[#0?]+$/)) !== null) {
		o = &quot;&quot; + val;
		if(fmt.length &lt;= o.length) return o;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;
	}
	if((r = fmt.match(/^([#0]+)\.([#0]+)$/)) !== null) {
		o = &quot;&quot; + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,&quot;$1&quot;);
		ri = o.indexOf(&quot;.&quot;);
		var lres = fmt.indexOf(&quot;.&quot;) - ri, rres = fmt.length - o.length - lres;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
	}
	if((r = fmt.match(/^00,000\.([#0]*0)$/)) !== null) {
		return val &lt; 0 ? &quot;-&quot; + write_num_int(type, fmt, -val) : commaify(&quot;&quot;+val).replace(/^\d,\d{3}$/,&quot;0$&amp;&quot;).replace(/^\d*$/,function($$) { return &quot;00,&quot; + ($$.length &lt; 3 ? pad0(0,3-$$.length) : &quot;&quot;) + $$; }) + &quot;.&quot; + pad0(0,r[1].length);
	}
	switch(fmt) {
		case &quot;#,###&quot;: var x = commaify(&quot;&quot;+aval); return x !== &quot;0&quot; ? sign + x : &quot;&quot;;
		default:
	}
	throw new Error(&quot;unsupported format |&quot; + fmt + &quot;|&quot;);
}
return function write_num(type, fmt, val) {
	return (val|0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
};})();
function split_fmt(fmt) {
	var out = [];
	var in_str = false, cc;
	for(var i = 0, j = 0; i &lt; fmt.length; ++i) switch((cc=fmt.charCodeAt(i))) {
		case 34: /* &#x27;&quot;&#x27; */
			in_str = !in_str; break;
		case 95: case 42: case 92: /* &#x27;_&#x27; &#x27;*&#x27; &#x27;\\&#x27; */
			++i; break;
		case 59: /* &#x27;;&#x27; */
			out[out.length] = fmt.substr(j,i-j);
			j = i+1;
	}
	out[out.length] = fmt.substr(j);
	if(in_str === true) throw new Error(&quot;Format |&quot; + fmt + &quot;| unterminated string &quot;);
	return out;
}
SSF._split = split_fmt;
var abstime = /\[[HhMmSs]*\]/;
function eval_fmt(fmt, v, opts, flen) {
	var out = [], o = &quot;&quot;, i = 0, c = &quot;&quot;, lst=&#x27;t&#x27;, q, dt, j, cc;
	var hr=&#x27;H&#x27;;
	/* Tokenize */
	while(i &lt; fmt.length) {
		switch((c = fmt[i])) {
			case &#x27;G&#x27;: /* General */
				if(!isgeneral(fmt, i)) throw new Error(&#x27;unrecognized character &#x27; + c + &#x27; in &#x27; +fmt);
				out[out.length] = {t:&#x27;G&#x27;, v:&#x27;General&#x27;}; i+=7; break;
			case &#x27;&quot;&#x27;: /* Literal text */
				for(o=&quot;&quot;;(cc=fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;) o += String.fromCharCode(cc);
				out[out.length] = {t:&#x27;t&#x27;, v:o}; ++i; break;
			case &#x27;\\&#x27;: var w = fmt[++i], t = (w === &quot;(&quot; || w === &quot;)&quot;) ? w : &#x27;t&#x27;;
				out[out.length] = {t:t, v:w}; ++i; break;
			case &#x27;_&#x27;: out[out.length] = {t:&#x27;t&#x27;, v:&quot; &quot;}; i+=2; break;
			case &#x27;@&#x27;: /* Text Placeholder */
				out[out.length] = {t:&#x27;T&#x27;, v:v}; ++i; break;
			case &#x27;B&#x27;: case &#x27;b&#x27;:
				if(fmt[i+1] === &quot;1&quot; || fmt[i+1] === &quot;2&quot;) {
          if(dt==null) { dt=parse_date_code(v, opts, fmt[i+1] === &quot;2&quot;); if(dt==null) return &quot;&quot;; }
					out[out.length] = {t:&#x27;X&#x27;, v:fmt.substr(i,2)}; lst = c; i+=2; break;
				}
				/* falls through */
			case &#x27;M&#x27;: case &#x27;D&#x27;: case &#x27;Y&#x27;: case &#x27;H&#x27;: case &#x27;S&#x27;: case &#x27;E&#x27;:
				c = c.toLowerCase();
				/* falls through */
			case &#x27;m&#x27;: case &#x27;d&#x27;: case &#x27;y&#x27;: case &#x27;h&#x27;: case &#x27;s&#x27;: case &#x27;e&#x27;: case &#x27;g&#x27;:
				if(v &lt; 0) return &quot;&quot;;
				if(dt==null) { dt=parse_date_code(v, opts); if(dt==null) return &quot;&quot;; }
				o = c; while(++i&lt;fmt.length &amp;&amp; fmt[i].toLowerCase() === c) o+=c;
				if(c === &#x27;m&#x27; &amp;&amp; lst.toLowerCase() === &#x27;h&#x27;) c = &#x27;M&#x27;; /* m = minute */
				if(c === &#x27;h&#x27;) c = hr;
				out[out.length] = {t:c, v:o}; lst = c; break;
			case &#x27;A&#x27;:
				q={t:c, v:&quot;A&quot;};
				if(dt==null) dt=parse_date_code(v, opts);
        if(fmt.substr(i, 3) === &quot;A/P&quot;) { if(dt!=null) q.v = dt.H &gt;= 12 ? &quot;P&quot; : &quot;A&quot;; q.t = &#x27;T&#x27;; hr=&#x27;h&#x27;;i+=3;}
        else if(fmt.substr(i,5) === &quot;AM/PM&quot;) { if(dt!=null) q.v = dt.H &gt;= 12 ? &quot;PM&quot; : &quot;AM&quot;; q.t = &#x27;T&#x27;; i+=5; hr=&#x27;h&#x27;; }
				else { q.t = &quot;t&quot;; ++i; }
				if(dt==null &amp;&amp; q.t === &#x27;T&#x27;) return &quot;&quot;;
				out[out.length] = q; lst = c; break;
			case &#x27;[&#x27;:
				o = c;
				while(fmt[i++] !== &#x27;]&#x27; &amp;&amp; i &lt; fmt.length) o += fmt[i];
				if(o.substr(-1) !== &#x27;]&#x27;) throw &#x27;unterminated &quot;[&quot; block: |&#x27; + o + &#x27;|&#x27;;
				if(o.match(abstime)) {
					if(dt==null) { dt=parse_date_code(v, opts); if(dt==null) return &quot;&quot;; }
					out[out.length] = {t:&#x27;Z&#x27;, v:o.toLowerCase()};
				} else { o=&quot;&quot;; }
				break;
			/* Numbers */
			case &#x27;.&#x27;:
				if(dt != null) {
					o = c; while((c=fmt[++i]) === &quot;0&quot;) o += c;
					out[out.length] = {t:&#x27;s&#x27;, v:o}; break;
				}
				/* falls through */
			case &#x27;0&#x27;: case &#x27;#&#x27;:
				o = c; while(&quot;0#?.,E+-%&quot;.indexOf(c=fmt[++i]) &gt; -1 || c==&#x27;\\&#x27; &amp;&amp; fmt[i+1] == &quot;-&quot; &amp;&amp; &quot;0#&quot;.indexOf(fmt[i+2])&gt;-1) o += c;
				out[out.length] = {t:&#x27;n&#x27;, v:o}; break;
			case &#x27;?&#x27;:
				o = c; while(fmt[++i] === c) o+=c;
				q={t:c, v:o}; out[out.length] = q; lst = c; break;
			case &#x27;*&#x27;: ++i; if(fmt[i] == &#x27; &#x27; || fmt[i] == &#x27;*&#x27;) ++i; break; // **
			case &#x27;(&#x27;: case &#x27;)&#x27;: out[out.length] = {t:(flen===1?&#x27;t&#x27;:c), v:c}; ++i; break;
			case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
				o = c; while(&quot;0123456789&quot;.indexOf(fmt[++i]) &gt; -1) o+=fmt[i];
				out[out.length] = {t:&#x27;D&#x27;, v:o}; break;
			case &#x27; &#x27;: out[out.length] = {t:c, v:c}; ++i; break;
			default:
				if(&quot;,$-+/():!^&amp;&#x27;~{}&lt;&gt;=€acfijklopqrtuvwxz&quot;.indexOf(c) === -1) throw new Error(&#x27;unrecognized character &#x27; + c + &#x27; in &#x27; + fmt);
				out[out.length] = {t:&#x27;t&#x27;, v:c}; ++i; break;
		}
	}
	var bt = 0, ss0 = 0, ssm;
	for(i=out.length-1, lst=&#x27;t&#x27;; i &gt;= 0; --i) {
		switch(out[i].t) {
			case &#x27;h&#x27;: case &#x27;H&#x27;: out[i].t = hr; lst=&#x27;h&#x27;; if(bt &lt; 1) bt = 1; break;
			case &#x27;s&#x27;:
				if((ssm=out[i].v.match(/\.0+$/))) ss0=Math.max(ss0,ssm[0].length-1);
				if(bt &lt; 3) bt = 3;
			/* falls through */
			case &#x27;d&#x27;: case &#x27;y&#x27;: case &#x27;M&#x27;: case &#x27;e&#x27;: lst=out[i].t; break;
			case &#x27;m&#x27;: if(lst === &#x27;s&#x27;) { out[i].t = &#x27;M&#x27;; if(bt &lt; 2) bt = 2; } break;
			case &#x27;X&#x27;: if(out[i].v === &quot;B2&quot;);
				break;
			case &#x27;Z&#x27;:
				if(bt &lt; 1 &amp;&amp; out[i].v.match(/[Hh]/)) bt = 1;
				if(bt &lt; 2 &amp;&amp; out[i].v.match(/[Mm]/)) bt = 2;
				if(bt &lt; 3 &amp;&amp; out[i].v.match(/[Ss]/)) bt = 3;
		}
	}
	switch(bt) {
		case 0: break;
		case 1:
			if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }
			if(dt.M &gt;=  60) { dt.M = 0; ++dt.H; }
			break;
		case 2:
			if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }
			break;
	}
	/* replace fields */
	var nstr = &quot;&quot;, jj;
	for(i=0; i &lt; out.length; ++i) {
		switch(out[i].t) {
			case &#x27;t&#x27;: case &#x27;T&#x27;: case &#x27; &#x27;: case &#x27;D&#x27;: break;
			case &#x27;X&#x27;: out[i] = undefined; break;
			case &#x27;d&#x27;: case &#x27;m&#x27;: case &#x27;y&#x27;: case &#x27;h&#x27;: case &#x27;H&#x27;: case &#x27;M&#x27;: case &#x27;s&#x27;: case &#x27;e&#x27;: case &#x27;b&#x27;: case &#x27;Z&#x27;:
				out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
				out[i].t = &#x27;t&#x27;; break;
			case &#x27;n&#x27;: case &#x27;(&#x27;: case &#x27;?&#x27;:
				jj = i+1;
				while(out[jj] != null &amp;&amp; (
					(c=out[jj].t) === &quot;?&quot; || c === &quot;D&quot; ||
					(c === &quot; &quot; || c === &quot;t&quot;) &amp;&amp; out[jj+1] != null &amp;&amp; (out[jj+1].t === &#x27;?&#x27; || out[jj+1].t === &quot;t&quot; &amp;&amp; out[jj+1].v === &#x27;/&#x27;) ||
					out[i].t === &#x27;(&#x27; &amp;&amp; (c === &#x27; &#x27; || c === &#x27;n&#x27; || c === &#x27;)&#x27;) ||
					c === &#x27;t&#x27; &amp;&amp; (out[jj].v === &#x27;/&#x27; || &#x27;$€&#x27;.indexOf(out[jj].v) &gt; -1 || out[jj].v === &#x27; &#x27; &amp;&amp; out[jj+1] != null &amp;&amp; out[jj+1].t == &#x27;?&#x27;)
				)) {
					out[i].v += out[jj].v;
					out[jj] = undefined; ++jj;
				}
				nstr += out[i].v;
				i = jj-1; break;
			case &#x27;G&#x27;: out[i].t = &#x27;t&#x27;; out[i].v = general_fmt(v,opts); break;
		}
	}
	var vv = &quot;&quot;, myv, ostr;
	if(nstr.length &gt; 0) {
		myv = (v&lt;0&amp;&amp;nstr.charCodeAt(0) === 45 ? -v : v); /* &#x27;-&#x27; */
		ostr = write_num(nstr.charCodeAt(0) === 40 ? &#x27;(&#x27; : &#x27;n&#x27;, nstr, myv); /* &#x27;(&#x27; */
		jj=ostr.length-1;
		var decpt = out.length;
		for(i=0; i &lt; out.length; ++i) if(out[i] != null &amp;&amp; out[i].v.indexOf(&quot;.&quot;) &gt; -1) { decpt = i; break; }
		var lasti=out.length;
		if(decpt === out.length &amp;&amp; ostr.indexOf(&quot;E&quot;) === -1) {
			for(i=out.length-1; i&gt;= 0;--i) {
				if(out[i] == null || &#x27;n?(&#x27;.indexOf(out[i].t) === -1) continue;
				if(jj&gt;=out[i].v.length-1) { jj -= out[i].v.length; out[i].v = ostr.substr(jj+1, out[i].v.length); }
				else if(jj &lt; 0) out[i].v = &quot;&quot;;
				else { out[i].v = ostr.substr(0, jj+1); jj = -1; }
				out[i].t = &#x27;t&#x27;;
				lasti = i;
			}
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
		}
		else if(decpt !== out.length &amp;&amp; ostr.indexOf(&quot;E&quot;) === -1) {
			jj = ostr.indexOf(&quot;.&quot;)-1;
			for(i=decpt; i&gt;= 0; --i) {
				if(out[i] == null || &#x27;n?(&#x27;.indexOf(out[i].t) === -1) continue;
				j=out[i].v.indexOf(&quot;.&quot;)&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(&quot;.&quot;)-1:out[i].v.length-1;
				vv = out[i].v.substr(j+1);
				for(; j&gt;=0; --j) {
					if(jj&gt;=0 &amp;&amp; (out[i].v[j] === &quot;0&quot; || out[i].v[j] === &quot;#&quot;)) vv = ostr[jj--] + vv;
				}
				out[i].v = vv;
				out[i].t = &#x27;t&#x27;;
				lasti = i;
			}
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
			jj = ostr.indexOf(&quot;.&quot;)+1;
			for(i=decpt; i&lt;out.length; ++i) {
				if(out[i] == null || &#x27;n?(&#x27;.indexOf(out[i].t) === -1 &amp;&amp; i !== decpt ) continue;
				j=out[i].v.indexOf(&quot;.&quot;)&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(&quot;.&quot;)+1:0;
				vv = out[i].v.substr(0,j);
				for(; j&lt;out[i].v.length; ++j) {
					if(jj&lt;ostr.length) vv += ostr[jj++];
				}
				out[i].v = vv;
				out[i].t = &#x27;t&#x27;;
				lasti = i;
			}
		}
	}
	for(i=0; i&lt;out.length; ++i) if(out[i] != null &amp;&amp; &#x27;n(?&#x27;.indexOf(out[i].t)&gt;-1) {
		myv = (flen &gt;1 &amp;&amp; v &lt; 0 &amp;&amp; i&gt;0 &amp;&amp; out[i-1].v === &quot;-&quot; ? -v:v);
		out[i].v = write_num(out[i].t, out[i].v, myv);
		out[i].t = &#x27;t&#x27;;
	}
	var retval = &quot;&quot;;
	for(i=0; i !== out.length; ++i) if(out[i] != null) retval += out[i].v;
	return retval;
}
SSF._eval = eval_fmt;
var cfregex = /\[[=&lt;&gt;]/;
var cfregex2 = /\[([=&lt;&gt;]*)(-?\d+\.?\d*)\]/;
function chkcond(v, rr) {
	if(rr == null) return false;
	var thresh = parseFloat(rr[2]);
	switch(rr[1]) {
		case &quot;=&quot;:  if(v == thresh) return true; break;
		case &quot;&gt;&quot;:  if(v &gt;  thresh) return true; break;
		case &quot;&lt;&quot;:  if(v &lt;  thresh) return true; break;
		case &quot;&lt;&gt;&quot;: if(v != thresh) return true; break;
		case &quot;&gt;=&quot;: if(v &gt;= thresh) return true; break;
		case &quot;&lt;=&quot;: if(v &lt;= thresh) return true; break;
	}
	return false;
}
function choose_fmt(f, v) {
	var fmt = split_fmt(f);
	var l = fmt.length, lat = fmt[l-1].indexOf(&quot;@&quot;);
	if(l&lt;4 &amp;&amp; lat&gt;-1) --l;
	if(fmt.length &gt; 4) throw &quot;cannot find right format for |&quot; + fmt + &quot;|&quot;;
	if(typeof v !== &quot;number&quot;) return [4, fmt.length === 4 || lat&gt;-1?fmt[fmt.length-1]:&quot;@&quot;];
	switch(fmt.length) {
		case 1: fmt = lat&gt;-1 ? [&quot;General&quot;, &quot;General&quot;, &quot;General&quot;, fmt[0]] : [fmt[0], fmt[0], fmt[0], &quot;@&quot;]; break;
		case 2: fmt = lat&gt;-1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], &quot;@&quot;]; break;
		case 3: fmt = lat&gt;-1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], &quot;@&quot;]; break;
		case 4: break;
	}
	var ff = v &gt; 0 ? fmt[0] : v &lt; 0 ? fmt[1] : fmt[2];
	if(fmt[0].indexOf(&quot;[&quot;) === -1 &amp;&amp; fmt[1].indexOf(&quot;[&quot;) === -1) return [l, ff];
	if(fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {
		var m1 = fmt[0].match(cfregex2);
		var m2 = fmt[1].match(cfregex2);
		return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null &amp;&amp; m2 != null ? 2 : 1]];
	}
	return [l, ff];
}
function format(fmt,v,o) {
	fixopts(o != null ? o : (o=[]));
	var sfmt = &quot;&quot;;
	switch(typeof fmt) {
		case &quot;string&quot;: sfmt = fmt; break;
		case &quot;number&quot;: sfmt = (o.table != null ? o.table : table_fmt)[fmt]; break;
	}
	if(isgeneral(sfmt,0)) return general_fmt(v, o);
	var f = choose_fmt(sfmt, v);
	if(isgeneral(f[1])) return general_fmt(v, o);
	if(v === true) v = &quot;TRUE&quot;; else if(v === false) v = &quot;FALSE&quot;;
	else if(v === &quot;&quot; || v == null) return &quot;&quot;;
	return eval_fmt(f[1], v, o, f[0]);
}
SSF._table = table_fmt;
SSF.load = function load_entry(fmt, idx) { table_fmt[idx] = fmt; };
SSF.format = format;
SSF.get_table = function get_table() { return table_fmt; };
SSF.load_table = function load_table(tbl) { for(var i=0; i!=0x0188; ++i) if(tbl[i] !== undefined) SSF.load(tbl[i], i); };
};
make_ssf(SSF);
/* map from xlml named formats to SSF TODO: localize */
var XLMLFormatMap = {
	&quot;General Number&quot;: &quot;General&quot;,
	&quot;General Date&quot;: SSF._table[22],
	&quot;Long Date&quot;: &quot;dddd, mmmm dd, yyyy&quot;,
	&quot;Medium Date&quot;: SSF._table[15],
	&quot;Short Date&quot;: SSF._table[14],
	&quot;Long Time&quot;: SSF._table[19],
	&quot;Medium Time&quot;: SSF._table[18],
	&quot;Short Time&quot;: SSF._table[20],
	&quot;Currency&quot;: &#x27;&quot;$&quot;#,##0.00_);[Red]\\(&quot;$&quot;#,##0.00\\)&#x27;,
	&quot;Fixed&quot;: SSF._table[2],
	&quot;Standard&quot;: SSF._table[4],
	&quot;Percent&quot;: SSF._table[10],
	&quot;Scientific&quot;: SSF._table[11],
	&quot;Yes/No&quot;: &#x27;&quot;Yes&quot;;&quot;Yes&quot;;&quot;No&quot;;@&#x27;,
	&quot;True/False&quot;: &#x27;&quot;True&quot;;&quot;True&quot;;&quot;False&quot;;@&#x27;,
	&quot;On/Off&quot;: &#x27;&quot;Yes&quot;;&quot;Yes&quot;;&quot;No&quot;;@&#x27;
};

var DO_NOT_EXPORT_CFB = true;
/* cfb.js (C) 2013-2014 SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*jshint eqnull:true */

/* [MS-CFB] v20130118 */
var CFB = (function _CFB(){
var exports = {};
exports.version = &#x27;0.10.2&#x27;;
function parse(file) {
var mver = 3; // major version
var ssz = 512; // sector size
var nmfs = 0; // number of mini FAT sectors
var ndfs = 0; // number of DIFAT sectors
var dir_start = 0; // first directory sector location
var minifat_start = 0; // first mini FAT sector location
var difat_start = 0; // first mini FAT sector location

var fat_addrs = []; // locations of FAT sectors

/* [MS-CFB] 2.2 Compound File Header */
var blob = file.slice(0,512);
prep_blob(blob, 0);

/* major version */
var mv = check_get_mver(blob);
mver = mv[0];
switch(mver) {
	case 3: ssz = 512; break; case 4: ssz = 4096; break;
	default: throw &quot;Major Version: Expected 3 or 4 saw &quot; + mver;
}

/* reprocess header */
if(ssz !== 512) { blob = file.slice(0,ssz); prep_blob(blob, 28 /* blob.l */); }
/* Save header for final object */
var header = file.slice(0,ssz);

check_shifts(blob, mver);

// Number of Directory Sectors
var nds = blob.read_shift(4, &#x27;i&#x27;);
if(mver === 3 &amp;&amp; nds !== 0) throw &#x27;# Directory Sectors: Expected 0 saw &#x27; + nds;

// Number of FAT Sectors
//var nfs = blob.read_shift(4, &#x27;i&#x27;);
blob.l += 4;

// First Directory Sector Location
dir_start = blob.read_shift(4, &#x27;i&#x27;);

// Transaction Signature
blob.l += 4;

// Mini Stream Cutoff Size
blob.chk(&#x27;00100000&#x27;, &#x27;Mini Stream Cutoff Size: &#x27;);

// First Mini FAT Sector Location
minifat_start = blob.read_shift(4, &#x27;i&#x27;);

// Number of Mini FAT Sectors
nmfs = blob.read_shift(4, &#x27;i&#x27;);

// First DIFAT sector location
difat_start = blob.read_shift(4, &#x27;i&#x27;);

// Number of DIFAT Sectors
ndfs = blob.read_shift(4, &#x27;i&#x27;);

// Grab FAT Sector Locations
for(var q, j = 0; j &lt; 109; ++j) { /* 109 = (512 - blob.l)&gt;&gt;&gt;2; */
	q = blob.read_shift(4, &#x27;i&#x27;);
	if(q&lt;0) break;
	fat_addrs[j] = q;
}

/** Break the file up into sectors */
var sectors = sectorify(file, ssz);

sleuth_fat(difat_start, ndfs, sectors, ssz, fat_addrs);

/** Chains */
var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);

sector_list[dir_start].name = &quot;!Directory&quot;;
if(nmfs &gt; 0 &amp;&amp; minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = &quot;!MiniFAT&quot;;
sector_list[fat_addrs[0]].name = &quot;!FAT&quot;;
sector_list.fat_addrs = fat_addrs;
sector_list.ssz = ssz;

/* [MS-CFB] 2.6.1 Compound File Directory Entry */
var files = {}, Paths = [], FileIndex = [], FullPaths = [], FullPathDir = {};
read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex);

build_full_paths(FileIndex, FullPathDir, FullPaths, Paths);

var root_name = Paths.shift();
Paths.root = root_name;

/* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */
var find_path = make_find_path(FullPaths, Paths, FileIndex, files, root_name);

return {
	raw: {header: header, sectors: sectors},
	FileIndex: FileIndex,
	FullPaths: FullPaths,
	FullPathDir: FullPathDir,
	find: find_path
};
} // parse

/* [MS-CFB] 2.2 Compound File Header -- read up to major version */
function check_get_mver(blob) {
	// header signature 8
	blob.chk(HEADER_SIGNATURE, &#x27;Header Signature: &#x27;);

	// clsid 16
	blob.chk(HEADER_CLSID, &#x27;CLSID: &#x27;);

	// minor version 2
	var mver = blob.read_shift(2, &#x27;u&#x27;);

	return [blob.read_shift(2,&#x27;u&#x27;), mver];
}
function check_shifts(blob, mver) {
	var shift = 0x09;

	// Byte Order
	blob.chk(&#x27;feff&#x27;, &#x27;Byte Order: &#x27;);

	// Sector Shift
	switch((shift = blob.read_shift(2))) {
		case 0x09: if(mver !== 3) throw &#x27;MajorVersion/SectorShift Mismatch&#x27;; break;
		case 0x0c: if(mver !== 4) throw &#x27;MajorVersion/SectorShift Mismatch&#x27;; break;
		default: throw &#x27;Sector Shift: Expected 9 or 12 saw &#x27; + shift;
	}

	// Mini Sector Shift
	blob.chk(&#x27;0600&#x27;, &#x27;Mini Sector Shift: &#x27;);

	// Reserved
	blob.chk(&#x27;000000000000&#x27;, &#x27;Reserved: &#x27;);
}

/** Break the file up into sectors */
function sectorify(file, ssz) {
	var nsectors = Math.ceil(file.length/ssz)-1;
	var sectors = new Array(nsectors);
	for(var i=1; i &lt; nsectors; ++i) sectors[i-1] = file.slice(i*ssz,(i+1)*ssz);
	sectors[nsectors-1] = file.slice(nsectors*ssz);
	return sectors;
}

/* [MS-CFB] 2.6.4 Red-Black Tree */
function build_full_paths(FI, FPD, FP, Paths) {
	var i = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
	var dad = new Array(pl), q = new Array(pl);

	for(; i &lt; pl; ++i) { dad[i]=q[i]=i; FP[i]=Paths[i]; }

	for(; j &lt; q.length; ++j) {
		i = q[j];
		L = FI[i].L; R = FI[i].R; C = FI[i].C;
		if(dad[i] === i) {
			if(L !== -1 /*NOSTREAM*/ &amp;&amp; dad[L] !== L) dad[i] = dad[L];
			if(R !== -1 &amp;&amp; dad[R] !== R) dad[i] = dad[R];
		}
		if(C !== -1 /*NOSTREAM*/) dad[C] = i;
		if(L !== -1) { dad[L] = dad[i]; q.push(L); }
		if(R !== -1) { dad[R] = dad[i]; q.push(R); }
	}
	for(i=1; i !== pl; ++i) if(dad[i] === i) {
		if(R !== -1 /*NOSTREAM*/ &amp;&amp; dad[R] !== R) dad[i] = dad[R];
		else if(L !== -1 &amp;&amp; dad[L] !== L) dad[i] = dad[L];
	}

	for(i=1; i &lt; pl; ++i) {
		if(FI[i].type === 0 /* unknown */) continue;
		j = dad[i];
		if(j === 0) FP[i] = FP[0] + &quot;/&quot; + FP[i];
		else while(j !== 0) {
			FP[i] = FP[j] + &quot;/&quot; + FP[i];
			j = dad[j];
		}
		dad[i] = 0;
	}

	FP[0] += &quot;/&quot;;
	for(i=1; i &lt; pl; ++i) {
		if(FI[i].type !== 2 /* stream */) FP[i] += &quot;/&quot;;
		FPD[FP[i]] = FI[i];
	}
}

/* [MS-CFB] 2.6.4 */
function make_find_path(FullPaths, Paths, FileIndex, files, root_name) {
	var UCFullPaths = new Array(FullPaths.length);
	var UCPaths = new Array(Paths.length), i;
	for(i = 0; i &lt; FullPaths.length; ++i) UCFullPaths[i] = FullPaths[i].toUpperCase().replace(chr0,&#x27;&#x27;).replace(chr1,&#x27;!&#x27;);
	for(i = 0; i &lt; Paths.length; ++i) UCPaths[i] = Paths[i].toUpperCase().replace(chr0,&#x27;&#x27;).replace(chr1,&#x27;!&#x27;);
	return function find_path(path) {
		var k;
		if(path.charCodeAt(0) === 47 /* &quot;/&quot; */) { k=true; path = root_name + path; }
		else k = path.indexOf(&quot;/&quot;) !== -1;
		var UCPath = path.toUpperCase().replace(chr0,&#x27;&#x27;).replace(chr1,&#x27;!&#x27;);
		var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
		if(w === -1) return null;
		return k === true ? FileIndex[w] : files[Paths[w]];
	};
}

/** Chase down the rest of the DIFAT chain to build a comprehensive list
    DIFAT chains by storing the next sector number as the last 32 bytes */
function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
	var q;
	if(idx === ENDOFCHAIN) {
		if(cnt !== 0) throw &quot;DIFAT chain shorter than expected&quot;;
	} else if(idx !== -1 /*FREESECT*/) {
		var sector = sectors[idx], m = (ssz&gt;&gt;&gt;2)-1;
		for(var i = 0; i &lt; m; ++i) {
			if((q = __readInt32LE(sector,i*4)) === ENDOFCHAIN) break;
			fat_addrs.push(q);
		}
		sleuth_fat(__readInt32LE(sector,ssz-4),cnt - 1, sectors, ssz, fat_addrs);
	}
}

/** Follow the linked list of sectors for a given starting point */
function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
	var sl = sectors.length;
	var buf, buf_chain;
	if(!chkd) chkd = new Array(sl);
	var modulus = ssz - 1, j, jj;
	buf = [];
	buf_chain = [];
	for(j=start; j&gt;=0;) {
		chkd[j] = true;
		buf[buf.length] = j;
		buf_chain.push(sectors[j]);
		var addr = fat_addrs[Math.floor(j*4/ssz)];
		jj = ((j*4) &amp; modulus);
		if(ssz &lt; 4 + jj) throw &quot;FAT boundary crossed: &quot; + j + &quot; 4 &quot;+ssz;
		j = __readInt32LE(sectors[addr], jj);
	}
	return {nodes: buf, data:__toBuffer([buf_chain])};
}

/** Chase down the sector linked lists */
function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
	var sl = sectors.length, sector_list = new Array(sl);
	var chkd = new Array(sl), buf, buf_chain;
	var modulus = ssz - 1, i, j, k, jj;
	for(i=0; i &lt; sl; ++i) {
		buf = [];
		k = (i + dir_start); if(k &gt;= sl) k-=sl;
		if(chkd[k] === true) continue;
		buf_chain = [];
		for(j=k; j&gt;=0;) {
			chkd[j] = true;
			buf[buf.length] = j;
			buf_chain.push(sectors[j]);
			var addr = fat_addrs[Math.floor(j*4/ssz)];
			jj = ((j*4) &amp; modulus);
			if(ssz &lt; 4 + jj) throw &quot;FAT boundary crossed: &quot; + j + &quot; 4 &quot;+ssz;
			j = __readInt32LE(sectors[addr], jj);
		}
		sector_list[k] = {nodes: buf, data:__toBuffer([buf_chain])};
	}
	return sector_list;
}

/* [MS-CFB] 2.6.1 Compound File Directory Entry */
function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex) {
	var blob;
	var minifat_store = 0, pl = (Paths.length?2:0);
	var sector = sector_list[dir_start].data;
	var i = 0, namelen = 0, name, o, ctime, mtime;
	for(; i &lt; sector.length; i+= 128) {
		blob = sector.slice(i, i+128);
		prep_blob(blob, 64);
		namelen = blob.read_shift(2);
		if(namelen === 0) continue;
		name = __utf16le(blob,0,namelen-pl);
		Paths.push(name);
		o = {
			name:  name,
			type:  blob.read_shift(1),
			color: blob.read_shift(1),
			L:     blob.read_shift(4, &#x27;i&#x27;),
			R:     blob.read_shift(4, &#x27;i&#x27;),
			C:     blob.read_shift(4, &#x27;i&#x27;),
			clsid: blob.read_shift(16),
			state: blob.read_shift(4, &#x27;i&#x27;)
		};
		ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
		if(ctime !== 0) {
			o.ctime = ctime; o.ct = read_date(blob, blob.l-8);
		}
		mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
		if(mtime !== 0) {
			o.mtime = mtime; o.mt = read_date(blob, blob.l-8);
		}
		o.start = blob.read_shift(4, &#x27;i&#x27;);
		o.size = blob.read_shift(4, &#x27;i&#x27;);
		if(o.type === 5) { /* root */
			minifat_store = o.start;
			if(nmfs &gt; 0 &amp;&amp; minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = &quot;!StreamData&quot;;
			/*minifat_size = o.size;*/
		} else if(o.size &gt;= 4096 /* MSCSZ */) {
			o.storage = &#x27;fat&#x27;;
			if(sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
			sector_list[o.start].name = o.name;
			o.content = sector_list[o.start].data.slice(0,o.size);
			prep_blob(o.content, 0);
		} else {
			o.storage = &#x27;minifat&#x27;;
			if(minifat_store !== ENDOFCHAIN &amp;&amp; o.start !== ENDOFCHAIN) {
				o.content = sector_list[minifat_store].data.slice(o.start*MSSZ,o.start*MSSZ+o.size);
				prep_blob(o.content, 0);
			}
		}
		files[name] = o;
		FileIndex.push(o);
	}
}

function read_date(blob, offset) {
	return new Date(( ( (__readUInt32LE(blob,offset+4)/1e7)*Math.pow(2,32)+__readUInt32LE(blob,offset)/1e7 ) - 11644473600)*1000);
}

var fs;
function readFileSync(filename, options) {
	if(fs === undefined) fs = require(&#x27;fs&#x27;);
	return parse(fs.readFileSync(filename), options);
}

function readSync(blob, options) {
	switch(options !== undefined &amp;&amp; options.type !== undefined ? options.type : &quot;base64&quot;) {
		case &quot;file&quot;: return readFileSync(blob, options);
		case &quot;base64&quot;: return parse(s2a(Base64.decode(blob)), options);
		case &quot;binary&quot;: return parse(s2a(blob), options);
	}
	return parse(blob);
}

/** CFB Constants */
var MSSZ = 64; /* Mini Sector Size = 1&lt;&lt;6 */
//var MSCSZ = 4096; /* Mini Stream Cutoff Size */
/* 2.1 Compound File Sector Numbers and Types */
var ENDOFCHAIN = -2;
/* 2.2 Compound File Header */
var HEADER_SIGNATURE = &#x27;d0cf11e0a1b11ae1&#x27;;
var HEADER_CLSID = &#x27;00000000000000000000000000000000&#x27;;
var consts = {
	/* 2.1 Compund File Sector Numbers and Types */
	MAXREGSECT: -6,
	DIFSECT: -4,
	FATSECT: -3,
	ENDOFCHAIN: ENDOFCHAIN,
	FREESECT: -1,
	/* 2.2 Compound File Header */
	HEADER_SIGNATURE: HEADER_SIGNATURE,
	HEADER_MINOR_VERSION: &#x27;3e00&#x27;,
	MAXREGSID: -6,
	NOSTREAM: -1,
	HEADER_CLSID: HEADER_CLSID,
	/* 2.6.1 Compound File Directory Entry */
	EntryTypes: [&#x27;unknown&#x27;,&#x27;storage&#x27;,&#x27;stream&#x27;,&#x27;lockbytes&#x27;,&#x27;property&#x27;,&#x27;root&#x27;]
};

exports.read = readSync;
exports.parse = parse;
exports.utils = {
	ReadShift: ReadShift,
	CheckField: CheckField,
	prep_blob: prep_blob,
	bconcat: bconcat,
	consts: consts
};

return exports;
})();

if(typeof require !== &#x27;undefined&#x27; &amp;&amp; typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof DO_NOT_EXPORT_CFB === &#x27;undefined&#x27;) { module.exports = CFB; }
function isval(x) { return x !== undefined &amp;&amp; x !== null; }

function keys(o) { return Object.keys(o); }

function evert_key(obj, key) {
	var o = [], K = keys(obj);
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]][key]] = K[i];
	return o;
}

function evert(obj) {
	var o = [], K = keys(obj);
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];
	return o;
}

function evert_num(obj) {
	var o = [], K = keys(obj);
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i],10);
	return o;
}

function evert_arr(obj) {
	var o = [], K = keys(obj);
	for(var i = 0; i !== K.length; ++i) {
		if(o[obj[K[i]]] == null) o[obj[K[i]]] = [];
		o[obj[K[i]]].push(K[i]);
	}
	return o;
}

/* TODO: date1904 logic */
function datenum(v, date1904) {
	if(date1904) v+=1462;
	var epoch = Date.parse(v);
	return (epoch + 2209161600000) / (24 * 60 * 60 * 1000);
}

function cc2str(arr) {
	var o = &quot;&quot;;
	for(var i = 0; i != arr.length; ++i) o += String.fromCharCode(arr[i]);
	return o;
}

function getdata(data) {
	if(!data) return null;
	if(data.name.substr(-4) === &quot;.bin&quot;) {
		if(data.data) return char_codes(data.data);
		if(data.asNodeBuffer &amp;&amp; has_buf) return data.asNodeBuffer();
		if(data._data &amp;&amp; data._data.getContent) return Array.prototype.slice.call(data._data.getContent());
	} else {
		if(data.data) return data.name.substr(-4) !== &quot;.bin&quot; ? debom_xml(data.data) : char_codes(data.data);
		if(data.asNodeBuffer &amp;&amp; has_buf) return debom_xml(data.asNodeBuffer().toString(&#x27;binary&#x27;));
		if(data.asBinary) return debom_xml(data.asBinary());
		if(data._data &amp;&amp; data._data.getContent) return debom_xml(cc2str(Array.prototype.slice.call(data._data.getContent(),0)));
	}
	return null;
}

function safegetzipfile(zip, file) {
	var f = file; if(zip.files[f]) return zip.files[f];
	f = file.toLowerCase(); if(zip.files[f]) return zip.files[f];
	f = f.replace(/\//g,&#x27;\\&#x27;); if(zip.files[f]) return zip.files[f];
	return null;
}

function getzipfile(zip, file) {
	var o = safegetzipfile(zip, file);
	if(o == null) throw new Error(&quot;Cannot find file &quot; + file + &quot; in zip&quot;);
	return o;
}

function getzipdata(zip, file, safe) {
	if(!safe) return getdata(getzipfile(zip, file));
	if(!file) return null;
	try { return getzipdata(zip, file); } catch(e) { return null; }
}

var _fs, jszip;
if(typeof JSZip !== &#x27;undefined&#x27;) jszip = JSZip;
if (typeof exports !== &#x27;undefined&#x27;) {
	if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
		if(has_buf &amp;&amp; typeof jszip === &#x27;undefined&#x27;) jszip = require(&#x27;js&#x27;+&#x27;zip&#x27;);
		if(typeof jszip === &#x27;undefined&#x27;) jszip = require(&#x27;./js&#x27;+&#x27;zip&#x27;).JSZip;
		_fs = require(&#x27;f&#x27;+&#x27;s&#x27;);
	}
}
var attregexg=/([\w:]+)=((?:&quot;)([^&quot;]*)(?:&quot;)|(?:&#x27;)([^&#x27;]*)(?:&#x27;))/g;
var tagregex=/&lt;[^&gt;]*&gt;/g;
var nsregex=/&lt;\w*:/, nsregex2 = /&lt;(\/?)\w+:/;
function parsexmltag(tag, skip_root) {
	var z = [];
	var eq = 0, c = 0;
	for(; eq !== tag.length; ++eq) if((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;
	if(!skip_root) z[0] = tag.substr(0, eq);
	if(eq === tag.length) return z;
	var m = tag.match(attregexg), j=0, w=&quot;&quot;, v=&quot;&quot;, i=0, q=&quot;&quot;, cc=&quot;&quot;;
	if(m) for(i = 0; i != m.length; ++i) {
		cc = m[i];
		for(c=0; c != cc.length; ++c) if(cc.charCodeAt(c) === 61) break;
		q = cc.substr(0,c); v = cc.substring(c+2, cc.length-1);
		for(j=0;j!=q.length;++j) if(q.charCodeAt(j) === 58) break;
		if(j===q.length) z[q] = v;
		else z[(j===5 &amp;&amp; q.substr(0,5)===&quot;xmlns&quot;?&quot;xmlns&quot;:&quot;&quot;)+q.substr(j+1)] = v;
	}
	return z;
}
function strip_ns(x) { return x.replace(nsregex2, &quot;&lt;$1&quot;); }

var encodings = {
	&#x27;&amp;quot;&#x27;: &#x27;&quot;&#x27;,
	&#x27;&amp;apos;&#x27;: &quot;&#x27;&quot;,
	&#x27;&amp;gt;&#x27;: &#x27;&gt;&#x27;,
	&#x27;&amp;lt;&#x27;: &#x27;&lt;&#x27;,
	&#x27;&amp;amp;&#x27;: &#x27;&amp;&#x27;
};
var rencoding = evert(encodings);
var rencstr = &quot;&amp;&lt;&gt;&#x27;\&quot;&quot;.split(&quot;&quot;);

// TODO: CP remap (need to read file version to determine OS)
var unescapexml = (function() {
	var encregex = /&amp;[a-z]*;/g, coderegex = /_x([\da-fA-F]+)_/g;
	return function unescapexml(text){
		var s = text + &#x27;&#x27;;
		return s.replace(encregex, function($$) { return encodings[$$]; }).replace(coderegex,function(m,c) {return String.fromCharCode(parseInt(c,16));});
	};
})();

var decregex=/[&amp;&lt;&gt;&#x27;&quot;]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
function escapexml(text){
	var s = text + &#x27;&#x27;;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(charegex,function(s) { return &quot;_x&quot; + (&quot;000&quot;+s.charCodeAt(0).toString(16)).substr(-4) + &quot;_&quot;;});
}

/* TODO: handle codepages */
var xlml_fixstr = (function() {
	var entregex = /&amp;#(\d+);/g;
	function entrepl($$,$1) { return String.fromCharCode(parseInt($1,10)); }
	return function xlml_fixstr(str) { return str.replace(entregex,entrepl); };
})();

function parsexmlbool(value, tag) {
	switch(value) {
		case &#x27;1&#x27;: case &#x27;true&#x27;: case &#x27;TRUE&#x27;: return true;
		/* case &#x27;0&#x27;: case &#x27;false&#x27;: case &#x27;FALSE&#x27;:*/
		default: return false;
	}
}

var utf8read = function utf8reada(orig) {
	var out = &quot;&quot;, i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
	while (i &lt; orig.length) {
		c = orig.charCodeAt(i++);
		if (c &lt; 128) { out += String.fromCharCode(c); continue; }
		d = orig.charCodeAt(i++);
		if (c&gt;191 &amp;&amp; c&lt;224) { out += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (d &amp; 63)); continue; }
		e = orig.charCodeAt(i++);
		if (c &lt; 240) { out += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((d &amp; 63) &lt;&lt; 6) | (e &amp; 63)); continue; }
		f = orig.charCodeAt(i++);
		w = (((c &amp; 7) &lt;&lt; 18) | ((d &amp; 63) &lt;&lt; 12) | ((e &amp; 63) &lt;&lt; 6) | (f &amp; 63))-65536;
		out += String.fromCharCode(0xD800 + ((w&gt;&gt;&gt;10)&amp;1023));
		out += String.fromCharCode(0xDC00 + (w&amp;1023));
	}
	return out;
};


if(has_buf) {
	var utf8readb = function utf8readb(data) {
		var out = new Buffer(2*data.length), w, i, j = 1, k = 0, ww=0, c;
		for(i = 0; i &lt; data.length; i+=j) {
			j = 1;
			if((c=data.charCodeAt(i)) &lt; 128) w = c;
			else if(c &lt; 224) { w = (c&amp;31)*64+(data.charCodeAt(i+1)&amp;63); j=2; }
			else if(c &lt; 240) { w=(c&amp;15)*4096+(data.charCodeAt(i+1)&amp;63)*64+(data.charCodeAt(i+2)&amp;63); j=3; }
			else { j = 4;
				w = (c &amp; 7)*262144+(data.charCodeAt(i+1)&amp;63)*4096+(data.charCodeAt(i+2)&amp;63)*64+(data.charCodeAt(i+3)&amp;63);
				w -= 65536; ww = 0xD800 + ((w&gt;&gt;&gt;10)&amp;1023); w = 0xDC00 + (w&amp;1023);
			}
			if(ww !== 0) { out[k++] = ww&amp;255; out[k++] = ww&gt;&gt;&gt;8; ww = 0; }
			out[k++] = w%256; out[k++] = w&gt;&gt;&gt;8;
		}
		out.length = k;
		return out.toString(&#x27;ucs2&#x27;);
	};
	var corpus = &quot;foo bar baz\u00e2\u0098\u0083\u00f0\u009f\u008d\u00a3&quot;;
	if(utf8read(corpus) == utf8readb(corpus)) utf8read = utf8readb;
	var utf8readc = function utf8readc(data) { return Buffer(data, &#x27;binary&#x27;).toString(&#x27;utf8&#x27;); };
	if(utf8read(corpus) == utf8readc(corpus)) utf8read = utf8readc;
}

// matches &lt;foo&gt;...&lt;/foo&gt; extracts content
var matchtag = (function() {
	var mtcache = {};
	return function matchtag(f,g) {
		var t = f+&quot;|&quot;+g;
		if(mtcache[t] !== undefined) return mtcache[t];
		return (mtcache[t] = new RegExp(&#x27;&lt;(?:\\w+:)?&#x27;+f+&#x27;(?: xml:space=&quot;preserve&quot;)?(?:[^&gt;]*)&gt;([^\u2603]*)&lt;/(?:\\w+:)?&#x27;+f+&#x27;&gt;&#x27;,(g||&quot;&quot;)));
	};
})();

var vtregex = (function(){ var vt_cache = {};
	return function vt_regex(bt) {
		if(vt_cache[bt] !== undefined) return vt_cache[bt];
		return (vt_cache[bt] = new RegExp(&quot;&lt;vt:&quot; + bt + &quot;&gt;(.*?)&lt;/vt:&quot; + bt + &quot;&gt;&quot;, &#x27;g&#x27;) );
};})();
var vtvregex = /&lt;\/?vt:variant&gt;/g, vtmregex = /&lt;vt:([^&gt;]*)&gt;(.*)&lt;/;
function parseVector(data) {
	var h = parsexmltag(data);

	var matches = data.match(vtregex(h.baseType))||[];
	if(matches.length != h.size) throw &quot;unexpected vector length &quot; + matches.length + &quot; != &quot; + h.size;
	var res = [];
	matches.forEach(function(x) {
		var v = x.replace(vtvregex,&quot;&quot;).match(vtmregex);
		res.push({v:v[2], t:v[1]});
	});
	return res;
}

var wtregex = /(^\s|\s$|\n)/;
function writetag(f,g) {return &#x27;&lt;&#x27; + f + (g.match(wtregex)?&#x27; xml:space=&quot;preserve&quot;&#x27; : &quot;&quot;) + &#x27;&gt;&#x27; + g + &#x27;&lt;/&#x27; + f + &#x27;&gt;&#x27;;}

function wxt_helper(h) { return keys(h).map(function(k) { return &quot; &quot; + k + &#x27;=&quot;&#x27; + h[k] + &#x27;&quot;&#x27;;}).join(&quot;&quot;); }
function writextag(f,g,h) { return &#x27;&lt;&#x27; + f + (isval(h) ? wxt_helper(h) : &quot;&quot;) + (isval(g) ? (g.match(wtregex)?&#x27; xml:space=&quot;preserve&quot;&#x27; : &quot;&quot;) + &#x27;&gt;&#x27; + g + &#x27;&lt;/&#x27; + f : &quot;/&quot;) + &#x27;&gt;&#x27;;}

function write_w3cdtf(d, t) { try { return d.toISOString().replace(/\.\d*/,&quot;&quot;); } catch(e) { if(t) throw e; } }

function write_vt(s) {
	switch(typeof s) {
		case &#x27;string&#x27;: return writextag(&#x27;vt:lpwstr&#x27;, s);
		case &#x27;number&#x27;: return writextag((s|0)==s?&#x27;vt:i4&#x27;:&#x27;vt:r8&#x27;, String(s));
		case &#x27;boolean&#x27;: return writextag(&#x27;vt:bool&#x27;,s?&#x27;true&#x27;:&#x27;false&#x27;);
	}
	if(s instanceof Date) return writextag(&#x27;vt:filetime&#x27;, write_w3cdtf(s));
	throw new Error(&quot;Unable to serialize &quot; + s);
}

var XML_HEADER = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;\r\n&#x27;;
var XMLNS = {
	&#x27;dc&#x27;: &#x27;http://purl.org/dc/elements/1.1/&#x27;,
	&#x27;dcterms&#x27;: &#x27;http://purl.org/dc/terms/&#x27;,
	&#x27;dcmitype&#x27;: &#x27;http://purl.org/dc/dcmitype/&#x27;,
	&#x27;mx&#x27;: &#x27;http://schemas.microsoft.com/office/mac/excel/2008/main&#x27;,
	&#x27;r&#x27;: &#x27;http://schemas.openxmlformats.org/officeDocument/2006/relationships&#x27;,
	&#x27;sjs&#x27;: &#x27;http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties&#x27;,
	&#x27;vt&#x27;: &#x27;http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes&#x27;,
	&#x27;xsi&#x27;: &#x27;http://www.w3.org/2001/XMLSchema-instance&#x27;,
	&#x27;xsd&#x27;: &#x27;http://www.w3.org/2001/XMLSchema&#x27;
};

XMLNS.main = [
	&#x27;http://schemas.openxmlformats.org/spreadsheetml/2006/main&#x27;,
	&#x27;http://purl.oclc.org/ooxml/spreadsheetml/main&#x27;,
	&#x27;http://schemas.microsoft.com/office/excel/2006/main&#x27;,
	&#x27;http://schemas.microsoft.com/office/excel/2006/2&#x27;
];

function readIEEE754(buf, idx, isLE, nl, ml) {
	if(isLE === undefined) isLE = true;
	if(!nl) nl = 8;
	if(!ml &amp;&amp; nl === 8) ml = 52;
	var e, m, el = nl * 8 - ml - 1, eMax = (1 &lt;&lt; el) - 1, eBias = eMax &gt;&gt; 1;
	var bits = -7, d = isLE ? -1 : 1, i = isLE ? (nl - 1) : 0, s = buf[idx + i];

	i += d;
	e = s &amp; ((1 &lt;&lt; (-bits)) - 1); s &gt;&gt;&gt;= (-bits); bits += el;
	for (; bits &gt; 0; e = e * 256 + buf[idx + i], i += d, bits -= 8);
	m = e &amp; ((1 &lt;&lt; (-bits)) - 1); e &gt;&gt;&gt;= (-bits); bits += ml;
	for (; bits &gt; 0; m = m * 256 + buf[idx + i], i += d, bits -= 8);
	if (e === eMax) return m ? NaN : ((s ? -1 : 1) * Infinity);
	else if (e === 0) e = 1 - eBias;
	else { m = m + Math.pow(2, ml); e = e - eBias; }
	return (s ? -1 : 1) * m * Math.pow(2, e - ml);
}

var __toBuffer, ___toBuffer;
__toBuffer = ___toBuffer = function toBuffer_(bufs) { var x = []; for(var i = 0; i &lt; bufs[0].length; ++i) { x.push.apply(x, bufs[0][i]); } return x; };
var __utf16le, ___utf16le;
__utf16le = ___utf16le = function utf16le_(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i+=2) ss.push(String.fromCharCode(__readUInt16LE(b,i))); return ss.join(&quot;&quot;); };
var __hexlify, ___hexlify;
__hexlify = ___hexlify = function hexlify_(b,s,l) { return b.slice(s,(s+l)).map(function(x){return (x&lt;16?&quot;0&quot;:&quot;&quot;) + x.toString(16);}).join(&quot;&quot;); };
var __utf8, ___utf8;
__utf8 = ___utf8 = function(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i++) ss.push(String.fromCharCode(__readUInt8(b,i))); return ss.join(&quot;&quot;); };
var __lpstr, ___lpstr;
__lpstr = ___lpstr = function lpstr_(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : &quot;&quot;;};
var __lpwstr, ___lpwstr;
__lpwstr = ___lpwstr = function lpwstr_(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : &quot;&quot;;};
var __double, ___double;
__double = ___double = function(b, idx) { return readIEEE754(b, idx);};

var is_buf = function is_buf_a(a) { return Array.isArray(a); };
if(has_buf) {
	__utf16le = function utf16le_b(b,s,e) { if(!Buffer.isBuffer(b)) return ___utf16le(b,s,e); return b.toString(&#x27;utf16le&#x27;,s,e); };
	__hexlify = function(b,s,l) { return Buffer.isBuffer(b) ? b.toString(&#x27;hex&#x27;,s,s+l) : ___hexlify(b,s,l); };
	__lpstr = function lpstr_b(b,i) { if(!Buffer.isBuffer(b)) return ___lpstr(b, i); var len = b.readUInt32LE(i); return len &gt; 0 ? b.toString(&#x27;utf8&#x27;,i+4,i+4+len-1) : &quot;&quot;;};
	__lpwstr = function lpwstr_b(b,i) { if(!Buffer.isBuffer(b)) return ___lpwstr(b, i); var len = 2*b.readUInt32LE(i); return b.toString(&#x27;utf16le&#x27;,i+4,i+4+len-1);};
	__utf8 = function utf8_b(s,e) { return this.toString(&#x27;utf8&#x27;,s,e); };
	__toBuffer = function(bufs) { return (bufs[0].length &gt; 0 &amp;&amp; Buffer.isBuffer(bufs[0][0])) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);};
	bconcat = function(bufs) { return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : [].concat.apply([], bufs); };
	__double = function double_(b,i) { if(Buffer.isBuffer(b)) return b.readDoubleLE(i); return ___double(b,i); };
	is_buf = function is_buf_b(a) { return Buffer.isBuffer(a) || Array.isArray(a); };
}

/* from js-xls */
if(typeof cptable !== &#x27;undefined&#x27;) {
	__utf16le = function(b,s,e) { return cptable.utils.decode(1200, b.slice(s,e)); };
	__utf8 = function(b,s,e) { return cptable.utils.decode(65001, b.slice(s,e)); };
	__lpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? cptable.utils.decode(current_codepage, b.slice(i+4, i+4+len-1)) : &quot;&quot;;};
	__lpwstr = function(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? cptable.utils.decode(1200, b.slice(i+4,i+4+len-1)) : &quot;&quot;;};
}

var __readUInt8 = function(b, idx) { return b[idx]; };
var __readUInt16LE = function(b, idx) { return b[idx+1]*(1&lt;&lt;8)+b[idx]; };
var __readInt16LE = function(b, idx) { var u = b[idx+1]*(1&lt;&lt;8)+b[idx]; return (u &lt; 0x8000) ? u : (0xffff - u + 1) * -1; };
var __readUInt32LE = function(b, idx) { return b[idx+3]*(1&lt;&lt;24)+(b[idx+2]&lt;&lt;16)+(b[idx+1]&lt;&lt;8)+b[idx]; };
var __readInt32LE = function(b, idx) { return (b[idx+3]&lt;&lt;24)|(b[idx+2]&lt;&lt;16)|(b[idx+1]&lt;&lt;8)|b[idx]; };

var ___unhexlify = function(s) { return s.match(/../g).map(function(x) { return parseInt(x,16);}); };
var __unhexlify = typeof Buffer !== &quot;undefined&quot; ? function(s) { return Buffer.isBuffer(s) ? new Buffer(s, &#x27;hex&#x27;) : ___unhexlify(s); } : ___unhexlify;

function ReadShift(size, t) {
	var o=&quot;&quot;, oI, oR, oo=[], w, vv, i, loc;
	switch(t) {
		case &#x27;dbcs&#x27;:
			loc = this.l;
			if(has_buf &amp;&amp; Buffer.isBuffer(this)) o = this.slice(this.l, this.l+2*size).toString(&quot;utf16le&quot;);
			else for(i = 0; i != size; ++i) { o+=String.fromCharCode(__readUInt16LE(this, loc)); loc+=2; }
			size *= 2;
			break;

		case &#x27;utf8&#x27;: o = __utf8(this, this.l, this.l + size); break;
		case &#x27;utf16le&#x27;: size *= 2; o = __utf16le(this, this.l, this.l + size); break;

		/* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
		case &#x27;lpstr&#x27;: o = __lpstr(this, this.l); size = 5 + o.length; break;
		/* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
		case &#x27;lpwstr&#x27;: o = __lpwstr(this, this.l); size = 5 + o.length; if(o[o.length-1] == &#x27;\u0000&#x27;) size += 2; break;

		case &#x27;cstr&#x27;: size = 0; o = &quot;&quot;;
			while((w=__readUInt8(this, this.l + size++))!==0) oo.push(_getchar(w));
			o = oo.join(&quot;&quot;); break;
		case &#x27;wstr&#x27;: size = 0; o = &quot;&quot;;
			while((w=__readUInt16LE(this,this.l +size))!==0){oo.push(_getchar(w));size+=2;}
			size+=2; o = oo.join(&quot;&quot;); break;

		/* sbcs and dbcs support continue records in the SST way TODO codepages */
		case &#x27;dbcs-cont&#x27;: o = &quot;&quot;; loc = this.l;
			for(i = 0; i != size; ++i) {
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {
					w = __readUInt8(this, loc);
					this.l = loc + 1;
					vv = ReadShift.call(this, size-i, w ? &#x27;dbcs-cont&#x27; : &#x27;sbcs-cont&#x27;);
					return oo.join(&quot;&quot;) + vv;
				}
				oo.push(_getchar(__readUInt16LE(this, loc)));
				loc+=2;
			} o = oo.join(&quot;&quot;); size *= 2; break;

		case &#x27;sbcs-cont&#x27;: o = &quot;&quot;; loc = this.l;
			for(i = 0; i != size; ++i) {
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {
					w = __readUInt8(this, loc);
					this.l = loc + 1;
					vv = ReadShift.call(this, size-i, w ? &#x27;dbcs-cont&#x27; : &#x27;sbcs-cont&#x27;);
					return oo.join(&quot;&quot;) + vv;
				}
				oo.push(_getchar(__readUInt8(this, loc)));
				loc+=1;
			} o = oo.join(&quot;&quot;); break;

		default:
	switch(size) {
		case 1: oI = __readUInt8(this, this.l); this.l++; return oI;
		case 2: oI = (t === &#x27;i&#x27; ? __readInt16LE : __readUInt16LE)(this, this.l); this.l += 2; return oI;
		case 4:
			if(t === &#x27;i&#x27; || (this[this.l+3] &amp; 0x80)===0) { oI = __readInt32LE(this, this.l); this.l += 4; return oI; }
			else { oR = __readUInt32LE(this, this.l); this.l += 4; return oR; } break;
		case 8: if(t === &#x27;f&#x27;) { oR = __double(this, this.l); this.l += 8; return oR; }
		/* falls through */
		case 16: o = __hexlify(this, this.l, size); break;
	}}
	this.l+=size; return o;
}

function WriteShift(t, val, f) {
	var size, i;
	if(f === &#x27;dbcs&#x27;) {
		for(i = 0; i != val.length; ++i) this.writeUInt16LE(val.charCodeAt(i), this.l + 2 * i);
		size = 2 * val.length;
	} else switch(t) {
		case  1: size = 1; this[this.l] = val&amp;255; break;
		case  3: size = 3; this[this.l+2] = val &amp; 255; val &gt;&gt;&gt;= 8; this[this.l+1] = val&amp;255; val &gt;&gt;&gt;= 8; this[this.l] = val&amp;255; break;
		case  4: size = 4; this.writeUInt32LE(val, this.l); break;
		case  8: size = 8; if(f === &#x27;f&#x27;) { this.writeDoubleLE(val, this.l); break; }
		/* falls through */
		case 16: break;
		case -4: size = 4; this.writeInt32LE(val, this.l); break;
	}
	this.l += size; return this;
}

function CheckField(hexstr, fld) {
	var m = __hexlify(this,this.l,hexstr.length&gt;&gt;1);
	if(m !== hexstr) throw fld + &#x27;Expected &#x27; + hexstr + &#x27; saw &#x27; + m;
	this.l += hexstr.length&gt;&gt;1;
}

function prep_blob(blob, pos) {
	blob.l = pos;
	blob.read_shift = ReadShift;
	blob.chk = CheckField;
	blob.write_shift = WriteShift;
}

function parsenoop(blob, length) { blob.l += length; }

function writenoop(blob, length) { blob.l += length; }

function new_buf(sz) {
	var o = new_raw_buf(sz);
	prep_blob(o, 0);
	return o;
}

/* [MS-XLSB] 2.1.4 Record */
function recordhopper(data, cb, opts) {
	var tmpbyte, cntbyte, length;
	prep_blob(data, data.l || 0);
	while(data.l &lt; data.length) {
		var RT = data.read_shift(1);
		if(RT &amp; 0x80) RT = (RT &amp; 0x7F) + ((data.read_shift(1) &amp; 0x7F)&lt;&lt;7);
		var R = XLSBRecordEnum[RT] || XLSBRecordEnum[0xFFFF];
		tmpbyte = data.read_shift(1);
		length = tmpbyte &amp; 0x7F;
		for(cntbyte = 1; cntbyte &lt;4 &amp;&amp; (tmpbyte &amp; 0x80); ++cntbyte) length += ((tmpbyte = data.read_shift(1)) &amp; 0x7F)&lt;&lt;(7*cntbyte);
		var d = R.f(data, length, opts);
		if(cb(d, R, RT)) return;
	}
}

/* control buffer usage for fixed-length buffers */
function buf_array() {
	var bufs = [], blksz = 2048;
	var newblk = function ba_newblk(sz) {
		var o = new_buf(sz);
		prep_blob(o, 0);
		return o;
	};

	var curbuf = newblk(blksz);

	var endbuf = function ba_endbuf() {
		curbuf.length = curbuf.l;
		if(curbuf.length &gt; 0) bufs.push(curbuf);
		curbuf = null;
	};

	var next = function ba_next(sz) {
		if(sz &lt; curbuf.length - curbuf.l) return curbuf;
		endbuf();
		return (curbuf = newblk(Math.max(sz+1, blksz)));
	};

	var end = function ba_end() {
		endbuf();
		return __toBuffer([bufs]);
	};

	var push = function ba_push(buf) { endbuf(); curbuf = buf; next(blksz); };

	return { next:next, push:push, end:end, _bufs:bufs };
}

function write_record(ba, type, payload, length) {
	var t = evert_RE[type], l;
	if(!length) length = XLSBRecordEnum[t].p || (payload||[]).length || 0;
	l = 1 + (t &gt;= 0x80 ? 1 : 0) + 1 + length;
	if(length &gt;= 0x80) ++l; if(length &gt;= 0x4000) ++l; if(length &gt;= 0x200000) ++l;
	var o = ba.next(l);
	if(t &lt;= 0x7F) o.write_shift(1, t);
	else {
		o.write_shift(1, (t &amp; 0x7F) + 0x80);
		o.write_shift(1, (t &gt;&gt; 7));
	}
	for(var i = 0; i != 4; ++i) {
		if(length &gt;= 0x80) { o.write_shift(1, (length &amp; 0x7F)+0x80); length &gt;&gt;= 7; }
		else { o.write_shift(1, length); break; }
	}
	if(length &gt; 0 &amp;&amp; is_buf(payload)) ba.push(payload);
}
/* XLS ranges enforced */
function shift_cell_xls(cell, tgt) {
	if(tgt.s) {
		if(cell.cRel) cell.c += tgt.s.c;
		if(cell.rRel) cell.r += tgt.s.r;
	} else {
		cell.c += tgt.c;
		cell.r += tgt.r;
	}
	cell.cRel = cell.rRel = 0;
	while(cell.c &gt;= 0x100) cell.c -= 0x100;
	while(cell.r &gt;= 0x10000) cell.r -= 0x10000;
	return cell;
}

function shift_range_xls(cell, range) {
	cell.s = shift_cell_xls(cell.s, range.s);
	cell.e = shift_cell_xls(cell.e, range.s);
	return cell;
}

var OFFCRYPTO = {};
var make_offcrypto = function(O, _crypto) {
	var crypto;
	if(typeof _crypto !== &#x27;undefined&#x27;) crypto = _crypto;
	else if(typeof require !== &#x27;undefined&#x27;) {
		try { crypto = require(&#x27;cry&#x27;+&#x27;pto&#x27;); }
		catch(e) { crypto = null; }
	}

	O.rc4 = function(key, data) {
		var S = new Array(256);
		var c = 0, i = 0, j = 0, t = 0;
		for(i = 0; i != 256; ++i) S[i] = i;
		for(i = 0; i != 256; ++i) {
			j = (j + S[i] + (key[i%key.length]).charCodeAt(0))&amp;255;
			t = S[i]; S[i] = S[j]; S[j] = t;
		}
		i = j = 0; out = Buffer(data.length);
		for(c = 0; c != data.length; ++c) {
			i = (i + 1)&amp;255;
			j = (j + S[i])%256;
			t = S[i]; S[i] = S[j]; S[j] = t;
			out[c] = (data[c] ^ S[(S[i]+S[j])&amp;255]);
		}
		return out;
	};

	if(crypto) {
		O.md5 = function(hex) { return crypto.createHash(&#x27;md5&#x27;).update(hex).digest(&#x27;hex&#x27;); };
	} else {
		O.md5 = function(hex) { throw &quot;unimplemented&quot;; };
	}
};
make_offcrypto(OFFCRYPTO, typeof crypto !== &quot;undefined&quot; ? crypto : undefined);


/* [MS-XLSB] 2.5.143 */
function parse_StrRun(data, length) {
	return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}

/* [MS-XLSB] 2.1.7.121 */
function parse_RichStr(data, length) {
	var start = data.l;
	var flags = data.read_shift(1);
	var str = parse_XLWideString(data);
	var rgsStrRun = [];
	var z = { t: str, h: str };
	if((flags &amp; 1) !== 0) { /* fRichStr */
		/* TODO: formatted string */
		var dwSizeStrRun = data.read_shift(4);
		for(var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
		z.r = rgsStrRun;
	}
	else z.r = &quot;&lt;t&gt;&quot; + escapexml(str) + &quot;&lt;/t&gt;&quot;;
	if((flags &amp; 2) !== 0) { /* fExtStr */
		/* TODO: phonetic string */
	}
	data.l = start + length;
	return z;
}
function write_RichStr(str, o) {
	/* TODO: formatted string */
	if(o == null) o = new_buf(5+2*str.t.length);
	o.write_shift(1,0);
	write_XLWideString(str.t, o);
	return o;
}

/* [MS-XLSB] 2.5.9 */
function parse_XLSBCell(data) {
	var col = data.read_shift(4);
	var iStyleRef = data.read_shift(2);
	iStyleRef += data.read_shift(1) &lt;&lt;16;
	var fPhShow = data.read_shift(1);
	return { c:col, iStyleRef: iStyleRef };
}
function write_XLSBCell(cell, o) {
	if(o == null) o = new_buf(8);
	o.write_shift(-4, cell.c);
	o.write_shift(3, cell.iStyleRef === undefined ? cell.iStyleRef : cell.s);
	o.write_shift(1, 0); /* fPhShow */
	return o;
}


/* [MS-XLSB] 2.5.21 */
function parse_XLSBCodeName (data, length) { return parse_XLWideString(data, length); }

/* [MS-XLSB] 2.5.166 */
function parse_XLNullableWideString(data) {
	var cchCharacters = data.read_shift(4);
	return cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? &quot;&quot; : data.read_shift(cchCharacters, &#x27;dbcs&#x27;);
}
function write_XLNullableWideString(data, o) {
	if(!o) o = new_buf(127);
	o.write_shift(4, data.length &gt; 0 ? data.length : 0xFFFFFFFF);
	if(data.length &gt; 0) o.write_shift(0, data, &#x27;dbcs&#x27;);
	return o;
}

/* [MS-XLSB] 2.5.168 */
function parse_XLWideString(data) {
	var cchCharacters = data.read_shift(4);
	return cchCharacters === 0 ? &quot;&quot; : data.read_shift(cchCharacters, &#x27;dbcs&#x27;);
}
function write_XLWideString(data, o) {
	if(o == null) o = new_buf(4+2*data.length);
	o.write_shift(4, data.length);
	if(data.length &gt; 0) o.write_shift(0, data, &#x27;dbcs&#x27;);
	return o;
}

/* [MS-XLSB] 2.5.114 */
var parse_RelID = parse_XLNullableWideString;
var write_RelID = write_XLNullableWideString;


/* [MS-XLSB] 2.5.122 */
/* [MS-XLS] 2.5.217 */
function parse_RkNumber(data) {
	var b = data.slice(data.l, data.l+4);
	var fX100 = b[0] &amp; 1, fInt = b[0] &amp; 2;
	data.l+=4;
	b[0] &amp;= 0xFC; // b[0] &amp;= ~3;
	var RK = fInt === 0 ? __double([0,0,0,0,b[0],b[1],b[2],b[3]],0) : __readInt32LE(b,0)&gt;&gt;2;
	return fX100 ? RK/100 : RK;
}

/* [MS-XLSB] 2.5.153 */
function parse_UncheckedRfX(data) {
	var cell = {s: {}, e: {}};
	cell.s.r = data.read_shift(4);
	cell.e.r = data.read_shift(4);
	cell.s.c = data.read_shift(4);
	cell.e.c = data.read_shift(4);
	return cell;
}

function write_UncheckedRfX(r, o) {
	if(!o) o = new_buf(16);
	o.write_shift(4, r.s.r);
	o.write_shift(4, r.e.r);
	o.write_shift(4, r.s.c);
	o.write_shift(4, r.e.c);
	return o;
}

/* [MS-XLSB] 2.5.171 */
/* [MS-XLS] 2.5.342 */
function parse_Xnum(data, length) { return data.read_shift(8, &#x27;f&#x27;); }
function write_Xnum(data, o) { return (o || new_buf(8)).write_shift(8, &#x27;f&#x27;, data); }

/* [MS-XLSB] 2.5.198.2 */
var BErr = {
	0x00: &quot;#NULL!&quot;,
	0x07: &quot;#DIV/0!&quot;,
	0x0F: &quot;#VALUE!&quot;,
	0x17: &quot;#REF!&quot;,
	0x1D: &quot;#NAME?&quot;,
	0x24: &quot;#NUM!&quot;,
	0x2A: &quot;#N/A&quot;,
	0x2B: &quot;#GETTING_DATA&quot;,
	0xFF: &quot;#WTF?&quot;
};
var RBErr = evert_num(BErr);

/* [MS-XLSB] 2.4.321 BrtColor */
function parse_BrtColor(data, length) {
	var out = {};
	var d = data.read_shift(1);
	out.fValidRGB = d &amp; 1;
	out.xColorType = d &gt;&gt;&gt; 1;
	out.index = data.read_shift(1);
	out.nTintAndShade = data.read_shift(2, &#x27;i&#x27;);
	out.bRed   = data.read_shift(1);
	out.bGreen = data.read_shift(1);
	out.bBlue  = data.read_shift(1);
	out.bAlpha = data.read_shift(1);
}

/* [MS-XLSB] 2.5.52 */
function parse_FontFlags(data, length) {
	var d = data.read_shift(1);
	data.l++;
	var out = {
		fItalic: d &amp; 0x2,
		fStrikeout: d &amp; 0x8,
		fOutline: d &amp; 0x10,
		fShadow: d &amp; 0x20,
		fCondense: d &amp; 0x40,
		fExtend: d &amp; 0x80
	};
	return out;
}
/* [MS-OLEPS] 2.2 PropertyType */
{
	var VT_EMPTY    = 0x0000;
	var VT_NULL     = 0x0001;
	var VT_I2       = 0x0002;
	var VT_I4       = 0x0003;
	var VT_R4       = 0x0004;
	var VT_R8       = 0x0005;
	var VT_CY       = 0x0006;
	var VT_DATE     = 0x0007;
	var VT_BSTR     = 0x0008;
	var VT_ERROR    = 0x000A;
	var VT_BOOL     = 0x000B;
	var VT_VARIANT  = 0x000C;
	var VT_DECIMAL  = 0x000E;
	var VT_I1       = 0x0010;
	var VT_UI1      = 0x0011;
	var VT_UI2      = 0x0012;
	var VT_UI4      = 0x0013;
	var VT_I8       = 0x0014;
	var VT_UI8      = 0x0015;
	var VT_INT      = 0x0016;
	var VT_UINT     = 0x0017;
	var VT_LPSTR    = 0x001E;
	var VT_LPWSTR   = 0x001F;
	var VT_FILETIME = 0x0040;
	var VT_BLOB     = 0x0041;
	var VT_STREAM   = 0x0042;
	var VT_STORAGE  = 0x0043;
	var VT_STREAMED_Object  = 0x0044;
	var VT_STORED_Object    = 0x0045;
	var VT_BLOB_Object      = 0x0046;
	var VT_CF       = 0x0047;
	var VT_CLSID    = 0x0048;
	var VT_VERSIONED_STREAM = 0x0049;
	var VT_VECTOR   = 0x1000;
	var VT_ARRAY    = 0x2000;

	var VT_STRING   = 0x0050; // 2.3.3.1.11 VtString
	var VT_USTR     = 0x0051; // 2.3.3.1.12 VtUnalignedString
	var VT_CUSTOM   = [VT_STRING, VT_USTR];
}

/* [MS-OSHARED] 2.3.3.2.2.1 Document Summary Information PIDDSI */
var DocSummaryPIDDSI = {
	0x01: { n: &#x27;CodePage&#x27;, t: VT_I2 },
	0x02: { n: &#x27;Category&#x27;, t: VT_STRING },
	0x03: { n: &#x27;PresentationFormat&#x27;, t: VT_STRING },
	0x04: { n: &#x27;ByteCount&#x27;, t: VT_I4 },
	0x05: { n: &#x27;LineCount&#x27;, t: VT_I4 },
	0x06: { n: &#x27;ParagraphCount&#x27;, t: VT_I4 },
	0x07: { n: &#x27;SlideCount&#x27;, t: VT_I4 },
	0x08: { n: &#x27;NoteCount&#x27;, t: VT_I4 },
	0x09: { n: &#x27;HiddenCount&#x27;, t: VT_I4 },
	0x0a: { n: &#x27;MultimediaClipCount&#x27;, t: VT_I4 },
	0x0b: { n: &#x27;Scale&#x27;, t: VT_BOOL },
	0x0c: { n: &#x27;HeadingPair&#x27;, t: VT_VECTOR | VT_VARIANT },
	0x0d: { n: &#x27;DocParts&#x27;, t: VT_VECTOR | VT_LPSTR },
	0x0e: { n: &#x27;Manager&#x27;, t: VT_STRING },
	0x0f: { n: &#x27;Company&#x27;, t: VT_STRING },
	0x10: { n: &#x27;LinksDirty&#x27;, t: VT_BOOL },
	0x11: { n: &#x27;CharacterCount&#x27;, t: VT_I4 },
	0x13: { n: &#x27;SharedDoc&#x27;, t: VT_BOOL },
	0x16: { n: &#x27;HLinksChanged&#x27;, t: VT_BOOL },
	0x17: { n: &#x27;AppVersion&#x27;, t: VT_I4, p: &#x27;version&#x27; },
	0x1A: { n: &#x27;ContentType&#x27;, t: VT_STRING },
	0x1B: { n: &#x27;ContentStatus&#x27;, t: VT_STRING },
	0x1C: { n: &#x27;Language&#x27;, t: VT_STRING },
	0x1D: { n: &#x27;Version&#x27;, t: VT_STRING },
	0xFF: {}
};

/* [MS-OSHARED] 2.3.3.2.1.1 Summary Information Property Set PIDSI */
var SummaryPIDSI = {
	0x01: { n: &#x27;CodePage&#x27;, t: VT_I2 },
	0x02: { n: &#x27;Title&#x27;, t: VT_STRING },
	0x03: { n: &#x27;Subject&#x27;, t: VT_STRING },
	0x04: { n: &#x27;Author&#x27;, t: VT_STRING },
	0x05: { n: &#x27;Keywords&#x27;, t: VT_STRING },
	0x06: { n: &#x27;Comments&#x27;, t: VT_STRING },
	0x07: { n: &#x27;Template&#x27;, t: VT_STRING },
	0x08: { n: &#x27;LastAuthor&#x27;, t: VT_STRING },
	0x09: { n: &#x27;RevNumber&#x27;, t: VT_STRING },
	0x0A: { n: &#x27;EditTime&#x27;, t: VT_FILETIME },
	0x0B: { n: &#x27;LastPrinted&#x27;, t: VT_FILETIME },
	0x0C: { n: &#x27;CreatedDate&#x27;, t: VT_FILETIME },
	0x0D: { n: &#x27;ModifiedDate&#x27;, t: VT_FILETIME },
	0x0E: { n: &#x27;PageCount&#x27;, t: VT_I4 },
	0x0F: { n: &#x27;WordCount&#x27;, t: VT_I4 },
	0x10: { n: &#x27;CharCount&#x27;, t: VT_I4 },
	0x11: { n: &#x27;Thumbnail&#x27;, t: VT_CF },
	0x12: { n: &#x27;ApplicationName&#x27;, t: VT_LPSTR },
	0x13: { n: &#x27;DocumentSecurity&#x27;, t: VT_I4 },
	0xFF: {}
};

/* [MS-OLEPS] 2.18 */
var SpecialProperties = {
	0x80000000: { n: &#x27;Locale&#x27;, t: VT_UI4 },
	0x80000003: { n: &#x27;Behavior&#x27;, t: VT_UI4 },
	0x72627262: {}
};

(function() {
	for(var y in SpecialProperties) if(SpecialProperties.hasOwnProperty(y))
	DocSummaryPIDDSI[y] = SummaryPIDSI[y] = SpecialProperties[y];
})();

/* [MS-XLS] 2.4.63 Country/Region codes */
var CountryEnum = {
	0x0001: &quot;US&quot;, // United States
	0x0002: &quot;CA&quot;, // Canada
	0x0003: &quot;&quot;, // Latin America (except Brazil)
	0x0007: &quot;RU&quot;, // Russia
	0x0014: &quot;EG&quot;, // Egypt
	0x001E: &quot;GR&quot;, // Greece
	0x001F: &quot;NL&quot;, // Netherlands
	0x0020: &quot;BE&quot;, // Belgium
	0x0021: &quot;FR&quot;, // France
	0x0022: &quot;ES&quot;, // Spain
	0x0024: &quot;HU&quot;, // Hungary
	0x0027: &quot;IT&quot;, // Italy
	0x0029: &quot;CH&quot;, // Switzerland
	0x002B: &quot;AT&quot;, // Austria
	0x002C: &quot;GB&quot;, // United Kingdom
	0x002D: &quot;DK&quot;, // Denmark
	0x002E: &quot;SE&quot;, // Sweden
	0x002F: &quot;NO&quot;, // Norway
	0x0030: &quot;PL&quot;, // Poland
	0x0031: &quot;DE&quot;, // Germany
	0x0034: &quot;MX&quot;, // Mexico
	0x0037: &quot;BR&quot;, // Brazil
	0x003d: &quot;AU&quot;, // Australia
	0x0040: &quot;NZ&quot;, // New Zealand
	0x0042: &quot;TH&quot;, // Thailand
	0x0051: &quot;JP&quot;, // Japan
	0x0052: &quot;KR&quot;, // Korea
	0x0054: &quot;VN&quot;, // Viet Nam
	0x0056: &quot;CN&quot;, // China
	0x005A: &quot;TR&quot;, // Turkey
	0x0069: &quot;JS&quot;, // Ramastan
	0x00D5: &quot;DZ&quot;, // Algeria
	0x00D8: &quot;MA&quot;, // Morocco
	0x00DA: &quot;LY&quot;, // Libya
	0x015F: &quot;PT&quot;, // Portugal
	0x0162: &quot;IS&quot;, // Iceland
	0x0166: &quot;FI&quot;, // Finland
	0x01A4: &quot;CZ&quot;, // Czech Republic
	0x0376: &quot;TW&quot;, // Taiwan
	0x03C1: &quot;LB&quot;, // Lebanon
	0x03C2: &quot;JO&quot;, // Jordan
	0x03C3: &quot;SY&quot;, // Syria
	0x03C4: &quot;IQ&quot;, // Iraq
	0x03C5: &quot;KW&quot;, // Kuwait
	0x03C6: &quot;SA&quot;, // Saudi Arabia
	0x03CB: &quot;AE&quot;, // United Arab Emirates
	0x03CC: &quot;IL&quot;, // Israel
	0x03CE: &quot;QA&quot;, // Qatar
	0x03D5: &quot;IR&quot;, // Iran
	0xFFFF: &quot;US&quot;  // United States
};

/* [MS-XLS] 2.5.127 */
var XLSFillPattern = [
	null,
	&#x27;solid&#x27;,
	&#x27;mediumGray&#x27;,
	&#x27;darkGray&#x27;,
	&#x27;lightGray&#x27;,
	&#x27;darkHorizontal&#x27;,
	&#x27;darkVertical&#x27;,
	&#x27;darkDown&#x27;,
	&#x27;darkUp&#x27;,
	&#x27;darkGrid&#x27;,
	&#x27;darkTrellis&#x27;,
	&#x27;lightHorizontal&#x27;,
	&#x27;lightVertical&#x27;,
	&#x27;lightDown&#x27;,
	&#x27;lightUp&#x27;,
	&#x27;lightGrid&#x27;,
	&#x27;lightTrellis&#x27;,
	&#x27;gray125&#x27;,
	&#x27;gray0625&#x27;
];

function rgbify(arr) { return arr.map(function(x) { return [(x&gt;&gt;16)&amp;255,(x&gt;&gt;8)&amp;255,x&amp;255]; }); }

/* [MS-XLS] 2.5.161 */
var XLSIcv = rgbify([
	/* Color Constants */
	0x000000,
	0xFFFFFF,
	0xFF0000,
	0x00FF00,
	0x0000FF,
	0xFFFF00,
	0xFF00FF,
	0x00FFFF,

	/* Defaults */
	0x000000,
	0xFFFFFF,
	0xFF0000,
	0x00FF00,
	0x0000FF,
	0xFFFF00,
	0xFF00FF,
	0x00FFFF,

	0x800000,
	0x008000,
	0x000080,
	0x808000,
	0x800080,
	0x008080,
	0xC0C0C0,
	0x808080,
	0x9999FF,
	0x993366,
	0xFFFFCC,
	0xCCFFFF,
	0x660066,
	0xFF8080,
	0x0066CC,
	0xCCCCFF,

	0x000080,
	0xFF00FF,
	0xFFFF00,
	0x00FFFF,
	0x800080,
	0x800000,
	0x008080,
	0x0000FF,
	0x00CCFF,
	0xCCFFFF,
	0xCCFFCC,
	0xFFFF99,
	0x99CCFF,
	0xFF99CC,
	0xCC99FF,
	0xFFCC99,

	0x3366FF,
	0x33CCCC,
	0x99CC00,
	0xFFCC00,
	0xFF9900,
	0xFF6600,
	0x666699,
	0x969696,
	0x003366,
	0x339966,
	0x003300,
	0x333300,
	0x993300,
	0x993366,
	0x333399,
	0x333333,

	/* Sheet */
	0xFFFFFF,
	0x000000
]);

/* Parts enumerated in OPC spec, MS-XLSB and MS-XLSX */
/* 12.3 Part Summary &lt;SpreadsheetML&gt; */
/* 14.2 Part Summary &lt;DrawingML&gt; */
/* [MS-XLSX] 2.1 Part Enumerations */
/* [MS-XLSB] 2.1.7 Part Enumeration */
var ct2type = {
	/* Workbook */
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml&quot;: &quot;workbooks&quot;,

	/* Worksheet */
	&quot;application/vnd.ms-excel.binIndexWs&quot;: &quot;TODO&quot;, /* Binary Index */

	/* Chartsheet */
	&quot;application/vnd.ms-excel.chartsheet&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml&quot;: &quot;TODO&quot;,

	/* Dialogsheet */
	&quot;application/vnd.ms-excel.dialogsheet&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml&quot;: &quot;TODO&quot;,

	/* Macrosheet */
	&quot;application/vnd.ms-excel.macrosheet&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.macrosheet+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.intlmacrosheet&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.binIndexMs&quot;: &quot;TODO&quot;, /* Binary Index */

	/* File Properties */
	&quot;application/vnd.openxmlformats-package.core-properties+xml&quot;: &quot;coreprops&quot;,
	&quot;application/vnd.openxmlformats-officedocument.custom-properties+xml&quot;: &quot;custprops&quot;,
	&quot;application/vnd.openxmlformats-officedocument.extended-properties+xml&quot;: &quot;extprops&quot;,

	/* Custom Data Properties */
	&quot;application/vnd.openxmlformats-officedocument.customXmlProperties+xml&quot;: &quot;TODO&quot;,

	/* Comments */
	&quot;application/vnd.ms-excel.comments&quot;: &quot;comments&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml&quot;: &quot;comments&quot;,

	/* PivotTable */
	&quot;application/vnd.ms-excel.pivotTable&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml&quot;: &quot;TODO&quot;,

	/* Calculation Chain */
	&quot;application/vnd.ms-excel.calcChain&quot;: &quot;calcchains&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml&quot;: &quot;calcchains&quot;,

	/* Printer Settings */
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings&quot;: &quot;TODO&quot;,

	/* ActiveX */
	&quot;application/vnd.ms-office.activeX&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-office.activeX+xml&quot;: &quot;TODO&quot;,

	/* Custom Toolbars */
	&quot;application/vnd.ms-excel.attachedToolbars&quot;: &quot;TODO&quot;,

	/* External Data Connections */
	&quot;application/vnd.ms-excel.connections&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml&quot;: &quot;TODO&quot;,

	/* External Links */
	&quot;application/vnd.ms-excel.externalLink&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml&quot;: &quot;TODO&quot;,

	/* Metadata */
	&quot;application/vnd.ms-excel.sheetMetadata&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml&quot;: &quot;TODO&quot;,

	/* PivotCache */
	&quot;application/vnd.ms-excel.pivotCacheDefinition&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.pivotCacheRecords&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml&quot;: &quot;TODO&quot;,

	/* Query Table */
	&quot;application/vnd.ms-excel.queryTable&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml&quot;: &quot;TODO&quot;,

	/* Shared Workbook */
	&quot;application/vnd.ms-excel.userNames&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.revisionHeaders&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.revisionLog&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml&quot;: &quot;TODO&quot;,

	/* Single Cell Table */
	&quot;application/vnd.ms-excel.tableSingleCells&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml&quot;: &quot;TODO&quot;,

	/* Slicer */
	&quot;application/vnd.ms-excel.slicer&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.slicerCache&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.slicer+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.ms-excel.slicerCache+xml&quot;: &quot;TODO&quot;,

	/* Sort Map */
	&quot;application/vnd.ms-excel.wsSortMap&quot;: &quot;TODO&quot;,

	/* Table */
	&quot;application/vnd.ms-excel.table&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml&quot;: &quot;TODO&quot;,

	/* Themes */
	&quot;application/vnd.openxmlformats-officedocument.theme+xml&quot;: &quot;themes&quot;,

	/* Timeline */
	&quot;application/vnd.ms-excel.Timeline+xml&quot;: &quot;TODO&quot;, /* verify */
	&quot;application/vnd.ms-excel.TimelineCache+xml&quot;: &quot;TODO&quot;, /* verify */

	/* VBA */
	&quot;application/vnd.ms-office.vbaProject&quot;: &quot;vba&quot;,
	&quot;application/vnd.ms-office.vbaProjectSignature&quot;: &quot;vba&quot;,

	/* Volatile Dependencies */
	&quot;application/vnd.ms-office.volatileDependencies&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml&quot;: &quot;TODO&quot;,

	/* Control Properties */
	&quot;application/vnd.ms-excel.controlproperties+xml&quot;: &quot;TODO&quot;,

	/* Data Model */
	&quot;application/vnd.openxmlformats-officedocument.model+data&quot;: &quot;TODO&quot;,

	/* Survey */
	&quot;application/vnd.ms-excel.Survey+xml&quot;: &quot;TODO&quot;,

	/* Drawing */
	&quot;application/vnd.openxmlformats-officedocument.drawing+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.chart+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml&quot;: &quot;TODO&quot;,
	&quot;application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml&quot;: &quot;TODO&quot;,

	/* VML */
	&quot;application/vnd.openxmlformats-officedocument.vmlDrawing&quot;: &quot;TODO&quot;,

	&quot;application/vnd.openxmlformats-package.relationships+xml&quot;: &quot;rels&quot;,
	&quot;application/vnd.openxmlformats-officedocument.oleObject&quot;: &quot;TODO&quot;,

	&quot;sheet&quot;: &quot;js&quot;
};

var CT_LIST = (function(){
	var o = {
		workbooks: {
			xlsx: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml&quot;,
			xlsm: &quot;application/vnd.ms-excel.sheet.macroEnabled.main+xml&quot;,
			xlsb: &quot;application/vnd.ms-excel.sheet.binary.macroEnabled.main&quot;,
			xltx: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml&quot;
		},
		strs: { /* Shared Strings */
			xlsx: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml&quot;,
			xlsb: &quot;application/vnd.ms-excel.sharedStrings&quot;
		},
		sheets: {
			xlsx: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml&quot;,
			xlsb: &quot;application/vnd.ms-excel.worksheet&quot;
		},
		styles: {/* Styles */
			xlsx: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml&quot;,
			xlsb: &quot;application/vnd.ms-excel.styles&quot;
		}
	};
	keys(o).forEach(function(k) { if(!o[k].xlsm) o[k].xlsm = o[k].xlsx; });
	keys(o).forEach(function(k){ keys(o[k]).forEach(function(v) { ct2type[o[k][v]] = k; }); });
	return o;
})();

var type2ct = evert_arr(ct2type);

XMLNS.CT = &#x27;http://schemas.openxmlformats.org/package/2006/content-types&#x27;;

function parse_ct(data, opts) {
	var ctext = {};
	if(!data || !data.match) return data;
	var ct = { workbooks: [], sheets: [], calcchains: [], themes: [], styles: [],
		coreprops: [], extprops: [], custprops: [], strs:[], comments: [], vba: [],
		TODO:[], rels:[], xmlns: &quot;&quot; };
	(data.match(tagregex)||[]).forEach(function(x) {
		var y = parsexmltag(x);
		switch(y[0].replace(nsregex,&quot;&lt;&quot;)) {
			case &#x27;&lt;?xml&#x27;: break;
			case &#x27;&lt;Types&#x27;: ct.xmlns = y[&#x27;xmlns&#x27; + (y[0].match(/&lt;(\w+):/)||[&quot;&quot;,&quot;&quot;])[1] ]; break;
			case &#x27;&lt;Default&#x27;: ctext[y.Extension] = y.ContentType; break;
			case &#x27;&lt;Override&#x27;:
				if(ct[ct2type[y.ContentType]] !== undefined) ct[ct2type[y.ContentType]].push(y.PartName);
				else if(opts.WTF) console.error(y);
				break;
		}
	});
	if(ct.xmlns !== XMLNS.CT) throw new Error(&quot;Unknown Namespace: &quot; + ct.xmlns);
	ct.calcchain = ct.calcchains.length &gt; 0 ? ct.calcchains[0] : &quot;&quot;;
	ct.sst = ct.strs.length &gt; 0 ? ct.strs[0] : &quot;&quot;;
	ct.style = ct.styles.length &gt; 0 ? ct.styles[0] : &quot;&quot;;
	ct.defaults = ctext;
	delete ct.calcchains;
	return ct;
}

var CTYPE_XML_ROOT = writextag(&#x27;Types&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.CT,
	&#x27;xmlns:xsd&#x27;: XMLNS.xsd,
	&#x27;xmlns:xsi&#x27;: XMLNS.xsi
});

var CTYPE_DEFAULTS = [
	[&#x27;xml&#x27;, &#x27;application/xml&#x27;],
	[&#x27;bin&#x27;, &#x27;application/vnd.ms-excel.sheet.binary.macroEnabled.main&#x27;],
	[&#x27;rels&#x27;, type2ct.rels[0]]
].map(function(x) {
	return writextag(&#x27;Default&#x27;, null, {&#x27;Extension&#x27;:x[0], &#x27;ContentType&#x27;: x[1]});
});

function write_ct(ct, opts) {
	var o = [], v;
	o[o.length] = (XML_HEADER);
	o[o.length] = (CTYPE_XML_ROOT);
	o = o.concat(CTYPE_DEFAULTS);
	var f1 = function(w) {
		if(ct[w] &amp;&amp; ct[w].length &gt; 0) {
			v = ct[w][0];
			o[o.length] = (writextag(&#x27;Override&#x27;, null, {
				&#x27;PartName&#x27;: (v[0] == &#x27;/&#x27; ? &quot;&quot;:&quot;/&quot;) + v,
				&#x27;ContentType&#x27;: CT_LIST[w][opts.bookType || &#x27;xlsx&#x27;]
			}));
		}
	};
	var f2 = function(w) {
		ct[w].forEach(function(v) {
			o[o.length] = (writextag(&#x27;Override&#x27;, null, {
				&#x27;PartName&#x27;: (v[0] == &#x27;/&#x27; ? &quot;&quot;:&quot;/&quot;) + v,
				&#x27;ContentType&#x27;: CT_LIST[w][opts.bookType || &#x27;xlsx&#x27;]
			}));
		});
	};
	var f3 = function(t) {
		(ct[t]||[]).forEach(function(v) {
			o[o.length] = (writextag(&#x27;Override&#x27;, null, {
				&#x27;PartName&#x27;: (v[0] == &#x27;/&#x27; ? &quot;&quot;:&quot;/&quot;) + v,
				&#x27;ContentType&#x27;: type2ct[t][0]
			}));
		});
	};
	f1(&#x27;workbooks&#x27;);
	f2(&#x27;sheets&#x27;);
	f3(&#x27;themes&#x27;);
	[&#x27;strs&#x27;, &#x27;styles&#x27;].forEach(f1);
	[&#x27;coreprops&#x27;, &#x27;extprops&#x27;, &#x27;custprops&#x27;].forEach(f3);
	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/Types&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* 9.3.2 OPC Relationships Markup */
var RELS = {
	WB: &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument&quot;,
	SHEET: &quot;http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument&quot;
};

function parse_rels(data, currentFilePath) {
	if (!data) return data;
	if (currentFilePath.charAt(0) !== &#x27;/&#x27;) {
		currentFilePath = &#x27;/&#x27;+currentFilePath;
	}
	var rels = {};
	var hash = {};
	var resolveRelativePathIntoAbsolute = function (to) {
		var toksFrom = currentFilePath.split(&#x27;/&#x27;);
		toksFrom.pop(); // folder path
		var toksTo = to.split(&#x27;/&#x27;);
		var reversed = [];
		while (toksTo.length !== 0) {
			var tokTo = toksTo.shift();
			if (tokTo === &#x27;..&#x27;) {
				toksFrom.pop();
			} else if (tokTo !== &#x27;.&#x27;) {
				toksFrom.push(tokTo);
			}
		}
		return toksFrom.join(&#x27;/&#x27;);
	};

	data.match(tagregex).forEach(function(x) {
		var y = parsexmltag(x);
		/* 9.3.2.2 OPC_Relationships */
		if (y[0] === &#x27;&lt;Relationship&#x27;) {
			var rel = {}; rel.Type = y.Type; rel.Target = y.Target; rel.Id = y.Id; rel.TargetMode = y.TargetMode;
			var canonictarget = y.TargetMode === &#x27;External&#x27; ? y.Target : resolveRelativePathIntoAbsolute(y.Target);
			rels[canonictarget] = rel;
			hash[y.Id] = rel;
		}
	});
	rels[&quot;!id&quot;] = hash;
	return rels;
}

XMLNS.RELS = &#x27;http://schemas.openxmlformats.org/package/2006/relationships&#x27;;

var RELS_ROOT = writextag(&#x27;Relationships&#x27;, null, {
	//&#x27;xmlns:ns0&#x27;: XMLNS.RELS,
	&#x27;xmlns&#x27;: XMLNS.RELS
});

/* TODO */
function write_rels(rels) {
	var o = [];
	o[o.length] = (XML_HEADER);
	o[o.length] = (RELS_ROOT);
	keys(rels[&#x27;!id&#x27;]).forEach(function(rid) { var rel = rels[&#x27;!id&#x27;][rid];
		o[o.length] = (writextag(&#x27;Relationship&#x27;, null, rel));
	});
	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/Relationships&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* ECMA-376 Part II 11.1 Core Properties Part */
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */
var CORE_PROPS = [
	[&quot;cp:category&quot;, &quot;Category&quot;],
	[&quot;cp:contentStatus&quot;, &quot;ContentStatus&quot;],
	[&quot;cp:keywords&quot;, &quot;Keywords&quot;],
	[&quot;cp:lastModifiedBy&quot;, &quot;LastAuthor&quot;],
	[&quot;cp:lastPrinted&quot;, &quot;LastPrinted&quot;],
	[&quot;cp:revision&quot;, &quot;RevNumber&quot;],
	[&quot;cp:version&quot;, &quot;Version&quot;],
	[&quot;dc:creator&quot;, &quot;Author&quot;],
	[&quot;dc:description&quot;, &quot;Comments&quot;],
	[&quot;dc:identifier&quot;, &quot;Identifier&quot;],
	[&quot;dc:language&quot;, &quot;Language&quot;],
	[&quot;dc:subject&quot;, &quot;Subject&quot;],
	[&quot;dc:title&quot;, &quot;Title&quot;],
	[&quot;dcterms:created&quot;, &quot;CreatedDate&quot;, &#x27;date&#x27;],
	[&quot;dcterms:modified&quot;, &quot;ModifiedDate&quot;, &#x27;date&#x27;]
];

XMLNS.CORE_PROPS = &quot;http://schemas.openxmlformats.org/package/2006/metadata/core-properties&quot;;
RELS.CORE_PROPS  = &#x27;http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties&#x27;;

var CORE_PROPS_REGEX = (function() {
	var r = new Array(CORE_PROPS.length);
	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {
		var f = CORE_PROPS[i];
		var g = &quot;(?:&quot;+ f[0].substr(0,f[0].indexOf(&quot;:&quot;)) +&quot;:)&quot;+ f[0].substr(f[0].indexOf(&quot;:&quot;)+1);
		r[i] = new RegExp(&quot;&lt;&quot; + g + &quot;[^&gt;]*&gt;(.*)&lt;\/&quot; + g + &quot;&gt;&quot;);
	}
	return r;
})();

function parse_core_props(data) {
	var p = {};

	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {
		var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);
		if(cur != null &amp;&amp; cur.length &gt; 0) p[f[1]] = cur[1];
		if(f[2] === &#x27;date&#x27; &amp;&amp; p[f[1]]) p[f[1]] = new Date(p[f[1]]);
	}

	return p;
}

var CORE_PROPS_XML_ROOT = writextag(&#x27;cp:coreProperties&#x27;, null, {
	//&#x27;xmlns&#x27;: XMLNS.CORE_PROPS,
	&#x27;xmlns:cp&#x27;: XMLNS.CORE_PROPS,
	&#x27;xmlns:dc&#x27;: XMLNS.dc,
	&#x27;xmlns:dcterms&#x27;: XMLNS.dcterms,
	&#x27;xmlns:dcmitype&#x27;: XMLNS.dcmitype,
	&#x27;xmlns:xsi&#x27;: XMLNS.xsi
});

function cp_doit(f, g, h, o, p) {
	if(p[f] != null || g == null || g === &quot;&quot;) return;
	p[f] = g;
	o[o.length] = (h ? writextag(f,g,h) : writetag(f,g));
}

function write_core_props(cp, opts) {
	var o = [XML_HEADER, CORE_PROPS_XML_ROOT], p = {};
	if(!cp) return o.join(&quot;&quot;);


	if(cp.CreatedDate != null) cp_doit(&quot;dcterms:created&quot;, typeof cp.CreatedDate === &quot;string&quot; ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {&quot;xsi:type&quot;:&quot;dcterms:W3CDTF&quot;}, o, p);
	if(cp.ModifiedDate != null) cp_doit(&quot;dcterms:modified&quot;, typeof cp.ModifiedDate === &quot;string&quot; ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {&quot;xsi:type&quot;:&quot;dcterms:W3CDTF&quot;}, o, p);

	for(var i = 0; i != CORE_PROPS.length; ++i) { var f = CORE_PROPS[i]; cp_doit(f[0], cp[f[1]], null, o, p); }
	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/cp:coreProperties&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* 15.2.12.3 Extended File Properties Part */
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */
var EXT_PROPS = [
	[&quot;Application&quot;, &quot;Application&quot;, &quot;string&quot;],
	[&quot;AppVersion&quot;, &quot;AppVersion&quot;, &quot;string&quot;],
	[&quot;Company&quot;, &quot;Company&quot;, &quot;string&quot;],
	[&quot;DocSecurity&quot;, &quot;DocSecurity&quot;, &quot;string&quot;],
	[&quot;Manager&quot;, &quot;Manager&quot;, &quot;string&quot;],
	[&quot;HyperlinksChanged&quot;, &quot;HyperlinksChanged&quot;, &quot;bool&quot;],
	[&quot;SharedDoc&quot;, &quot;SharedDoc&quot;, &quot;bool&quot;],
	[&quot;LinksUpToDate&quot;, &quot;LinksUpToDate&quot;, &quot;bool&quot;],
	[&quot;ScaleCrop&quot;, &quot;ScaleCrop&quot;, &quot;bool&quot;],
	[&quot;HeadingPairs&quot;, &quot;HeadingPairs&quot;, &quot;raw&quot;],
	[&quot;TitlesOfParts&quot;, &quot;TitlesOfParts&quot;, &quot;raw&quot;]
];

XMLNS.EXT_PROPS = &quot;http://schemas.openxmlformats.org/officeDocument/2006/extended-properties&quot;;
RELS.EXT_PROPS  = &#x27;http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties&#x27;;

function parse_ext_props(data, p) {
	var q = {}; if(!p) p = {};

	EXT_PROPS.forEach(function(f) {
		switch(f[2]) {
			case &quot;string&quot;: p[f[1]] = (data.match(matchtag(f[0]))||[])[1]; break;
			case &quot;bool&quot;: p[f[1]] = (data.match(matchtag(f[0]))||[])[1] === &quot;true&quot;; break;
			case &quot;raw&quot;:
				var cur = data.match(new RegExp(&quot;&lt;&quot; + f[0] + &quot;[^&gt;]*&gt;(.*)&lt;\/&quot; + f[0] + &quot;&gt;&quot;));
				if(cur &amp;&amp; cur.length &gt; 0) q[f[1]] = cur[1];
				break;
		}
	});

	if(q.HeadingPairs &amp;&amp; q.TitlesOfParts) {
		var v = parseVector(q.HeadingPairs);
		var j = 0, widx = 0;
		for(var i = 0; i !== v.length; ++i) {
			switch(v[i].v) {
				case &quot;Worksheets&quot;: widx = j; p.Worksheets = +(v[++i].v); break;
				case &quot;Named Ranges&quot;: ++i; break; // TODO: Handle Named Ranges
			}
		}
		var parts = parseVector(q.TitlesOfParts).map(function(x) { return utf8read(x.v); });
		p.SheetNames = parts.slice(widx, widx + p.Worksheets);
	}
	return p;
}

var EXT_PROPS_XML_ROOT = writextag(&#x27;Properties&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.EXT_PROPS,
	&#x27;xmlns:vt&#x27;: XMLNS.vt
});

function write_ext_props(cp, opts) {
	var o = [], p = {}, W = writextag;
	if(!cp) cp = {};
	cp.Application = &quot;SheetJS&quot;;
	o[o.length] = (XML_HEADER);
	o[o.length] = (EXT_PROPS_XML_ROOT);

	EXT_PROPS.forEach(function(f) {
		if(cp[f[1]] === undefined) return;
		var v;
		switch(f[2]) {
			case &#x27;string&#x27;: v = cp[f[1]]; break;
			case &#x27;bool&#x27;: v = cp[f[1]] ? &#x27;true&#x27; : &#x27;false&#x27;; break;
		}
		if(v !== undefined) o[o.length] = (W(f[0], v));
	});

	/* TODO: HeadingPairs, TitlesOfParts */
	o[o.length] = (W(&#x27;HeadingPairs&#x27;, W(&#x27;vt:vector&#x27;, W(&#x27;vt:variant&#x27;, &#x27;&lt;vt:lpstr&gt;Worksheets&lt;/vt:lpstr&gt;&#x27;)+W(&#x27;vt:variant&#x27;, W(&#x27;vt:i4&#x27;, String(cp.Worksheets))), {size:2, baseType:&quot;variant&quot;})));
	o[o.length] = (W(&#x27;TitlesOfParts&#x27;, W(&#x27;vt:vector&#x27;, cp.SheetNames.map(function(s) { return &quot;&lt;vt:lpstr&gt;&quot; + s + &quot;&lt;/vt:lpstr&gt;&quot;; }).join(&quot;&quot;), {size: cp.Worksheets, baseType:&quot;lpstr&quot;})));
	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/Properties&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* 15.2.12.2 Custom File Properties Part */
XMLNS.CUST_PROPS = &quot;http://schemas.openxmlformats.org/officeDocument/2006/custom-properties&quot;;
RELS.CUST_PROPS  = &#x27;http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties&#x27;;

var custregex = /&lt;[^&gt;]+&gt;[^&lt;]*/g;
function parse_cust_props(data, opts) {
	var p = {}, name;
	var m = data.match(custregex);
	if(m) for(var i = 0; i != m.length; ++i) {
		var x = m[i], y = parsexmltag(x);
		switch(y[0]) {
			case &#x27;&lt;?xml&#x27;: break;
			case &#x27;&lt;Properties&#x27;:
				if(y.xmlns !== XMLNS.CUST_PROPS) throw &quot;unrecognized xmlns &quot; + y.xmlns;
				if(y.xmlnsvt &amp;&amp; y.xmlnsvt !== XMLNS.vt) throw &quot;unrecognized vt &quot; + y.xmlnsvt;
				break;
			case &#x27;&lt;property&#x27;: name = y.name; break;
			case &#x27;&lt;/property&gt;&#x27;: name = null; break;
			default: if (x.indexOf(&#x27;&lt;vt:&#x27;) === 0) {
				var toks = x.split(&#x27;&gt;&#x27;);
				var type = toks[0].substring(4), text = toks[1];
				/* 22.4.2.32 (CT_Variant). Omit the binary types from 22.4 (Variant Types) */
				switch(type) {
					case &#x27;lpstr&#x27;: case &#x27;lpwstr&#x27;: case &#x27;bstr&#x27;: case &#x27;lpwstr&#x27;:
						p[name] = unescapexml(text);
						break;
					case &#x27;bool&#x27;:
						p[name] = parsexmlbool(text, &#x27;&lt;vt:bool&gt;&#x27;);
						break;
					case &#x27;i1&#x27;: case &#x27;i2&#x27;: case &#x27;i4&#x27;: case &#x27;i8&#x27;: case &#x27;int&#x27;: case &#x27;uint&#x27;:
						p[name] = parseInt(text, 10);
						break;
					case &#x27;r4&#x27;: case &#x27;r8&#x27;: case &#x27;decimal&#x27;:
						p[name] = parseFloat(text);
						break;
					case &#x27;filetime&#x27;: case &#x27;date&#x27;:
						p[name] = new Date(text);
						break;
					case &#x27;cy&#x27;: case &#x27;error&#x27;:
						p[name] = unescapexml(text);
						break;
					default:
						if(typeof console !== &#x27;undefined&#x27;) console.warn(&#x27;Unexpected&#x27;, x, type, toks);
				}
			} else if(x.substr(0,2) === &quot;&lt;/&quot;) {
			} else if(opts.WTF) throw new Error(x);
		}
	}
	return p;
}

var CUST_PROPS_XML_ROOT = writextag(&#x27;Properties&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.CUST_PROPS,
	&#x27;xmlns:vt&#x27;: XMLNS.vt
});

function write_cust_props(cp, opts) {
	var o = [XML_HEADER, CUST_PROPS_XML_ROOT];
	if(!cp) return o.join(&quot;&quot;);
	var pid = 1;
	keys(cp).forEach(function custprop(k) { ++pid;
		o[o.length] = (writextag(&#x27;property&#x27;, write_vt(cp[k]), {
			&#x27;fmtid&#x27;: &#x27;{D5CDD505-2E9C-101B-9397-08002B2CF9AE}&#x27;,
			&#x27;pid&#x27;: pid,
			&#x27;name&#x27;: k
		}));
	});
	if(o.length&gt;2){ o[o.length] = &#x27;&lt;/Properties&gt;&#x27;; o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
function xlml_set_prop(Props, tag, val) {
	/* TODO: Normalize the properties */
	switch(tag) {
		case &#x27;Description&#x27;: tag = &#x27;Comments&#x27;; break;
	}
	Props[tag] = val;
}

/* [MS-DTYP] 2.3.3 FILETIME */
/* [MS-OLEDS] 2.1.3 FILETIME (Packet Version) */
/* [MS-OLEPS] 2.8 FILETIME (Packet Version) */
function parse_FILETIME(blob) {
	var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
	return new Date(((dwHighDateTime/1e7*Math.pow(2,32) + dwLowDateTime/1e7) - 11644473600)*1000).toISOString().replace(/\.000/,&quot;&quot;);
}

/* [MS-OSHARED] 2.3.3.1.4 Lpstr */
function parse_lpstr(blob, type, pad) {
	var str = blob.read_shift(0, &#x27;lpstr&#x27;);
	if(pad) blob.l += (4 - ((str.length+1) &amp; 3)) &amp; 3;
	return str;
}

/* [MS-OSHARED] 2.3.3.1.6 Lpwstr */
function parse_lpwstr(blob, type, pad) {
	var str = blob.read_shift(0, &#x27;lpwstr&#x27;);
	if(pad) blob.l += (4 - ((str.length+1) &amp; 3)) &amp; 3;
	return str;
}


/* [MS-OSHARED] 2.3.3.1.11 VtString */
/* [MS-OSHARED] 2.3.3.1.12 VtUnalignedString */
function parse_VtStringBase(blob, stringType, pad) {
	if(stringType === 0x1F /*VT_LPWSTR*/) return parse_lpwstr(blob);
	return parse_lpstr(blob, stringType, pad);
}

function parse_VtString(blob, t, pad) { return parse_VtStringBase(blob, t, pad === false ? 0: 4); }
function parse_VtUnalignedString(blob, t) { if(!t) throw new Error(&quot;dafuq?&quot;); return parse_VtStringBase(blob, t, 0); }

/* [MS-OSHARED] 2.3.3.1.9 VtVecUnalignedLpstrValue */
function parse_VtVecUnalignedLpstrValue(blob) {
	var length = blob.read_shift(4);
	var ret = [];
	for(var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, &#x27;lpstr&#x27;);
	return ret;
}

/* [MS-OSHARED] 2.3.3.1.10 VtVecUnalignedLpstr */
function parse_VtVecUnalignedLpstr(blob) {
	return parse_VtVecUnalignedLpstrValue(blob);
}

/* [MS-OSHARED] 2.3.3.1.13 VtHeadingPair */
function parse_VtHeadingPair(blob) {
	var headingString = parse_TypedPropertyValue(blob, VT_USTR);
	var headerParts = parse_TypedPropertyValue(blob, VT_I4);
	return [headingString, headerParts];
}

/* [MS-OSHARED] 2.3.3.1.14 VtVecHeadingPairValue */
function parse_VtVecHeadingPairValue(blob) {
	var cElements = blob.read_shift(4);
	var out = [];
	for(var i = 0; i != cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));
	return out;
}

/* [MS-OSHARED] 2.3.3.1.15 VtVecHeadingPair */
function parse_VtVecHeadingPair(blob) {
	// NOTE: When invoked, wType &amp; padding were already consumed
	return parse_VtVecHeadingPairValue(blob);
}

/* [MS-OLEPS] 2.18.1 Dictionary (uses 2.17, 2.16) */
function parse_dictionary(blob,CodePage) {
	var cnt = blob.read_shift(4);
	var dict = {};
	for(var j = 0; j != cnt; ++j) {
		var pid = blob.read_shift(4);
		var len = blob.read_shift(4);
		dict[pid] = blob.read_shift(len, (CodePage === 0x4B0 ?&#x27;utf16le&#x27;:&#x27;utf8&#x27;)).replace(chr0,&#x27;&#x27;).replace(chr1,&#x27;!&#x27;);
	}
	if(blob.l &amp; 3) blob.l = (blob.l&gt;&gt;2+1)&lt;&lt;2;
	return dict;
}

/* [MS-OLEPS] 2.9 BLOB */
function parse_BLOB(blob) {
	var size = blob.read_shift(4);
	var bytes = blob.slice(blob.l,blob.l+size);
	if(size &amp; 3 &gt; 0) blob.l += (4 - (size &amp; 3)) &amp; 3;
	return bytes;
}

/* [MS-OLEPS] 2.11 ClipboardData */
function parse_ClipboardData(blob) {
	// TODO
	var o = {};
	o.Size = blob.read_shift(4);
	//o.Format = blob.read_shift(4);
	blob.l += o.Size;
	return o;
}

/* [MS-OLEPS] 2.14 Vector and Array Property Types */
function parse_VtVector(blob, cb) {
	/* [MS-OLEPS] 2.14.2 VectorHeader */
/*	var Length = blob.read_shift(4);
	var o = [];
	for(var i = 0; i != Length; ++i) {
		o.push(cb(blob));
	}
	return o;*/
}

/* [MS-OLEPS] 2.15 TypedPropertyValue */
function parse_TypedPropertyValue(blob, type, _opts) {
	var t = blob.read_shift(2), ret, opts = _opts||{};
	blob.l += 2;
	if(type !== VT_VARIANT)
	if(t !== type &amp;&amp; VT_CUSTOM.indexOf(type)===-1) throw new Error(&#x27;Expected type &#x27; + type + &#x27; saw &#x27; + t);
	switch(type === VT_VARIANT ? t : type) {
		case 0x02 /*VT_I2*/: ret = blob.read_shift(2, &#x27;i&#x27;); if(!opts.raw) blob.l += 2; return ret;
		case 0x03 /*VT_I4*/: ret = blob.read_shift(4, &#x27;i&#x27;); return ret;
		case 0x0B /*VT_BOOL*/: return blob.read_shift(4) !== 0x0;
		case 0x13 /*VT_UI4*/: ret = blob.read_shift(4); return ret;
		case 0x1E /*VT_LPSTR*/: return parse_lpstr(blob, t, 4).replace(chr0,&#x27;&#x27;);
		case 0x1F /*VT_LPWSTR*/: return parse_lpwstr(blob);
		case 0x40 /*VT_FILETIME*/: return parse_FILETIME(blob);
		case 0x41 /*VT_BLOB*/: return parse_BLOB(blob);
		case 0x47 /*VT_CF*/: return parse_ClipboardData(blob);
		case 0x50 /*VT_STRING*/: return parse_VtString(blob, t, !opts.raw &amp;&amp; 4).replace(chr0,&#x27;&#x27;);
		case 0x51 /*VT_USTR*/: return parse_VtUnalignedString(blob, t, 4).replace(chr0,&#x27;&#x27;);
		case 0x100C /*VT_VECTOR|VT_VARIANT*/: return parse_VtVecHeadingPair(blob);
		case 0x101E /*VT_LPSTR*/: return parse_VtVecUnalignedLpstr(blob);
		default: throw new Error(&quot;TypedPropertyValue unrecognized type &quot; + type + &quot; &quot; + t);
	}
}
/* [MS-OLEPS] 2.14.2 VectorHeader */
/*function parse_VTVectorVariant(blob) {
	var Length = blob.read_shift(4);

	if(Length &amp; 1 !== 0) throw new Error(&quot;VectorHeader Length=&quot; + Length + &quot; must be even&quot;);
	var o = [];
	for(var i = 0; i != Length; ++i) {
		o.push(parse_TypedPropertyValue(blob, VT_VARIANT));
	}
	return o;
}*/

/* [MS-OLEPS] 2.20 PropertySet */
function parse_PropertySet(blob, PIDSI) {
	var start_addr = blob.l;
	var size = blob.read_shift(4);
	var NumProps = blob.read_shift(4);
	var Props = [], i = 0;
	var CodePage = 0;
	var Dictionary = -1, DictObj;
	for(i = 0; i != NumProps; ++i) {
		var PropID = blob.read_shift(4);
		var Offset = blob.read_shift(4);
		Props[i] = [PropID, Offset + start_addr];
	}
	var PropH = {};
	for(i = 0; i != NumProps; ++i) {
		if(blob.l !== Props[i][1]) {
			var fail = true;
			if(i&gt;0 &amp;&amp; PIDSI) switch(PIDSI[Props[i-1][0]].t) {
				case 0x02 /*VT_I2*/: if(blob.l +2 === Props[i][1]) { blob.l+=2; fail = false; } break;
				case 0x50 /*VT_STRING*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;
				case 0x100C /*VT_VECTOR|VT_VARIANT*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;
			}
			if(!PIDSI &amp;&amp; blob.l &lt;= Props[i][1]) { fail=false; blob.l = Props[i][1]; }
			if(fail) throw new Error(&quot;Read Error: Expected address &quot; + Props[i][1] + &#x27; at &#x27; + blob.l + &#x27; :&#x27; + i);
		}
		if(PIDSI) {
			var piddsi = PIDSI[Props[i][0]];
			PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, {raw:true});
			if(piddsi.p === &#x27;version&#x27;) PropH[piddsi.n] = String(PropH[piddsi.n] &gt;&gt; 16) + &quot;.&quot; + String(PropH[piddsi.n] &amp; 0xFFFF);
			if(piddsi.n == &quot;CodePage&quot;) switch(PropH[piddsi.n]) {
				case 0: PropH[piddsi.n] = 1252;
					/* falls through */
				case 10000: // OSX Roman
				case 1252: // Windows Latin

				case 874: // SB Windows Thai
				case 1250: // SB Windows Central Europe
				case 1251: // SB Windows Cyrillic
				case 1253: // SB Windows Greek
				case 1254: // SB Windows Turkish
				case 1255: // SB Windows Hebrew
				case 1256: // SB Windows Arabic
				case 1257: // SB Windows Baltic
				case 1258: // SB Windows Vietnam

				case 932: // DB Windows Japanese Shift-JIS
				case 936: // DB Windows Simplified Chinese GBK
				case 949: // DB Windows Korean
				case 950: // DB Windows Traditional Chinese Big5

				case 1200: // UTF16LE
				case 1201: // UTF16BE
				case 65000: case -536: // UTF-7
				case 65001: case -535: // UTF-8
					set_cp(CodePage = PropH[piddsi.n]); break;
				default: throw new Error(&quot;Unsupported CodePage: &quot; + PropH[piddsi.n]);
			}
		} else {
			if(Props[i][0] === 0x1) {
				CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
				set_cp(CodePage);
				if(Dictionary !== -1) {
					var oldpos = blob.l;
					blob.l = Props[Dictionary][1];
					DictObj = parse_dictionary(blob,CodePage);
					blob.l = oldpos;
				}
			} else if(Props[i][0] === 0) {
				if(CodePage === 0) { Dictionary = i; blob.l = Props[i+1][1]; continue; }
				DictObj = parse_dictionary(blob,CodePage);
			} else {
				var name = DictObj[Props[i][0]];
				var val;
				/* [MS-OSHARED] 2.3.3.2.3.1.2 + PROPVARIANT */
				switch(blob[blob.l]) {
					case 0x41 /*VT_BLOB*/: blob.l += 4; val = parse_BLOB(blob); break;
					case 0x1E /*VT_LPSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]); break;
					case 0x1F /*VT_LPWSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]); break;
					case 0x03 /*VT_I4*/: blob.l += 4; val = blob.read_shift(4, &#x27;i&#x27;); break;
					case 0x13 /*VT_UI4*/: blob.l += 4; val = blob.read_shift(4); break;
					case 0x05 /*VT_R8*/: blob.l += 4; val = blob.read_shift(8, &#x27;f&#x27;); break;
					case 0x0B /*VT_BOOL*/: blob.l += 4; val = parsebool(blob, 4); break;
					case 0x40 /*VT_FILETIME*/: blob.l += 4; val = new Date(parse_FILETIME(blob)); break;
					default: throw new Error(&quot;unparsed value: &quot; + blob[blob.l]);
				}
				PropH[name] = val;
			}
		}
	}
	blob.l = start_addr + size; /* step ahead to skip padding */
	return PropH;
}

/* [MS-OLEPS] 2.21 PropertySetStream */
function parse_PropertySetStream(file, PIDSI) {
	var blob = file.content;
	prep_blob(blob, 0);

	var NumSets, FMTID0, FMTID1, Offset0, Offset1;
	blob.chk(&#x27;feff&#x27;, &#x27;Byte Order: &#x27;);

	var vers = blob.read_shift(2); // TODO: check version
	var SystemIdentifier = blob.read_shift(4);
	blob.chk(CFB.utils.consts.HEADER_CLSID, &#x27;CLSID: &#x27;);
	NumSets = blob.read_shift(4);
	if(NumSets !== 1 &amp;&amp; NumSets !== 2) throw &quot;Unrecognized #Sets: &quot; + NumSets;
	FMTID0 = blob.read_shift(16); Offset0 = blob.read_shift(4);

	if(NumSets === 1 &amp;&amp; Offset0 !== blob.l) throw &quot;Length mismatch&quot;;
	else if(NumSets === 2) { FMTID1 = blob.read_shift(16); Offset1 = blob.read_shift(4); }
	var PSet0 = parse_PropertySet(blob, PIDSI);

	var rval = { SystemIdentifier: SystemIdentifier };
	for(var y in PSet0) rval[y] = PSet0[y];
	//rval.blob = blob;
	rval.FMTID = FMTID0;
	//rval.PSet0 = PSet0;
	if(NumSets === 1) return rval;
	if(blob.l !== Offset1) throw &quot;Length mismatch 2: &quot; + blob.l + &quot; !== &quot; + Offset1;
	var PSet1;
	try { PSet1 = parse_PropertySet(blob, null); } catch(e) { }
	for(y in PSet1) rval[y] = PSet1[y];
	rval.FMTID = [FMTID0, FMTID1]; // TODO: verify FMTID0/1
	return rval;
}


function parsenoop2(blob, length) { blob.read_shift(length); return null; }

function parslurp(blob, length, cb) {
	var arr = [], target = blob.l + length;
	while(blob.l &lt; target) arr.push(cb(blob, target - blob.l));
	if(target !== blob.l) throw new Error(&quot;Slurp error&quot;);
	return arr;
}

function parslurp2(blob, length, cb) {
	var arr = [], target = blob.l + length, len = blob.read_shift(2);
	while(len-- !== 0) arr.push(cb(blob, target - blob.l));
	if(target !== blob.l) throw new Error(&quot;Slurp error&quot;);
	return arr;
}

function parsebool(blob, length) { return blob.read_shift(length) === 0x1; }

function parseuint16(blob) { return blob.read_shift(2, &#x27;u&#x27;); }
function parseuint16a(blob, length) { return parslurp(blob,length,parseuint16);}

/* --- 2.5 Structures --- */

/* [MS-XLS] 2.5.14 Boolean */
var parse_Boolean = parsebool;

/* [MS-XLS] 2.5.10 Bes (boolean or error) */
function parse_Bes(blob) {
	var v = blob.read_shift(1), t = blob.read_shift(1);
	return t === 0x01 ? v : v === 0x01;
}

/* [MS-XLS] 2.5.240 ShortXLUnicodeString */
function parse_ShortXLUnicodeString(blob, length, opts) {
	var cch = blob.read_shift(1);
	var width = 1, encoding = &#x27;sbcs-cont&#x27;;
	var cp = current_codepage;
	if(opts &amp;&amp; opts.biff &gt;= 8) current_codepage = 1200;
	if(opts === undefined || opts.biff !== 5) {
		var fHighByte = blob.read_shift(1);
		if(fHighByte) { width = 2; encoding = &#x27;dbcs-cont&#x27;; }
	}
	var o = cch ? blob.read_shift(cch, encoding) : &quot;&quot;;
	current_codepage = cp;
	return o;
}

/* 2.5.293 XLUnicodeRichExtendedString */
function parse_XLUnicodeRichExtendedString(blob) {
	var cp = current_codepage;
	current_codepage = 1200;
	var cch = blob.read_shift(2), flags = blob.read_shift(1);
	var fHighByte = flags &amp; 0x1, fExtSt = flags &amp; 0x4, fRichSt = flags &amp; 0x8;
	var width = 1 + (flags &amp; 0x1); // 0x0 -&gt; utf8, 0x1 -&gt; dbcs
	var cRun, cbExtRst;
	var z = {};
	if(fRichSt) cRun = blob.read_shift(2);
	if(fExtSt) cbExtRst = blob.read_shift(4);
	var encoding = (flags &amp; 0x1) ? &#x27;dbcs-cont&#x27; : &#x27;sbcs-cont&#x27;;
	var msg = cch === 0 ? &quot;&quot; : blob.read_shift(cch, encoding);
	if(fRichSt) blob.l += 4 * cRun; //TODO: parse this
	if(fExtSt) blob.l += cbExtRst; //TODO: parse this
	z.t = msg;
	if(!fRichSt) { z.raw = &quot;&lt;t&gt;&quot; + z.t + &quot;&lt;/t&gt;&quot;; z.r = z.t; }
	current_codepage = cp;
	return z;
}

/* 2.5.296 XLUnicodeStringNoCch */
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
	var retval;
	var fHighByte = blob.read_shift(1);
	if(fHighByte===0) { retval = blob.read_shift(cch, &#x27;sbcs-cont&#x27;); }
	else { retval = blob.read_shift(cch, &#x27;dbcs-cont&#x27;); }
	return retval;
}

/* 2.5.294 XLUnicodeString */
function parse_XLUnicodeString(blob, length, opts) {
	var cch = blob.read_shift(opts !== undefined &amp;&amp; opts.biff &gt; 0 &amp;&amp; opts.biff &lt; 8 ? 1 : 2);
	if(cch === 0) { blob.l++; return &quot;&quot;; }
	return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
/* BIFF5 override */
function parse_XLUnicodeString2(blob, length, opts) {
	if(opts.biff !== 5 &amp;&amp; opts.biff !== 2) return parse_XLUnicodeString(blob, length, opts);
	var cch = blob.read_shift(1);
	if(cch === 0) { blob.l++; return &quot;&quot;; }
	return blob.read_shift(cch, &#x27;sbcs-cont&#x27;);
}

/* [MS-XLS] 2.5.61 ControlInfo */
var parse_ControlInfo = parsenoop;

/* [MS-OSHARED] 2.3.7.6 URLMoniker TODO: flags */
var parse_URLMoniker = function(blob, length) {
	var len = blob.read_shift(4), start = blob.l;
	var extra = false;
	if(len &gt; 24) {
		/* look ahead */
		blob.l += len - 24;
		if(blob.read_shift(16) === &quot;795881f43b1d7f48af2c825dc4852763&quot;) extra = true;
		blob.l = start;
	}
	var url = blob.read_shift((extra?len-24:len)&gt;&gt;1, &#x27;utf16le&#x27;).replace(chr0,&quot;&quot;);
	if(extra) blob.l += 24;
	return url;
};

/* [MS-OSHARED] 2.3.7.8 FileMoniker TODO: all fields */
var parse_FileMoniker = function(blob, length) {
	var cAnti = blob.read_shift(2);
	var ansiLength = blob.read_shift(4);
	var ansiPath = blob.read_shift(ansiLength, &#x27;cstr&#x27;);
	var endServer = blob.read_shift(2);
	var versionNumber = blob.read_shift(2);
	var cbUnicodePathSize = blob.read_shift(4);
	if(cbUnicodePathSize === 0) return ansiPath.replace(/\\/g,&quot;/&quot;);
	var cbUnicodePathBytes = blob.read_shift(4);
	var usKeyValue = blob.read_shift(2);
	var unicodePath = blob.read_shift(cbUnicodePathBytes&gt;&gt;1, &#x27;utf16le&#x27;).replace(chr0,&quot;&quot;);
	return unicodePath;
};

/* [MS-OSHARED] 2.3.7.2 HyperlinkMoniker TODO: all the monikers */
var parse_HyperlinkMoniker = function(blob, length) {
	var clsid = blob.read_shift(16); length -= 16;
	switch(clsid) {
		case &quot;e0c9ea79f9bace118c8200aa004ba90b&quot;: return parse_URLMoniker(blob, length);
		case &quot;0303000000000000c000000000000046&quot;: return parse_FileMoniker(blob, length);
		default: throw &quot;unsupported moniker &quot; + clsid;
	}
};

/* [MS-OSHARED] 2.3.7.9 HyperlinkString */
var parse_HyperlinkString = function(blob, length) {
	var len = blob.read_shift(4);
	var o = blob.read_shift(len, &#x27;utf16le&#x27;).replace(chr0, &quot;&quot;);
	return o;
};

/* [MS-OSHARED] 2.3.7.1 Hyperlink Object TODO: unify params with XLSX */
var parse_Hyperlink = function(blob, length) {
	var end = blob.l + length;
	var sVer = blob.read_shift(4);
	if(sVer !== 2) throw new Error(&quot;Unrecognized streamVersion: &quot; + sVer);
	var flags = blob.read_shift(2);
	blob.l += 2;
	var displayName, targetFrameName, moniker, oleMoniker, location, guid, fileTime;
	if(flags &amp; 0x0010) displayName = parse_HyperlinkString(blob, end - blob.l);
	if(flags &amp; 0x0080) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
	if((flags &amp; 0x0101) === 0x0101) moniker = parse_HyperlinkString(blob, end - blob.l);
	if((flags &amp; 0x0101) === 0x0001) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
	if(flags &amp; 0x0008) location = parse_HyperlinkString(blob, end - blob.l);
	if(flags &amp; 0x0020) guid = blob.read_shift(16);
	if(flags &amp; 0x0040) fileTime = parse_FILETIME(blob, 8);
	blob.l = end;
	var target = (targetFrameName||moniker||oleMoniker);
	if(location) target+=&quot;#&quot;+location;
	return {Target: target};
};

/* 2.5.178 LongRGBA */
function parse_LongRGBA(blob, length) { var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1); return [r,g,b,a]; }

/* 2.5.177 LongRGB */
function parse_LongRGB(blob, length) { var x = parse_LongRGBA(blob, length); x[3] = 0; return x; }


/* --- MS-XLS --- */

/* 2.5.19 */
function parse_XLSCell(blob, length) {
	var rw = blob.read_shift(2); // 0-indexed
	var col = blob.read_shift(2);
	var ixfe = blob.read_shift(2);
	return {r:rw, c:col, ixfe:ixfe};
}

/* 2.5.134 */
function parse_frtHeader(blob) {
	var rt = blob.read_shift(2);
	var flags = blob.read_shift(2); // TODO: parse these flags
	blob.l += 8;
	return {type: rt, flags: flags};
}



function parse_OptXLUnicodeString(blob, length, opts) { return length === 0 ? &quot;&quot; : parse_XLUnicodeString2(blob, length, opts); }

/* 2.5.158 */
var HIDEOBJENUM = [&#x27;SHOWALL&#x27;, &#x27;SHOWPLACEHOLDER&#x27;, &#x27;HIDEALL&#x27;];
var parse_HideObjEnum = parseuint16;

/* 2.5.344 */
function parse_XTI(blob, length) {
	var iSupBook = blob.read_shift(2), itabFirst = blob.read_shift(2,&#x27;i&#x27;), itabLast = blob.read_shift(2,&#x27;i&#x27;);
	return [iSupBook, itabFirst, itabLast];
}

/* 2.5.218 */
function parse_RkRec(blob, length) {
	var ixfe = blob.read_shift(2);
	var RK = parse_RkNumber(blob);
	//console.log(&quot;::&quot;, ixfe, RK,&quot;;;&quot;);
	return [ixfe, RK];
}

/* 2.5.1 */
function parse_AddinUdf(blob, length) {
	blob.l += 4; length -= 4;
	var l = blob.l + length;
	var udfName = parse_ShortXLUnicodeString(blob, length);
	var cb = blob.read_shift(2);
	l -= blob.l;
	if(cb !== l) throw &quot;Malformed AddinUdf: padding = &quot; + l + &quot; != &quot; + cb;
	blob.l += cb;
	return udfName;
}

/* 2.5.209 TODO: Check sizes */
function parse_Ref8U(blob, length) {
	var rwFirst = blob.read_shift(2);
	var rwLast = blob.read_shift(2);
	var colFirst = blob.read_shift(2);
	var colLast = blob.read_shift(2);
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};
}

/* 2.5.211 */
function parse_RefU(blob, length) {
	var rwFirst = blob.read_shift(2);
	var rwLast = blob.read_shift(2);
	var colFirst = blob.read_shift(1);
	var colLast = blob.read_shift(1);
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};
}

/* 2.5.207 */
var parse_Ref = parse_RefU;

/* 2.5.143 */
function parse_FtCmo(blob, length) {
	blob.l += 4;
	var ot = blob.read_shift(2);
	var id = blob.read_shift(2);
	var flags = blob.read_shift(2);
	blob.l+=12;
	return [id, ot, flags];
}

/* 2.5.149 */
function parse_FtNts(blob, length) {
	var out = {};
	blob.l += 4;
	blob.l += 16; // GUID TODO
	out.fSharedNote = blob.read_shift(2);
	blob.l += 4;
	return out;
}

/* 2.5.142 */
function parse_FtCf(blob, length) {
	var out = {};
	blob.l += 4;
	blob.cf = blob.read_shift(2);
	return out;
}

/* 2.5.140 - 2.5.154 and friends */
var FtTab = {
	0x15: parse_FtCmo,
	0x13: parsenoop,                                /* FtLbsData */
	0x12: function(blob, length) { blob.l += 12; }, /* FtCblsData */
	0x11: function(blob, length) { blob.l += 8; },  /* FtRboData */
	0x10: parsenoop,                                /* FtEdoData */
	0x0F: parsenoop,                                /* FtGboData */
	0x0D: parse_FtNts,                              /* FtNts */
	0x0C: function(blob, length) { blob.l += 24; }, /* FtSbs */
	0x0B: function(blob, length) { blob.l += 10; }, /* FtRbo */
	0x0A: function(blob, length) { blob.l += 16; }, /* FtCbls */
	0x09: parsenoop,                                /* FtPictFmla */
	0x08: function(blob, length) { blob.l += 6; },  /* FtPioGrbit */
	0x07: parse_FtCf,                               /* FtCf */
	0x06: function(blob, length) { blob.l += 6; },  /* FtGmo */
	0x04: parsenoop,                                /* FtMacro */
	0x00: function(blob, length) { blob.l += 4; }   /* FtEnding */
};
function parse_FtArray(blob, length, ot) {
	var s = blob.l;
	var fts = [];
	while(blob.l &lt; s + length) {
		var ft = blob.read_shift(2);
		blob.l-=2;
		try {
			fts.push(FtTab[ft](blob, s + length - blob.l));
		} catch(e) { blob.l = s + length; return fts; }
	}
	if(blob.l != s + length) blob.l = s + length; //throw &quot;bad Object Ft-sequence&quot;;
	return fts;
}

/* 2.5.129 */
var parse_FontIndex = parseuint16;

/* --- 2.4 Records --- */

/* 2.4.21 */
function parse_BOF(blob, length) {
	var o = {};
	o.BIFFVer = blob.read_shift(2); length -= 2;
	switch(o.BIFFVer) {
		case 0x0600: /* BIFF8 */
		case 0x0500: /* BIFF5 */
		case 0x0002: case 0x0007: /* BIFF2 */
			break;
		default: throw &quot;Unexpected BIFF Ver &quot; + o.BIFFVer;
	}
	blob.read_shift(length);
	return o;
}


/* 2.4.146 */
function parse_InterfaceHdr(blob, length) {
	if(length === 0) return 0x04b0;
	var q;
	if((q=blob.read_shift(2))!==0x04b0) throw &#x27;InterfaceHdr codePage &#x27; + q;
	return 0x04b0;
}


/* 2.4.349 */
function parse_WriteAccess(blob, length, opts) {
	if(opts.enc) { blob.l += length; return &quot;&quot;; }
	var l = blob.l;
	// TODO: make sure XLUnicodeString doesnt overrun
	var UserName = parse_XLUnicodeString(blob, 0, opts);
	blob.read_shift(length + l - blob.l);
	return UserName;
}

/* 2.4.28 */
function parse_BoundSheet8(blob, length, opts) {
	var pos = blob.read_shift(4);
	var hidden = blob.read_shift(1) &gt;&gt; 6;
	var dt = blob.read_shift(1);
	switch(dt) {
		case 0: dt = &#x27;Worksheet&#x27;; break;
		case 1: dt = &#x27;Macrosheet&#x27;; break;
		case 2: dt = &#x27;Chartsheet&#x27;; break;
		case 6: dt = &#x27;VBAModule&#x27;; break;
	}
	var name = parse_ShortXLUnicodeString(blob, 0, opts);
	if(name.length === 0) name = &quot;Sheet1&quot;;
	return { pos:pos, hs:hidden, dt:dt, name:name };
}

/* 2.4.265 TODO */
function parse_SST(blob, length) {
	var cnt = blob.read_shift(4);
	var ucnt = blob.read_shift(4);
	var strs = [];
	for(var i = 0; i != ucnt; ++i) {
		strs.push(parse_XLUnicodeRichExtendedString(blob));
	}
	strs.Count = cnt; strs.Unique = ucnt;
	return strs;
}

/* 2.4.107 */
function parse_ExtSST(blob, length) {
	var extsst = {};
	extsst.dsst = blob.read_shift(2);
	blob.l += length-2;
	return extsst;
}


/* 2.4.221 TODO*/
function parse_Row(blob, length) {
	var rw = blob.read_shift(2), col = blob.read_shift(2), Col = blob.read_shift(2), rht = blob.read_shift(2);
	blob.read_shift(4); // reserved(2), unused(2)
	var flags = blob.read_shift(1); // various flags
	blob.read_shift(1); // reserved
	blob.read_shift(2); //ixfe, other flags
	return {r:rw, c:col, cnt:Col-col};
}


/* 2.4.125 */
function parse_ForceFullCalculation(blob, length) {
	var header = parse_frtHeader(blob);
	if(header.type != 0x08A3) throw &quot;Invalid Future Record &quot; + header.type;
	var fullcalc = blob.read_shift(4);
	return fullcalc !== 0x0;
}


var parse_CompressPictures = parsenoop2; /* 2.4.55 Not interesting */



/* 2.4.215 rt */
function parse_RecalcId(blob, length) {
	blob.read_shift(2);
	return blob.read_shift(4);
}

/* 2.4.87 */
function parse_DefaultRowHeight (blob, length) {
	var f = blob.read_shift(2), miyRw;
	miyRw = blob.read_shift(2); // flags &amp; 0x02 -&gt; hidden, else empty
	var fl = {Unsynced:f&amp;1,DyZero:(f&amp;2)&gt;&gt;1,ExAsc:(f&amp;4)&gt;&gt;2,ExDsc:(f&amp;8)&gt;&gt;3};
	return [fl, miyRw];
}

/* 2.4.345 TODO */
function parse_Window1(blob, length) {
	var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
	var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
	var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
	return { Pos: [xWn, yWn], Dim: [dxWn, dyWn], Flags: flags, CurTab: iTabCur,
		FirstTab: iTabFirst, Selected: ctabSel, TabRatio: wTabRatio };
}

/* 2.4.122 TODO */
function parse_Font(blob, length, opts) {
	blob.l += 14;
	var name = parse_ShortXLUnicodeString(blob, 0, opts);
	return name;
}

/* 2.4.149 */
function parse_LabelSst(blob, length) {
	var cell = parse_XLSCell(blob);
	cell.isst = blob.read_shift(4);
	return cell;
}

/* 2.4.148 */
function parse_Label(blob, length, opts) {
	var cell = parse_XLSCell(blob, 6);
	var str = parse_XLUnicodeString(blob, length-6, opts);
	cell.val = str;
	return cell;
}

/* 2.4.126 Number Formats */
function parse_Format(blob, length, opts) {
	var ifmt = blob.read_shift(2);
	var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
	return [ifmt, fmtstr];
}

/* 2.4.90 */
function parse_Dimensions(blob, length) {
	var w = length === 10 ? 2 : 4;
	var r = blob.read_shift(w), R = blob.read_shift(w),
	    c = blob.read_shift(2), C = blob.read_shift(2);
	blob.l += 2;
	return {s: {r:r, c:c}, e: {r:R, c:C}};
}

/* 2.4.220 */
function parse_RK(blob, length) {
	var rw = blob.read_shift(2), col = blob.read_shift(2);
	var rkrec = parse_RkRec(blob);
	return {r:rw, c:col, ixfe:rkrec[0], rknum:rkrec[1]};
}

/* 2.4.175 */
function parse_MulRk(blob, length) {
	var target = blob.l + length - 2;
	var rw = blob.read_shift(2), col = blob.read_shift(2);
	var rkrecs = [];
	while(blob.l &lt; target) rkrecs.push(parse_RkRec(blob));
	if(blob.l !== target) throw &quot;MulRK read error&quot;;
	var lastcol = blob.read_shift(2);
	if(rkrecs.length != lastcol - col + 1) throw &quot;MulRK length mismatch&quot;;
	return {r:rw, c:col, C:lastcol, rkrec:rkrecs};
}

/* 2.5.20 2.5.249 TODO */
function parse_CellStyleXF(blob, length, style) {
	var o = {};
	var a = blob.read_shift(4), b = blob.read_shift(4);
	var c = blob.read_shift(4), d = blob.read_shift(2);
	o.patternType = XLSFillPattern[c &gt;&gt; 26];
	o.icvFore = d &amp; 0x7F;
	o.icvBack = (d &gt;&gt; 7) &amp; 0x7F;
	return o;
}
function parse_CellXF(blob, length) {return parse_CellStyleXF(blob,length,0);}
function parse_StyleXF(blob, length) {return parse_CellStyleXF(blob,length,1);}

/* 2.4.353 TODO: actually do this right */
function parse_XF(blob, length) {
	var o = {};
	o.ifnt = blob.read_shift(2); o.ifmt = blob.read_shift(2); o.flags = blob.read_shift(2);
	o.fStyle = (o.flags &gt;&gt; 2) &amp; 0x01;
	length -= 6;
	o.data = parse_CellStyleXF(blob, length, o.fStyle);
	return o;
}

/* 2.4.134 */
function parse_Guts(blob, length) {
	blob.l += 4;
	var out = [blob.read_shift(2), blob.read_shift(2)];
	if(out[0] !== 0) out[0]--;
	if(out[1] !== 0) out[1]--;
	if(out[0] &gt; 7 || out[1] &gt; 7) throw &quot;Bad Gutters: &quot; + out;
	return out;
}

/* 2.4.24 */
function parse_BoolErr(blob, length) {
	var cell = parse_XLSCell(blob, 6);
	var val = parse_Bes(blob, 2);
	cell.val = val;
	cell.t = (val === true || val === false) ? &#x27;b&#x27; : &#x27;e&#x27;;
	return cell;
}

/* 2.4.180 Number */
function parse_Number(blob, length) {
	var cell = parse_XLSCell(blob, 6);
	var xnum = parse_Xnum(blob, 8);
	cell.val = xnum;
	return cell;
}

var parse_XLHeaderFooter = parse_OptXLUnicodeString; // TODO: parse 2.4.136

/* 2.4.271 */
function parse_SupBook(blob, length, opts) {
	var end = blob.l + length;
	var ctab = blob.read_shift(2);
	var cch = blob.read_shift(2);
	var virtPath;
	if(cch &gt;=0x01 &amp;&amp; cch &lt;=0xff) virtPath = parse_XLUnicodeStringNoCch(blob, cch);
	var rgst = blob.read_shift(end - blob.l);
	opts.sbcch = cch;
	return [cch, ctab, virtPath, rgst];
}

/* 2.4.105 TODO */
function parse_ExternName(blob, length, opts) {
	var flags = blob.read_shift(2);
	var body;
	var o = {
		fBuiltIn: flags &amp; 0x01,
		fWantAdvise: (flags &gt;&gt;&gt; 1) &amp; 0x01,
		fWantPict: (flags &gt;&gt;&gt; 2) &amp; 0x01,
		fOle: (flags &gt;&gt;&gt; 3) &amp; 0x01,
		fOleLink: (flags &gt;&gt;&gt; 4) &amp; 0x01,
		cf: (flags &gt;&gt;&gt; 5) &amp; 0x3FF,
		fIcon: flags &gt;&gt;&gt; 15 &amp; 0x01
	};
	if(opts.sbcch === 0x3A01) body = parse_AddinUdf(blob, length-2);
	//else throw new Error(&quot;unsupported SupBook cch: &quot; + opts.sbcch);
	o.body = body || blob.read_shift(length-2);
	return o;
}

/* 2.4.150 TODO */
function parse_Lbl(blob, length, opts) {
	if(opts.biff &lt; 8) return parse_Label(blob, length, opts);
	var target = blob.l + length;
	var flags = blob.read_shift(2);
	var chKey = blob.read_shift(1);
	var cch = blob.read_shift(1);
	var cce = blob.read_shift(2);
	blob.l += 2;
	var itab = blob.read_shift(2);
	blob.l += 4;
	var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
	var rgce = parse_NameParsedFormula(blob, target - blob.l, opts, cce);
	return {
		chKey: chKey,
		Name: name,
		rgce: rgce
	};
}

/* 2.4.106 TODO: verify supbook manipulation */
function parse_ExternSheet(blob, length, opts) {
	if(opts.biff &lt; 8) return parse_ShortXLUnicodeString(blob, length, opts);
	var o = parslurp2(blob,length,parse_XTI);
	var oo = [];
	if(opts.sbcch === 0x0401) {
		for(var i = 0; i != o.length; ++i) oo.push(opts.snames[o[i][1]]);
		return oo;
	}
	else return o;
}

/* 2.4.260 */
function parse_ShrFmla(blob, length, opts) {
	var ref = parse_RefU(blob, 6);
	blob.l++;
	var cUse = blob.read_shift(1);
	length -= 8;
	return [parse_SharedParsedFormula(blob, length, opts), cUse];
}

/* 2.4.4 TODO */
function parse_Array(blob, length, opts) {
	var ref = parse_Ref(blob, 6);
	blob.l += 6; length -= 12; /* TODO: fAlwaysCalc */
	return [ref, parse_ArrayParsedFormula(blob, length, opts, ref)];
}

/* 2.4.173 */
function parse_MTRSettings(blob, length) {
	var fMTREnabled = blob.read_shift(4) !== 0x00;
	var fUserSetThreadCount = blob.read_shift(4) !== 0x00;
	var cUserThreadCount = blob.read_shift(4);
	return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}

/* 2.5.186 TODO: BIFF5 */
function parse_NoteSh(blob, length, opts) {
	if(opts.biff &lt; 8) return;
	var row = blob.read_shift(2), col = blob.read_shift(2);
	var flags = blob.read_shift(2), idObj = blob.read_shift(2);
	var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
	if(opts.biff &lt; 8) blob.read_shift(1);
	return [{r:row,c:col}, stAuthor, idObj, flags];
}

/* 2.4.179 */
function parse_Note(blob, length, opts) {
	/* TODO: Support revisions */
	return parse_NoteSh(blob, length, opts);
}

/* 2.4.168 */
function parse_MergeCells(blob, length) {
	var merges = [];
	var cmcs = blob.read_shift(2);
	while (cmcs--) merges.push(parse_Ref8U(blob,length));
	return merges;
}

/* 2.4.181 TODO: parse all the things! */
function parse_Obj(blob, length) {
	var cmo = parse_FtCmo(blob, 22); // id, ot, flags
	var fts = parse_FtArray(blob, length-22, cmo[1]);
	return { cmo: cmo, ft:fts };
}

/* 2.4.329 TODO: parse properly */
function parse_TxO(blob, length, opts) {
	var s = blob.l;
try {
	blob.l += 4;
	var ot = (opts.lastobj||{cmo:[0,0]}).cmo[1];
	var controlInfo;
	if([0,5,7,11,12,14].indexOf(ot) == -1) blob.l += 6;
	else controlInfo = parse_ControlInfo(blob, 6, opts);
	var cchText = blob.read_shift(2);
	var cbRuns = blob.read_shift(2);
	var ifntEmpty = parse_FontIndex(blob, 2);
	var len = blob.read_shift(2);
	blob.l += len;
	//var fmla = parse_ObjFmla(blob, s + length - blob.l);

	var texts = &quot;&quot;;
	for(var i = 1; i &lt; blob.lens.length-1; ++i) {
		if(blob.l-s != blob.lens[i]) throw &quot;TxO: bad continue record&quot;;
		var hdr = blob[blob.l];
		var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i+1]-blob.lens[i]-1);
		texts += t;
		if(texts.length &gt;= (hdr ? cchText : 2*cchText)) break;
	}
	if(texts.length !== cchText &amp;&amp; texts.length !== cchText*2) {
		throw &quot;cchText: &quot; + cchText + &quot; != &quot; + texts.length;
	}

	blob.l = s + length;
	/* 2.5.272 TxORuns */
//	var rgTxoRuns = [];
//	for(var j = 0; j != cbRuns/8-1; ++j) blob.l += 8;
//	var cchText2 = blob.read_shift(2);
//	if(cchText2 !== cchText) throw &quot;TxOLastRun mismatch: &quot; + cchText2 + &quot; &quot; + cchText;
//	blob.l += 6;
//	if(s + length != blob.l) throw &quot;TxO &quot; + (s + length) + &quot;, at &quot; + blob.l;
	return { t: texts };
} catch(e) { blob.l = s + length; return { t: texts||&quot;&quot; }; }
}

/* 2.4.140 */
var parse_HLink = function(blob, length) {
	var ref = parse_Ref8U(blob, 8);
	blob.l += 16; /* CLSID */
	var hlink = parse_Hyperlink(blob, length-24);
	return [ref, hlink];
};

/* 2.4.141 */
var parse_HLinkTooltip = function(blob, length) {
	var end = blob.l + length;
	blob.read_shift(2);
	var ref = parse_Ref8U(blob, 8);
	var wzTooltip = blob.read_shift((length-10)/2, &#x27;dbcs-cont&#x27;);
	wzTooltip = wzTooltip.replace(chr0,&quot;&quot;);
	return [ref, wzTooltip];
};

/* 2.4.63 */
function parse_Country(blob, length) {
	var o = [], d;
	d = blob.read_shift(2); o[0] = CountryEnum[d] || d;
	d = blob.read_shift(2); o[1] = CountryEnum[d] || d;
	return o;
}

/* 2.4.50 ClrtClient */
function parse_ClrtClient(blob, length) {
	var ccv = blob.read_shift(2);
	var o = [];
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));
	return o;
}

/* 2.4.188 */
function parse_Palette(blob, length) {
	var ccv = blob.read_shift(2);
	var o = [];
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));
	return o;
}

/* 2.4.354 */
function parse_XFCRC(blob, length) {
	blob.l += 2;
	var o = {cxfs:0, crc:0};
	o.cxfs = blob.read_shift(2);
	o.crc = blob.read_shift(4);
	return o;
}


var parse_Style = parsenoop;
var parse_StyleExt = parsenoop;

var parse_ColInfo = parsenoop;

var parse_Window2 = parsenoop;


var parse_Backup = parsebool; /* 2.4.14 */
var parse_Blank = parse_XLSCell; /* 2.4.20 Just the cell */
var parse_BottomMargin = parse_Xnum; /* 2.4.27 */
var parse_BuiltInFnGroupCount = parseuint16; /* 2.4.30 0x0E or 0x10 but excel 2011 generates 0x11? */
var parse_CalcCount = parseuint16; /* 2.4.31 #Iterations */
var parse_CalcDelta = parse_Xnum; /* 2.4.32 */
var parse_CalcIter = parsebool;  /* 2.4.33 1=iterative calc */
var parse_CalcMode = parseuint16; /* 2.4.34 0=manual, 1=auto (def), 2=table */
var parse_CalcPrecision = parsebool; /* 2.4.35 */
var parse_CalcRefMode = parsenoop2; /* 2.4.36 */
var parse_CalcSaveRecalc = parsebool; /* 2.4.37 */
var parse_CodePage = parseuint16; /* 2.4.52 */
var parse_Compat12 = parsebool; /* 2.4.54 true = no compatibility check */
var parse_Date1904 = parsebool; /* 2.4.77 - 1=1904,0=1900 */
var parse_DefColWidth = parseuint16; /* 2.4.89 */
var parse_DSF = parsenoop2; /* 2.4.94 -- MUST be ignored */
var parse_EntExU2 = parsenoop2; /* 2.4.102 -- Explicitly says to ignore */
var parse_EOF = parsenoop2; /* 2.4.103 */
var parse_Excel9File = parsenoop2; /* 2.4.104 -- Optional and unused */
var parse_FeatHdr = parsenoop2; /* 2.4.112 */
var parse_FontX = parseuint16; /* 2.4.123 */
var parse_Footer = parse_XLHeaderFooter; /* 2.4.124 */
var parse_GridSet = parseuint16; /* 2.4.132, =1 */
var parse_HCenter = parsebool; /* 2.4.135 sheet centered horizontal on print */
var parse_Header = parse_XLHeaderFooter; /* 2.4.136 */
var parse_HideObj = parse_HideObjEnum; /* 2.4.139 */
var parse_InterfaceEnd = parsenoop2; /* 2.4.145 -- noop */
var parse_LeftMargin = parse_Xnum; /* 2.4.151 */
var parse_Mms = parsenoop2; /* 2.4.169 -- Explicitly says to ignore */
var parse_ObjProtect = parsebool; /* 2.4.183 -- must be 1 if present */
var parse_Password = parseuint16; /* 2.4.191 */
var parse_PrintGrid = parsebool; /* 2.4.202 */
var parse_PrintRowCol = parsebool; /* 2.4.203 */
var parse_PrintSize = parseuint16; /* 2.4.204 0:3 */
var parse_Prot4Rev = parsebool; /* 2.4.205 */
var parse_Prot4RevPass = parseuint16; /* 2.4.206 */
var parse_Protect = parsebool; /* 2.4.207 */
var parse_RefreshAll = parsebool; /* 2.4.217 -- must be 0 if not template */
var parse_RightMargin = parse_Xnum; /* 2.4.219 */
var parse_RRTabId = parseuint16a; /* 2.4.241 */
var parse_ScenarioProtect = parsebool; /* 2.4.245 */
var parse_Scl = parseuint16a; /* 2.4.247 num, den */
var parse_String = parse_XLUnicodeString; /* 2.4.268 */
var parse_SxBool = parsebool; /* 2.4.274 */
var parse_TopMargin = parse_Xnum; /* 2.4.328 */
var parse_UsesELFs = parsebool; /* 2.4.337 -- should be 0 */
var parse_VCenter = parsebool; /* 2.4.342 */
var parse_WinProtect = parsebool; /* 2.4.347 */
var parse_WriteProtect = parsenoop; /* 2.4.350 empty record */


/* ---- */
var parse_VerticalPageBreaks = parsenoop;
var parse_HorizontalPageBreaks = parsenoop;
var parse_Selection = parsenoop;
var parse_Continue = parsenoop;
var parse_Pane = parsenoop;
var parse_Pls = parsenoop;
var parse_DCon = parsenoop;
var parse_DConRef = parsenoop;
var parse_DConName = parsenoop;
var parse_XCT = parsenoop;
var parse_CRN = parsenoop;
var parse_FileSharing = parsenoop;
var parse_Uncalced = parsenoop;
var parse_Template = parsenoop;
var parse_Intl = parsenoop;
var parse_WsBool = parsenoop;
var parse_Sort = parsenoop;
var parse_Sync = parsenoop;
var parse_LPr = parsenoop;
var parse_DxGCol = parsenoop;
var parse_FnGroupName = parsenoop;
var parse_FilterMode = parsenoop;
var parse_AutoFilterInfo = parsenoop;
var parse_AutoFilter = parsenoop;
var parse_Setup = parsenoop;
var parse_ScenMan = parsenoop;
var parse_SCENARIO = parsenoop;
var parse_SxView = parsenoop;
var parse_Sxvd = parsenoop;
var parse_SXVI = parsenoop;
var parse_SxIvd = parsenoop;
var parse_SXLI = parsenoop;
var parse_SXPI = parsenoop;
var parse_DocRoute = parsenoop;
var parse_RecipName = parsenoop;
var parse_MulBlank = parsenoop;
var parse_SXDI = parsenoop;
var parse_SXDB = parsenoop;
var parse_SXFDB = parsenoop;
var parse_SXDBB = parsenoop;
var parse_SXNum = parsenoop;
var parse_SxErr = parsenoop;
var parse_SXInt = parsenoop;
var parse_SXString = parsenoop;
var parse_SXDtr = parsenoop;
var parse_SxNil = parsenoop;
var parse_SXTbl = parsenoop;
var parse_SXTBRGIITM = parsenoop;
var parse_SxTbpg = parsenoop;
var parse_ObProj = parsenoop;
var parse_SXStreamID = parsenoop;
var parse_DBCell = parsenoop;
var parse_SXRng = parsenoop;
var parse_SxIsxoper = parsenoop;
var parse_BookBool = parsenoop;
var parse_DbOrParamQry = parsenoop;
var parse_OleObjectSize = parsenoop;
var parse_SXVS = parsenoop;
var parse_BkHim = parsenoop;
var parse_MsoDrawingGroup = parsenoop;
var parse_MsoDrawing = parsenoop;
var parse_MsoDrawingSelection = parsenoop;
var parse_PhoneticInfo = parsenoop;
var parse_SxRule = parsenoop;
var parse_SXEx = parsenoop;
var parse_SxFilt = parsenoop;
var parse_SxDXF = parsenoop;
var parse_SxItm = parsenoop;
var parse_SxName = parsenoop;
var parse_SxSelect = parsenoop;
var parse_SXPair = parsenoop;
var parse_SxFmla = parsenoop;
var parse_SxFormat = parsenoop;
var parse_SXVDEx = parsenoop;
var parse_SXFormula = parsenoop;
var parse_SXDBEx = parsenoop;
var parse_RRDInsDel = parsenoop;
var parse_RRDHead = parsenoop;
var parse_RRDChgCell = parsenoop;
var parse_RRDRenSheet = parsenoop;
var parse_RRSort = parsenoop;
var parse_RRDMove = parsenoop;
var parse_RRFormat = parsenoop;
var parse_RRAutoFmt = parsenoop;
var parse_RRInsertSh = parsenoop;
var parse_RRDMoveBegin = parsenoop;
var parse_RRDMoveEnd = parsenoop;
var parse_RRDInsDelBegin = parsenoop;
var parse_RRDInsDelEnd = parsenoop;
var parse_RRDConflict = parsenoop;
var parse_RRDDefName = parsenoop;
var parse_RRDRstEtxp = parsenoop;
var parse_LRng = parsenoop;
var parse_CUsr = parsenoop;
var parse_CbUsr = parsenoop;
var parse_UsrInfo = parsenoop;
var parse_UsrExcl = parsenoop;
var parse_FileLock = parsenoop;
var parse_RRDInfo = parsenoop;
var parse_BCUsrs = parsenoop;
var parse_UsrChk = parsenoop;
var parse_UserBView = parsenoop;
var parse_UserSViewBegin = parsenoop; // overloaded
var parse_UserSViewEnd = parsenoop;
var parse_RRDUserView = parsenoop;
var parse_Qsi = parsenoop;
var parse_CondFmt = parsenoop;
var parse_CF = parsenoop;
var parse_DVal = parsenoop;
var parse_DConBin = parsenoop;
var parse_Lel = parsenoop;
var parse_XLSCodeName = parse_XLUnicodeString;
var parse_SXFDBType = parsenoop;
var parse_ObNoMacros = parsenoop;
var parse_Dv = parsenoop;
var parse_Index = parsenoop;
var parse_Table = parsenoop;
var parse_BigName = parsenoop;
var parse_ContinueBigName = parsenoop;
var parse_WebPub = parsenoop;
var parse_QsiSXTag = parsenoop;
var parse_DBQueryExt = parsenoop;
var parse_ExtString = parsenoop;
var parse_TxtQry = parsenoop;
var parse_Qsir = parsenoop;
var parse_Qsif = parsenoop;
var parse_RRDTQSIF = parsenoop;
var parse_OleDbConn = parsenoop;
var parse_WOpt = parsenoop;
var parse_SXViewEx = parsenoop;
var parse_SXTH = parsenoop;
var parse_SXPIEx = parsenoop;
var parse_SXVDTEx = parsenoop;
var parse_SXViewEx9 = parsenoop;
var parse_ContinueFrt = parsenoop;
var parse_RealTimeData = parsenoop;
var parse_ChartFrtInfo = parsenoop;
var parse_FrtWrapper = parsenoop;
var parse_StartBlock = parsenoop;
var parse_EndBlock = parsenoop;
var parse_StartObject = parsenoop;
var parse_EndObject = parsenoop;
var parse_CatLab = parsenoop;
var parse_YMult = parsenoop;
var parse_SXViewLink = parsenoop;
var parse_PivotChartBits = parsenoop;
var parse_FrtFontList = parsenoop;
var parse_SheetExt = parsenoop;
var parse_BookExt = parsenoop;
var parse_SXAddl = parsenoop;
var parse_CrErr = parsenoop;
var parse_HFPicture = parsenoop;
var parse_Feat = parsenoop;
var parse_DataLabExt = parsenoop;
var parse_DataLabExtContents = parsenoop;
var parse_CellWatch = parsenoop;
var parse_FeatHdr11 = parsenoop;
var parse_Feature11 = parsenoop;
var parse_DropDownObjIds = parsenoop;
var parse_ContinueFrt11 = parsenoop;
var parse_DConn = parsenoop;
var parse_List12 = parsenoop;
var parse_Feature12 = parsenoop;
var parse_CondFmt12 = parsenoop;
var parse_CF12 = parsenoop;
var parse_CFEx = parsenoop;
var parse_AutoFilter12 = parsenoop;
var parse_ContinueFrt12 = parsenoop;
var parse_MDTInfo = parsenoop;
var parse_MDXStr = parsenoop;
var parse_MDXTuple = parsenoop;
var parse_MDXSet = parsenoop;
var parse_MDXProp = parsenoop;
var parse_MDXKPI = parsenoop;
var parse_MDB = parsenoop;
var parse_PLV = parsenoop;
var parse_DXF = parsenoop;
var parse_TableStyles = parsenoop;
var parse_TableStyle = parsenoop;
var parse_TableStyleElement = parsenoop;
var parse_NamePublish = parsenoop;
var parse_NameCmt = parsenoop;
var parse_SortData = parsenoop;
var parse_GUIDTypeLib = parsenoop;
var parse_FnGrp12 = parsenoop;
var parse_NameFnGrp12 = parsenoop;
var parse_HeaderFooter = parsenoop;
var parse_CrtLayout12 = parsenoop;
var parse_CrtMlFrt = parsenoop;
var parse_CrtMlFrtContinue = parsenoop;
var parse_ShapePropsStream = parsenoop;
var parse_TextPropsStream = parsenoop;
var parse_RichTextStream = parsenoop;
var parse_CrtLayout12A = parsenoop;
var parse_Units = parsenoop;
var parse_Chart = parsenoop;
var parse_Series = parsenoop;
var parse_DataFormat = parsenoop;
var parse_LineFormat = parsenoop;
var parse_MarkerFormat = parsenoop;
var parse_AreaFormat = parsenoop;
var parse_PieFormat = parsenoop;
var parse_AttachedLabel = parsenoop;
var parse_SeriesText = parsenoop;
var parse_ChartFormat = parsenoop;
var parse_Legend = parsenoop;
var parse_SeriesList = parsenoop;
var parse_Bar = parsenoop;
var parse_Line = parsenoop;
var parse_Pie = parsenoop;
var parse_Area = parsenoop;
var parse_Scatter = parsenoop;
var parse_CrtLine = parsenoop;
var parse_Axis = parsenoop;
var parse_Tick = parsenoop;
var parse_ValueRange = parsenoop;
var parse_CatSerRange = parsenoop;
var parse_AxisLine = parsenoop;
var parse_CrtLink = parsenoop;
var parse_DefaultText = parsenoop;
var parse_Text = parsenoop;
var parse_ObjectLink = parsenoop;
var parse_Frame = parsenoop;
var parse_Begin = parsenoop;
var parse_End = parsenoop;
var parse_PlotArea = parsenoop;
var parse_Chart3d = parsenoop;
var parse_PicF = parsenoop;
var parse_DropBar = parsenoop;
var parse_Radar = parsenoop;
var parse_Surf = parsenoop;
var parse_RadarArea = parsenoop;
var parse_AxisParent = parsenoop;
var parse_LegendException = parsenoop;
var parse_ShtProps = parsenoop;
var parse_SerToCrt = parsenoop;
var parse_AxesUsed = parsenoop;
var parse_SBaseRef = parsenoop;
var parse_SerParent = parsenoop;
var parse_SerAuxTrend = parsenoop;
var parse_IFmtRecord = parsenoop;
var parse_Pos = parsenoop;
var parse_AlRuns = parsenoop;
var parse_BRAI = parsenoop;
var parse_SerAuxErrBar = parsenoop;
var parse_SerFmt = parsenoop;
var parse_Chart3DBarShape = parsenoop;
var parse_Fbi = parsenoop;
var parse_BopPop = parsenoop;
var parse_AxcExt = parsenoop;
var parse_Dat = parsenoop;
var parse_PlotGrowth = parsenoop;
var parse_SIIndex = parsenoop;
var parse_GelFrame = parsenoop;
var parse_BopPopCustom = parsenoop;
var parse_Fbi2 = parsenoop;

/* --- Specific to versions before BIFF8 --- */
function parse_BIFF5String(blob) {
	var len = blob.read_shift(1);
	return blob.read_shift(len, &#x27;sbcs-cont&#x27;);
}

/* BIFF2_??? where ??? is the name from [XLS] */
function parse_BIFF2STR(blob, length, opts) {
	var cell = parse_XLSCell(blob, 6);
	++blob.l;
	var str = parse_XLUnicodeString2(blob, length-7, opts);
	cell.val = str;
	return cell;
}

function parse_BIFF2NUM(blob, length, opts) {
	var cell = parse_XLSCell(blob, 6);
	++blob.l;
	var num = parse_Xnum(blob, 8);
	cell.val = num;
	return cell;
}

/* 18.4.1 charset to codepage mapping */
var CS2CP = {
	0:    1252, /* ANSI */
	1:   65001, /* DEFAULT */
	2:   65001, /* SYMBOL */
	77:  10000, /* MAC */
	128:   932, /* SHIFTJIS */
	129:   949, /* HANGUL */
	130:  1361, /* JOHAB */
	134:   936, /* GB2312 */
	136:   950, /* CHINESEBIG5 */
	161:  1253, /* GREEK */
	162:  1254, /* TURKISH */
	163:  1258, /* VIETNAMESE */
	177:  1255, /* HEBREW */
	178:  1256, /* ARABIC */
	186:  1257, /* BALTIC */
	204:  1251, /* RUSSIAN */
	222:   874, /* THAI */
	238:  1250, /* EASTEUROPE */
	255:  1252, /* OEM */
	69:   6969  /* MISC */
};

/* Parse a list of &lt;r&gt; tags */
var parse_rs = (function parse_rs_factory() {
	var tregex = matchtag(&quot;t&quot;), rpregex = matchtag(&quot;rPr&quot;), rregex = /&lt;r&gt;/g, rend = /&lt;\/r&gt;/, nlregex = /\r\n/g;
	/* 18.4.7 rPr CT_RPrElt */
	var parse_rpr = function parse_rpr(rpr, intro, outro) {
		var font = {}, cp = 65001;
		var m = rpr.match(tagregex), i = 0;
		if(m) for(;i!=m.length; ++i) {
			var y = parsexmltag(m[i]);
			switch(y[0]) {
				/* 18.8.12 condense CT_BooleanProperty */
				/* ** not required . */
				case &#x27;&lt;condense&#x27;: break;
				/* 18.8.17 extend CT_BooleanProperty */
				/* ** not required . */
				case &#x27;&lt;extend&#x27;: break;
				/* 18.8.36 shadow CT_BooleanProperty */
				/* ** not required . */
				case &#x27;&lt;shadow&#x27;:
					/* falls through */
				case &#x27;&lt;shadow/&gt;&#x27;: break;

				/* 18.4.1 charset CT_IntProperty TODO */
				case &#x27;&lt;charset&#x27;:
					if(y.val == &#x27;1&#x27;) break;
					cp = CS2CP[parseInt(y.val, 10)];
					break;

				/* 18.4.2 outline CT_BooleanProperty TODO */
				case &#x27;&lt;outline&#x27;:
					/* falls through */
				case &#x27;&lt;outline/&gt;&#x27;: break;

				/* 18.4.5 rFont CT_FontName */
				case &#x27;&lt;rFont&#x27;: font.name = y.val; break;

				/* 18.4.11 sz CT_FontSize */
				case &#x27;&lt;sz&#x27;: font.sz = y.val; break;

				/* 18.4.10 strike CT_BooleanProperty */
				case &#x27;&lt;strike&#x27;:
					if(!y.val) break;
					/* falls through */
				case &#x27;&lt;strike/&gt;&#x27;: font.strike = 1; break;
				case &#x27;&lt;/strike&gt;&#x27;: break;

				/* 18.4.13 u CT_UnderlineProperty */
				case &#x27;&lt;u&#x27;:
					if(!y.val) break;
					/* falls through */
				case &#x27;&lt;u/&gt;&#x27;: font.u = 1; break;
				case &#x27;&lt;/u&gt;&#x27;: break;

				/* 18.8.2 b */
				case &#x27;&lt;b&#x27;:
					if(!y.val) break;
					/* falls through */
				case &#x27;&lt;b/&gt;&#x27;: font.b = 1; break;
				case &#x27;&lt;/b&gt;&#x27;: break;

				/* 18.8.26 i */
				case &#x27;&lt;i&#x27;:
					if(!y.val) break;
					/* falls through */
				case &#x27;&lt;i/&gt;&#x27;: font.i = 1; break;
				case &#x27;&lt;/i&gt;&#x27;: break;

				/* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */
				case &#x27;&lt;color&#x27;:
					if(y.rgb) font.color = y.rgb.substr(2,6);
					break;

				/* 18.8.18 family ST_FontFamily */
				case &#x27;&lt;family&#x27;: font.family = y.val; break;

				/* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */
				case &#x27;&lt;vertAlign&#x27;: break;

				/* 18.8.35 scheme CT_FontScheme TODO */
				case &#x27;&lt;scheme&#x27;: break;

				default:
					if(y[0].charCodeAt(1) !== 47) throw &#x27;Unrecognized rich format &#x27; + y[0];
			}
		}
		/* TODO: These should be generated styles, not inline */
		var style = [];
		if(font.b) style.push(&quot;font-weight: bold;&quot;);
		if(font.i) style.push(&quot;font-style: italic;&quot;);
		intro.push(&#x27;&lt;span style=&quot;&#x27; + style.join(&quot;&quot;) + &#x27;&quot;&gt;&#x27;);
		outro.push(&quot;&lt;/span&gt;&quot;);
		return cp;
	};

	/* 18.4.4 r CT_RElt */
	function parse_r(r) {
		var terms = [[],&quot;&quot;,[]];
		/* 18.4.12 t ST_Xstring */
		var t = r.match(tregex), cp = 65001;
		if(!isval(t)) return &quot;&quot;;
		terms[1] = t[1];

		var rpr = r.match(rpregex);
		if(isval(rpr)) cp = parse_rpr(rpr[1], terms[0], terms[2]);

		return terms[0].join(&quot;&quot;) + terms[1].replace(nlregex,&#x27;&lt;br/&gt;&#x27;) + terms[2].join(&quot;&quot;);
	}
	return function parse_rs(rs) {
		return rs.replace(rregex,&quot;&quot;).split(rend).map(parse_r).join(&quot;&quot;);
	};
})();

/* 18.4.8 si CT_Rst */
var sitregex = /&lt;t[^&gt;]*&gt;([^&lt;]*)&lt;\/t&gt;/g, sirregex = /&lt;r&gt;/;
function parse_si(x, opts) {
	var html = opts ? opts.cellHTML : true;
	var z = {};
	if(!x) return null;
	var y;
	/* 18.4.12 t ST_Xstring (Plaintext String) */
	if(x.charCodeAt(1) === 116) {
		z.t = utf8read(unescapexml(x.substr(x.indexOf(&quot;&gt;&quot;)+1).split(/&lt;\/t&gt;/)[0]));
		z.r = x;
		if(html) z.h = z.t;
	}
	/* 18.4.4 r CT_RElt (Rich Text Run) */
	else if((y = x.match(sirregex))) {
		z.r = x;
		z.t = utf8read(unescapexml(x.match(sitregex).join(&quot;&quot;).replace(tagregex,&quot;&quot;)));
		if(html) z.h = parse_rs(x);
	}
	/* 18.4.3 phoneticPr CT_PhoneticPr (TODO: needed for Asian support) */
	/* 18.4.6 rPh CT_PhoneticRun (TODO: needed for Asian support) */
	return z;
}

/* 18.4 Shared String Table */
var sstr0 = /&lt;sst([^&gt;]*)&gt;([\s\S]*)&lt;\/sst&gt;/;
var sstr1 = /&lt;(?:si|sstItem)&gt;/g;
var sstr2 = /&lt;\/(?:si|sstItem)&gt;/;
function parse_sst_xml(data, opts) {
	var s = [], ss;
	/* 18.4.9 sst CT_Sst */
	var sst = data.match(sstr0);
	if(isval(sst)) {
		ss = sst[2].replace(sstr1,&quot;&quot;).split(sstr2);
		for(var i = 0; i != ss.length; ++i) {
			var o = parse_si(ss[i], opts);
			if(o != null) s[s.length] = o;
		}
		sst = parsexmltag(sst[1]); s.Count = sst.count; s.Unique = sst.uniqueCount;
	}
	return s;
}

RELS.SST = &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings&quot;;
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(sst, opts) {
	if(!opts.bookSST) return &quot;&quot;;
	var o = [XML_HEADER];
	o[o.length] = (writextag(&#x27;sst&#x27;, null, {
		xmlns: XMLNS.main[0],
		count: sst.Count,
		uniqueCount: sst.Unique
	}));
	for(var i = 0; i != sst.length; ++i) { if(sst[i] == null) continue;
		var s = sst[i];
		var sitag = &quot;&lt;si&gt;&quot;;
		if(s.r) sitag += s.r;
		else {
			sitag += &quot;&lt;t&quot;;
			if(s.t.match(straywsregex)) sitag += &#x27; xml:space=&quot;preserve&quot;&#x27;;
			sitag += &quot;&gt;&quot; + escapexml(s.t) + &quot;&lt;/t&gt;&quot;;
		}
		sitag += &quot;&lt;/si&gt;&quot;;
		o[o.length] = (sitag);
	}
	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/sst&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* [MS-XLSB] 2.4.219 BrtBeginSst */
function parse_BrtBeginSst(data, length) {
	return [data.read_shift(4), data.read_shift(4)];
}

/* [MS-XLSB] 2.1.7.45 Shared Strings */
function parse_sst_bin(data, opts) {
	var s = [];
	var pass = false;
	recordhopper(data, function hopper_sst(val, R, RT) {
		switch(R.n) {
			case &#x27;BrtBeginSst&#x27;: s.Count = val[0]; s.Unique = val[1]; break;
			case &#x27;BrtSSTItem&#x27;: s.push(val); break;
			case &#x27;BrtEndSst&#x27;: return true;
			/* TODO: produce a test case with a future record */
			case &#x27;BrtFRTBegin&#x27;: pass = true; break;
			case &#x27;BrtFRTEnd&#x27;: pass = false; break;
			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + RT + &quot; &quot; + R.n);
		}
	});
	return s;
}

function write_BrtBeginSst(sst, o) {
	if(!o) o = new_buf(8);
	o.write_shift(4, sst.Count);
	o.write_shift(4, sst.Unique);
	return o;
}

var write_BrtSSTItem = write_RichStr;

function write_sst_bin(sst, opts) {
	var ba = buf_array();
	write_record(ba, &quot;BrtBeginSst&quot;, write_BrtBeginSst(sst));
	for(var i = 0; i &lt; sst.length; ++i) write_record(ba, &quot;BrtSSTItem&quot;, write_BrtSSTItem(sst[i]));
	write_record(ba, &quot;BrtEndSst&quot;);
	return ba.end();
}
function _JS2ANSI(str) { if(typeof cptable !== &#x27;undefined&#x27;) return cptable.utils.encode(1252, str); return str.split(&quot;&quot;).map(function(x) { return x.charCodeAt(0); }); }

/* [MS-OFFCRYPTO] 2.1.4 Version */
function parse_Version(blob, length) {
	var o = {};
	o.Major = blob.read_shift(2);
	o.Minor = blob.read_shift(2);
	return o;
}
/* [MS-OFFCRYPTO] 2.3.2 Encryption Header */
function parse_EncryptionHeader(blob, length) {
	var o = {};
	o.Flags = blob.read_shift(4);

	// Check if SizeExtra is 0x00000000
	var tmp = blob.read_shift(4);
	if(tmp !== 0) throw &#x27;Unrecognized SizeExtra: &#x27; + tmp;

	o.AlgID = blob.read_shift(4);
	switch(o.AlgID) {
		case 0: case 0x6801: case 0x660E: case 0x660F: case 0x6610: break;
		default: throw &#x27;Unrecognized encryption algorithm: &#x27; + o.AlgID;
	}
	parsenoop(blob, length-12);
	return o;
}

/* [MS-OFFCRYPTO] 2.3.3 Encryption Verifier */
function parse_EncryptionVerifier(blob, length) {
	return parsenoop(blob, length);
}
/* [MS-OFFCRYPTO] 2.3.5.1 RC4 CryptoAPI Encryption Header */
function parse_RC4CryptoHeader(blob, length) {
	var o = {};
	var vers = o.EncryptionVersionInfo = parse_Version(blob, 4); length -= 4;
	if(vers.Minor != 2) throw &#x27;unrecognized minor version code: &#x27; + vers.Minor;
	if(vers.Major &gt; 4 || vers.Major &lt; 2) throw &#x27;unrecognized major version code: &#x27; + vers.Major;
	o.Flags = blob.read_shift(4); length -= 4;
	var sz = blob.read_shift(4); length -= 4;
	o.EncryptionHeader = parse_EncryptionHeader(blob, sz); length -= sz;
	o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
	return o;
}
/* [MS-OFFCRYPTO] 2.3.6.1 RC4 Encryption Header */
function parse_RC4Header(blob, length) {
	var o = {};
	var vers = o.EncryptionVersionInfo = parse_Version(blob, 4); length -= 4;
	if(vers.Major != 1 || vers.Minor != 1) throw &#x27;unrecognized version code &#x27; + vers.Major + &#x27; : &#x27; + vers.Minor;
	o.Salt = blob.read_shift(16);
	o.EncryptedVerifier = blob.read_shift(16);
	o.EncryptedVerifierHash = blob.read_shift(16);
	return o;
}

/* [MS-OFFCRYPTO] 2.3.7.1 Binary Document Password Verifier Derivation */
function crypto_CreatePasswordVerifier_Method1(Password) {
	var Verifier = 0x0000, PasswordArray;
	var PasswordDecoded = _JS2ANSI(Password);
	var len = PasswordDecoded.length + 1, i, PasswordByte;
	var Intermediate1, Intermediate2, Intermediate3;
	PasswordArray = new_raw_buf(len);
	PasswordArray[0] = PasswordDecoded.length;
	for(i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i-1];
	for(i = len-1; i &gt;= 0; --i) {
		PasswordByte = PasswordArray[i];
		Intermediate1 = ((Verifier &amp; 0x4000) === 0x0000) ? 0 : 1;
		Intermediate2 = (Verifier &lt;&lt; 1) &amp; 0x7FFF;
		Intermediate3 = Intermediate1 | Intermediate2;
		Verifier = Intermediate3 ^ PasswordByte;
	}
	return Verifier ^ 0xCE4B;
}

/* [MS-OFFCRYPTO] 2.3.7.2 Binary Document XOR Array Initialization */
var crypto_CreateXorArray_Method1 = (function() {
	var PadArray = [0xBB, 0xFF, 0xFF, 0xBA, 0xFF, 0xFF, 0xB9, 0x80, 0x00, 0xBE, 0x0F, 0x00, 0xBF, 0x0F, 0x00];
	var InitialCode = [0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 0x313E, 0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 0x4EC3];
	var XorMatrix = [0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09, 0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF, 0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0, 0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40, 0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5, 0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A, 0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9, 0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0, 0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC, 0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10, 0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168, 0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C, 0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD, 0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC, 0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4];
	var Ror = function(Byte) { return ((Byte/2) | (Byte*128)) &amp; 0xFF; };
	var XorRor = function(byte1, byte2) { return Ror(byte1 ^ byte2); };
	var CreateXorKey_Method1 = function(Password) {
		var XorKey = InitialCode[Password.length - 1];
		var CurrentElement = 0x68;
		for(var i = Password.length-1; i &gt;= 0; --i) {
			var Char = Password[i];
			for(var j = 0; j != 7; ++j) {
				if(Char &amp; 0x40) XorKey ^= XorMatrix[CurrentElement];
				Char *= 2; --CurrentElement;
			}
		}
		return XorKey;
	};
	return function(password) {
		var Password = _JS2ANSI(password);
		var XorKey = CreateXorKey_Method1(Password);
		var Index = Password.length;
		var ObfuscationArray = new_raw_buf(16);
		for(var i = 0; i != 16; ++i) ObfuscationArray[i] = 0x00;
		var Temp, PasswordLastChar, PadIndex;
		if((Index &amp; 1) === 1) {
			Temp = XorKey &gt;&gt; 8;
			ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
			--Index;
			Temp = XorKey &amp; 0xFF;
			PasswordLastChar = Password[Password.length - 1];
			ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
		}
		while(Index &gt; 0) {
			--Index;
			Temp = XorKey &gt;&gt; 8;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);
			--Index;
			Temp = XorKey &amp; 0xFF;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);
		}
		Index = 15;
		PadIndex = 15 - Password.length;
		while(PadIndex &gt; 0) {
			Temp = XorKey &gt;&gt; 8;
			ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
			--Index;
			--PadIndex;
			Temp = XorKey &amp; 0xFF;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);
			--Index;
			--PadIndex;
		}
		return ObfuscationArray;
	};
})();

/* [MS-OFFCRYPTO] 2.3.7.3 Binary Document XOR Data Transformation Method 1 */
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
	/* If XorArray is set, use it; if O is not set, make changes in-place */
	if(!O) O = Data;
	if(!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
	var Index, Value;
	for(Index = 0; Index != Data.length; ++Index) {
		Value = Data[Index];
		Value ^= XorArray[XorArrayIndex];
		Value = ((Value&gt;&gt;5) | (Value&lt;&lt;3)) &amp; 0xFF;
		O[Index] = Value;
		++XorArrayIndex;
	}
	return [O, XorArrayIndex, XorArray];
};

var crypto_MakeXorDecryptor = function(password) {
	var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
	return function(Data) {
		var O = crypto_DecryptData_Method1(null, Data, XorArrayIndex, XorArray);
		XorArrayIndex = O[1];
		return O[0];
	};
};

/* 2.5.343 */
function parse_XORObfuscation(blob, length, opts, out) {
	var o = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
	if(opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
	out.valid = o.verificationBytes === o.verifier;
	if(out.valid) out.insitu_decrypt = crypto_MakeXorDecryptor(opts.password);
	return o;
}

/* 2.4.117 */
function parse_FilePassHeader(blob, length, oo) {
	var o = oo || {}; o.Info = blob.read_shift(2); blob.l -= 2;
	if(o.Info === 1) o.Data = parse_RC4Header(blob, length);
	else o.Data = parse_RC4CryptoHeader(blob, length);
	return o;
}
function parse_FilePass(blob, length, opts) {
	var o = { Type: blob.read_shift(2) }; /* wEncryptionType */
	if(o.Type) parse_FilePassHeader(blob, length-2, o);
	else parse_XORObfuscation(blob, length-2, opts, o);
	return o;
}


function hex2RGB(h) {
	var o = h.substr(h[0]===&quot;#&quot;?1:0,6);
	return [parseInt(o.substr(0,2),16),parseInt(o.substr(0,2),16),parseInt(o.substr(0,2),16)];
}
function rgb2Hex(rgb) {
	for(var i=0,o=1; i!=3; ++i) o = o*256 + (rgb[i]&gt;255?255:rgb[i]&lt;0?0:rgb[i]);
	return o.toString(16).toUpperCase().substr(1);
}

function rgb2HSL(rgb) {
	var R = rgb[0]/255, G = rgb[1]/255, B=rgb[2]/255;
	var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
	if(C === 0) return [0, 0, R];

	var H6 = 0, S = 0, L2 = (M + m);
	S = C / (L2 &gt; 1 ? 2 - L2 : L2);
	switch(M){
		case R: H6 = ((G - B) / C + 6)%6; break;
		case G: H6 = ((B - R) / C + 2); break;
		case B: H6 = ((R - G) / C + 4); break;
	}
	return [H6 / 6, S, L2 / 2];
}

function hsl2RGB(hsl){
	var H = hsl[0], S = hsl[1], L = hsl[2];
	var C = S * 2 * (L &lt; 0.5 ? L : 1 - L), m = L - C/2;
	var rgb = [m,m,m], h6 = 6*H;

	var X;
	if(S !== 0) switch(h6|0) {
		case 0: case 6: X = C * h6; rgb[0] += C; rgb[1] += X; break;
		case 1: X = C * (2 - h6);   rgb[0] += X; rgb[1] += C; break;
		case 2: X = C * (h6 - 2);   rgb[1] += C; rgb[2] += X; break;
		case 3: X = C * (4 - h6);   rgb[1] += X; rgb[2] += C; break;
		case 4: X = C * (h6 - 4);   rgb[2] += C; rgb[0] += X; break;
		case 5: X = C * (6 - h6);   rgb[2] += X; rgb[0] += C; break;
	}
	for(var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i]*255);
	return rgb;
}

/* 18.8.3 bgColor tint algorithm */
function rgb_tint(hex, tint) {
	if(tint === 0) return hex;
	var hsl = rgb2HSL(hex2RGB(hex));
	if (tint &lt; 0) hsl[2] = hsl[2] * (1 + tint);
	else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
	return rgb2Hex(hsl2RGB(hsl));
}

/* 18.3.1.13 width calculations */
var DEF_MDW = 7, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width) { return (( width + ((128/MDW)|0)/256 )* MDW )|0; }
function px2char(px) { return (((px - 5)/MDW * 100 + 0.5)|0)/100; }
function char2width(chr) { return (((chr * MDW + 5)/MDW*256)|0)/256; }
function cycle_width(collw) { return char2width(px2char(width2px(collw))); }
function find_mdw(collw, coll) {
	if(cycle_width(collw) != collw) {
		for(MDW=DEF_MDW; MDW&gt;MIN_MDW; --MDW) if(cycle_width(collw) === collw) break;
		if(MDW === MIN_MDW) for(MDW=DEF_MDW+1; MDW&lt;MAX_MDW; ++MDW) if(cycle_width(collw) === collw) break;
		if(MDW === MAX_MDW) MDW = DEF_MDW;
	}
}

/* [MS-EXSPXML3] 2.4.54 ST_enmPattern */
var XLMLPatternTypeMap = {
	&quot;None&quot;: &quot;none&quot;,
	&quot;Solid&quot;: &quot;solid&quot;,
	&quot;Gray50&quot;: &quot;mediumGray&quot;,
	&quot;Gray75&quot;: &quot;darkGray&quot;,
	&quot;Gray25&quot;: &quot;lightGray&quot;,
	&quot;HorzStripe&quot;: &quot;darkHorizontal&quot;,
	&quot;VertStripe&quot;: &quot;darkVertical&quot;,
	&quot;ReverseDiagStripe&quot;: &quot;darkDown&quot;,
	&quot;DiagStripe&quot;: &quot;darkUp&quot;,
	&quot;DiagCross&quot;: &quot;darkGrid&quot;,
	&quot;ThickDiagCross&quot;: &quot;darkTrellis&quot;,
	&quot;ThinHorzStripe&quot;: &quot;lightHorizontal&quot;,
	&quot;ThinVertStripe&quot;: &quot;lightVertical&quot;,
	&quot;ThinReverseDiagStripe&quot;: &quot;lightDown&quot;,
	&quot;ThinHorzCross&quot;: &quot;lightGrid&quot;
};

var styles = {}; // shared styles

var themes = {}; // shared themes

/* 18.8.21 fills CT_Fills */
function parse_fills(t, opts) {
	styles.Fills = [];
	var fill = {};
	t[0].match(tagregex).forEach(function(x) {
		var y = parsexmltag(x);
		switch(y[0]) {
			case &#x27;&lt;fills&#x27;: case &#x27;&lt;fills&gt;&#x27;: case &#x27;&lt;/fills&gt;&#x27;: break;

			/* 18.8.20 fill CT_Fill */
			case &#x27;&lt;fill&gt;&#x27;: break;
			case &#x27;&lt;/fill&gt;&#x27;: styles.Fills.push(fill); fill = {}; break;

			/* 18.8.32 patternFill CT_PatternFill */
			case &#x27;&lt;patternFill&#x27;:
				if(y.patternType) fill.patternType = y.patternType;
				break;
			case &#x27;&lt;patternFill/&gt;&#x27;: case &#x27;&lt;/patternFill&gt;&#x27;: break;

			/* 18.8.3 bgColor CT_Color */
			case &#x27;&lt;bgColor&#x27;:
				if(!fill.bgColor) fill.bgColor = {};
				if(y.indexed) fill.bgColor.indexed = parseInt(y.indexed, 10);
				if(y.theme) fill.bgColor.theme = parseInt(y.theme, 10);
				if(y.tint) fill.bgColor.tint = parseFloat(y.tint);
				/* Excel uses ARGB strings */
				if(y.rgb) fill.bgColor.rgb = y.rgb.substring(y.rgb.length - 6);
				break;
			case &#x27;&lt;bgColor/&gt;&#x27;: case &#x27;&lt;/bgColor&gt;&#x27;: break;

			/* 18.8.19 fgColor CT_Color */
			case &#x27;&lt;fgColor&#x27;:
				if(!fill.fgColor) fill.fgColor = {};
				if(y.theme) fill.fgColor.theme = parseInt(y.theme, 10);
				if(y.tint) fill.fgColor.tint = parseFloat(y.tint);
				/* Excel uses ARGB strings */
				if(y.rgb) fill.fgColor.rgb = y.rgb.substring(y.rgb.length - 6);
				break;
			case &#x27;&lt;fgColor/&gt;&#x27;: case &#x27;&lt;/fgColor&gt;&#x27;: break;

			default: if(opts.WTF) throw &#x27;unrecognized &#x27; + y[0] + &#x27; in fills&#x27;;
		}
	});
}

/* 18.8.31 numFmts CT_NumFmts */
function parse_numFmts(t, opts) {
	styles.NumberFmt = [];
	var k = keys(SSF._table);
	for(var i=0; i &lt; k.length; ++i) styles.NumberFmt[k[i]] = SSF._table[k[i]];
	var m = t[0].match(tagregex);
	for(i=0; i &lt; m.length; ++i) {
		var y = parsexmltag(m[i]);
		switch(y[0]) {
			case &#x27;&lt;numFmts&#x27;: case &#x27;&lt;/numFmts&gt;&#x27;: case &#x27;&lt;numFmts/&gt;&#x27;: case &#x27;&lt;numFmts&gt;&#x27;: break;
			case &#x27;&lt;numFmt&#x27;: {
				var f=unescapexml(utf8read(y.formatCode)), j=parseInt(y.numFmtId,10);
				styles.NumberFmt[j] = f; if(j&gt;0) SSF.load(f,j);
			} break;
			default: if(opts.WTF) throw &#x27;unrecognized &#x27; + y[0] + &#x27; in numFmts&#x27;;
		}
	}
}

function write_numFmts(NF, opts) {
	var o = [&quot;&lt;numFmts&gt;&quot;];
	[[5,8],[23,26],[41,44],[63,66],[164,392]].forEach(function(r) {
		for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] !== undefined) o[o.length] = (writextag(&#x27;numFmt&#x27;,null,{numFmtId:i,formatCode:escapexml(NF[i])}));
	});
	if(o.length === 1) return &quot;&quot;;
	o[o.length] = (&quot;&lt;/numFmts&gt;&quot;);
	o[0] = writextag(&#x27;numFmts&#x27;, null, { count:o.length-2 }).replace(&quot;/&gt;&quot;, &quot;&gt;&quot;);
	return o.join(&quot;&quot;);
}

/* 18.8.10 cellXfs CT_CellXfs */
function parse_cellXfs(t, opts) {
	styles.CellXf = [];
	t[0].match(tagregex).forEach(function(x) {
		var y = parsexmltag(x);
		switch(y[0]) {
			case &#x27;&lt;cellXfs&#x27;: case &#x27;&lt;cellXfs&gt;&#x27;: case &#x27;&lt;cellXfs/&gt;&#x27;: case &#x27;&lt;/cellXfs&gt;&#x27;: break;

			/* 18.8.45 xf CT_Xf */
			case &#x27;&lt;xf&#x27;: delete y[0];
				if(y.numFmtId) y.numFmtId = parseInt(y.numFmtId, 10);
				if(y.fillId) y.fillId = parseInt(y.fillId, 10);
				styles.CellXf.push(y); break;
			case &#x27;&lt;/xf&gt;&#x27;: break;

			/* 18.8.1 alignment CT_CellAlignment */
			case &#x27;&lt;alignment&#x27;: case &#x27;&lt;alignment/&gt;&#x27;: break;

			/* 18.8.33 protection CT_CellProtection */
			case &#x27;&lt;protection&#x27;: case &#x27;&lt;/protection&gt;&#x27;: case &#x27;&lt;protection/&gt;&#x27;: break;

			case &#x27;&lt;extLst&#x27;: case &#x27;&lt;/extLst&gt;&#x27;: break;
			case &#x27;&lt;ext&#x27;: break;
			default: if(opts.WTF) throw &#x27;unrecognized &#x27; + y[0] + &#x27; in cellXfs&#x27;;
		}
	});
}

function write_cellXfs(cellXfs) {
	var o = [];
	o[o.length] = (writextag(&#x27;cellXfs&#x27;,null));
	cellXfs.forEach(function(c) { o[o.length] = (writextag(&#x27;xf&#x27;, null, c)); });
	o[o.length] = (&quot;&lt;/cellXfs&gt;&quot;);
	if(o.length === 2) return &quot;&quot;;
	o[0] = writextag(&#x27;cellXfs&#x27;,null, {count:o.length-2}).replace(&quot;/&gt;&quot;,&quot;&gt;&quot;);
	return o.join(&quot;&quot;);
}

/* 18.8 Styles CT_Stylesheet*/
var parse_sty_xml= (function make_pstyx() {
var numFmtRegex = /&lt;numFmts([^&gt;]*)&gt;.*&lt;\/numFmts&gt;/;
var cellXfRegex = /&lt;cellXfs([^&gt;]*)&gt;.*&lt;\/cellXfs&gt;/;
var fillsRegex = /&lt;fills([^&gt;]*)&gt;.*&lt;\/fills&gt;/;

return function parse_sty_xml(data, opts) {
	/* 18.8.39 styleSheet CT_Stylesheet */
	var t;

	/* numFmts CT_NumFmts ? */
	if((t=data.match(numFmtRegex))) parse_numFmts(t, opts);

	/* fonts CT_Fonts ? */
	/*if((t=data.match(/&lt;fonts([^&gt;]*)&gt;.*&lt;\/fonts&gt;/))) parse_fonts(t, opts);*/

	/* fills CT_Fills */
	if((t=data.match(fillsRegex))) parse_fills(t, opts);

	/* borders CT_Borders ? */
	/* cellStyleXfs CT_CellStyleXfs ? */

	/* cellXfs CT_CellXfs ? */
	if((t=data.match(cellXfRegex))) parse_cellXfs(t, opts);

	/* dxfs CT_Dxfs ? */
	/* tableStyles CT_TableStyles ? */
	/* colors CT_Colors ? */
	/* extLst CT_ExtensionList ? */

	return styles;
};
})();

var STYLES_XML_ROOT = writextag(&#x27;styleSheet&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.main[0],
	&#x27;xmlns:vt&#x27;: XMLNS.vt
});

RELS.STY = &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles&quot;;

function write_sty_xml(wb, opts) {
	var o = [XML_HEADER, STYLES_XML_ROOT], w;
	if((w = write_numFmts(wb.SSF)) != null) o[o.length] = w;
	o[o.length] = (&#x27;&lt;fonts count=&quot;1&quot;&gt;&lt;font&gt;&lt;sz val=&quot;12&quot;/&gt;&lt;color theme=&quot;1&quot;/&gt;&lt;name val=&quot;Calibri&quot;/&gt;&lt;family val=&quot;2&quot;/&gt;&lt;scheme val=&quot;minor&quot;/&gt;&lt;/font&gt;&lt;/fonts&gt;&#x27;);
	o[o.length] = (&#x27;&lt;fills count=&quot;2&quot;&gt;&lt;fill&gt;&lt;patternFill patternType=&quot;none&quot;/&gt;&lt;/fill&gt;&lt;fill&gt;&lt;patternFill patternType=&quot;gray125&quot;/&gt;&lt;/fill&gt;&lt;/fills&gt;&#x27;);
	o[o.length] = (&#x27;&lt;borders count=&quot;1&quot;&gt;&lt;border&gt;&lt;left/&gt;&lt;right/&gt;&lt;top/&gt;&lt;bottom/&gt;&lt;diagonal/&gt;&lt;/border&gt;&lt;/borders&gt;&#x27;);
	o[o.length] = (&#x27;&lt;cellStyleXfs count=&quot;1&quot;&gt;&lt;xf numFmtId=&quot;0&quot; fontId=&quot;0&quot; fillId=&quot;0&quot; borderId=&quot;0&quot;/&gt;&lt;/cellStyleXfs&gt;&#x27;);
	if((w = write_cellXfs(opts.cellXfs))) o[o.length] = (w);
	o[o.length] = (&#x27;&lt;cellStyles count=&quot;1&quot;&gt;&lt;cellStyle name=&quot;Normal&quot; xfId=&quot;0&quot; builtinId=&quot;0&quot;/&gt;&lt;/cellStyles&gt;&#x27;);
	o[o.length] = (&#x27;&lt;dxfs count=&quot;0&quot;/&gt;&#x27;);
	o[o.length] = (&#x27;&lt;tableStyles count=&quot;0&quot; defaultTableStyle=&quot;TableStyleMedium9&quot; defaultPivotStyle=&quot;PivotStyleMedium4&quot;/&gt;&#x27;);

	if(o.length&gt;2){ o[o.length] = (&#x27;&lt;/styleSheet&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* [MS-XLSB] 2.4.651 BrtFmt */
function parse_BrtFmt(data, length) {
	var ifmt = data.read_shift(2);
	var stFmtCode = parse_XLWideString(data,length-2);
	return [ifmt, stFmtCode];
}

/* [MS-XLSB] 2.4.653 BrtFont TODO */
function parse_BrtFont(data, length) {
	var out = {flags:{}};
	out.dyHeight = data.read_shift(2);
	out.grbit = parse_FontFlags(data, 2);
	out.bls = data.read_shift(2);
	out.sss = data.read_shift(2);
	out.uls = data.read_shift(1);
	out.bFamily = data.read_shift(1);
	out.bCharSet = data.read_shift(1);
	data.l++;
	out.brtColor = parse_BrtColor(data, 8);
	out.bFontScheme = data.read_shift(1);
	out.name = parse_XLWideString(data, length - 21);

	out.flags.Bold = out.bls === 0x02BC;
	out.flags.Italic = out.grbit.fItalic;
	out.flags.Strikeout = out.grbit.fStrikeout;
	out.flags.Outline = out.grbit.fOutline;
	out.flags.Shadow = out.grbit.fShadow;
	out.flags.Condense = out.grbit.fCondense;
	out.flags.Extend = out.grbit.fExtend;
	out.flags.Sub = out.sss &amp; 0x2;
	out.flags.Sup = out.sss &amp; 0x1;
	return out;
}

/* [MS-XLSB] 2.4.816 BrtXF */
function parse_BrtXF(data, length) {
	var ixfeParent = data.read_shift(2);
	var ifmt = data.read_shift(2);
	parsenoop(data, length-4);
	return {ixfe:ixfeParent, ifmt:ifmt };
}

/* [MS-XLSB] 2.1.7.50 Styles */
function parse_sty_bin(data, opts) {
	styles.NumberFmt = [];
	for(var y in SSF._table) styles.NumberFmt[y] = SSF._table[y];

	styles.CellXf = [];
	var state = &quot;&quot;; /* TODO: this should be a stack */
	var pass = false;
	recordhopper(data, function hopper_sty(val, R, RT) {
		switch(R.n) {
			case &#x27;BrtFmt&#x27;:
				styles.NumberFmt[val[0]] = val[1]; SSF.load(val[1], val[0]);
				break;
			case &#x27;BrtFont&#x27;: break; /* TODO */
			case &#x27;BrtKnownFonts&#x27;: break; /* TODO */
			case &#x27;BrtFill&#x27;: break; /* TODO */
			case &#x27;BrtBorder&#x27;: break; /* TODO */
			case &#x27;BrtXF&#x27;:
				if(state === &quot;CELLXFS&quot;) {
					styles.CellXf.push(val);
				}
				break; /* TODO */
			case &#x27;BrtStyle&#x27;: break; /* TODO */
			case &#x27;BrtDXF&#x27;: break; /* TODO */
			case &#x27;BrtMRUColor&#x27;: break; /* TODO */
			case &#x27;BrtIndexedColor&#x27;: break; /* TODO */
			case &#x27;BrtBeginStyleSheet&#x27;: break;
			case &#x27;BrtEndStyleSheet&#x27;: break;
			case &#x27;BrtBeginTableStyle&#x27;: break;
			case &#x27;BrtTableStyleElement&#x27;: break;
			case &#x27;BrtEndTableStyle&#x27;: break;
			case &#x27;BrtBeginFmts&#x27;: state = &quot;FMTS&quot;; break;
			case &#x27;BrtEndFmts&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginFonts&#x27;: state = &quot;FONTS&quot;; break;
			case &#x27;BrtEndFonts&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtACBegin&#x27;: state = &quot;ACFONTS&quot;; break;
			case &#x27;BrtACEnd&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginFills&#x27;: state = &quot;FILLS&quot;; break;
			case &#x27;BrtEndFills&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginBorders&#x27;: state = &quot;BORDERS&quot;; break;
			case &#x27;BrtEndBorders&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginCellStyleXFs&#x27;: state = &quot;CELLSTYLEXFS&quot;; break;
			case &#x27;BrtEndCellStyleXFs&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginCellXFs&#x27;: state = &quot;CELLXFS&quot;; break;
			case &#x27;BrtEndCellXFs&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginStyles&#x27;: state = &quot;STYLES&quot;; break;
			case &#x27;BrtEndStyles&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginDXFs&#x27;: state = &quot;DXFS&quot;; break;
			case &#x27;BrtEndDXFs&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginTableStyles&#x27;: state = &quot;TABLESTYLES&quot;; break;
			case &#x27;BrtEndTableStyles&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginColorPalette&#x27;: state = &quot;COLORPALETTE&quot;; break;
			case &#x27;BrtEndColorPalette&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginIndexedColors&#x27;: state = &quot;INDEXEDCOLORS&quot;; break;
			case &#x27;BrtEndIndexedColors&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtBeginMRUColors&#x27;: state = &quot;MRUCOLORS&quot;; break;
			case &#x27;BrtEndMRUColors&#x27;: state = &quot;&quot;; break;
			case &#x27;BrtFRTBegin&#x27;: pass = true; break;
			case &#x27;BrtFRTEnd&#x27;: pass = false; break;
			case &#x27;BrtBeginStyleSheetExt14&#x27;: break;
			case &#x27;BrtBeginSlicerStyles&#x27;: break;
			case &#x27;BrtEndSlicerStyles&#x27;: break;
			case &#x27;BrtBeginTimelineStylesheetExt15&#x27;: break;
			case &#x27;BrtEndTimelineStylesheetExt15&#x27;: break;
			case &#x27;BrtBeginTimelineStyles&#x27;: break;
			case &#x27;BrtEndTimelineStyles&#x27;: break;
			case &#x27;BrtEndStyleSheetExt14&#x27;: break;
			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + RT + &quot; &quot; + R.n);
		}
	});
	return styles;
}

/* [MS-XLSB] 2.1.7.50 Styles */
function write_sty_bin(data, opts) {
	var ba = buf_array();
	write_record(ba, &quot;BrtBeginStyleSheet&quot;);
	/* [FMTS] */
	/* [FONTS] */
	/* [FILLS] */
	/* [BORDERS] */
	/* CELLSTYLEXFS */
	/* CELLXFS*/
	/* STYLES */
	/* DXFS */
	/* TABLESTYLES */
	/* [COLORPALETTE] */
	/* FRTSTYLESHEET*/
	write_record(ba, &quot;BrtEndStyleSheet&quot;);
	return ba.end();
}
RELS.THEME = &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme&quot;;

/* 20.1.6.2 clrScheme CT_ColorScheme */
function parse_clrScheme(t, opts) {
	themes.themeElements.clrScheme = [];
	var color = {};
	t[0].match(tagregex).forEach(function(x) {
		var y = parsexmltag(x);
		switch(y[0]) {
			case &#x27;&lt;a:clrScheme&#x27;: case &#x27;&lt;/a:clrScheme&gt;&#x27;: break;

			/* 20.1.2.3.32 srgbClr CT_SRgbColor */
			case &#x27;&lt;a:srgbClr&#x27;: color.rgb = y.val; break;

			/* 20.1.2.3.33 sysClr CT_SystemColor */
			case &#x27;&lt;a:sysClr&#x27;: color.rgb = y.lastClr; break;

			/* 20.1.4.1.9 dk1 (Dark 1) */
			case &#x27;&lt;a:dk1&gt;&#x27;:
			case &#x27;&lt;/a:dk1&gt;&#x27;:
			/* 20.1.4.1.10 dk2 (Dark 2) */
			case &#x27;&lt;a:dk2&gt;&#x27;:
			case &#x27;&lt;/a:dk2&gt;&#x27;:
			/* 20.1.4.1.22 lt1 (Light 1) */
			case &#x27;&lt;a:lt1&gt;&#x27;:
			case &#x27;&lt;/a:lt1&gt;&#x27;:
			/* 20.1.4.1.23 lt2 (Light 2) */
			case &#x27;&lt;a:lt2&gt;&#x27;:
			case &#x27;&lt;/a:lt2&gt;&#x27;:
			/* 20.1.4.1.1 accent1 (Accent 1) */
			case &#x27;&lt;a:accent1&gt;&#x27;:
			case &#x27;&lt;/a:accent1&gt;&#x27;:
			/* 20.1.4.1.2 accent2 (Accent 2) */
			case &#x27;&lt;a:accent2&gt;&#x27;:
			case &#x27;&lt;/a:accent2&gt;&#x27;:
			/* 20.1.4.1.3 accent3 (Accent 3) */
			case &#x27;&lt;a:accent3&gt;&#x27;:
			case &#x27;&lt;/a:accent3&gt;&#x27;:
			/* 20.1.4.1.4 accent4 (Accent 4) */
			case &#x27;&lt;a:accent4&gt;&#x27;:
			case &#x27;&lt;/a:accent4&gt;&#x27;:
			/* 20.1.4.1.5 accent5 (Accent 5) */
			case &#x27;&lt;a:accent5&gt;&#x27;:
			case &#x27;&lt;/a:accent5&gt;&#x27;:
			/* 20.1.4.1.6 accent6 (Accent 6) */
			case &#x27;&lt;a:accent6&gt;&#x27;:
			case &#x27;&lt;/a:accent6&gt;&#x27;:
			/* 20.1.4.1.19 hlink (Hyperlink) */
			case &#x27;&lt;a:hlink&gt;&#x27;:
			case &#x27;&lt;/a:hlink&gt;&#x27;:
			/* 20.1.4.1.15 folHlink (Followed Hyperlink) */
			case &#x27;&lt;a:folHlink&gt;&#x27;:
			case &#x27;&lt;/a:folHlink&gt;&#x27;:
				if (y[0][1] === &#x27;/&#x27;) {
					themes.themeElements.clrScheme.push(color);
					color = {};
				} else {
					color.name = y[0].substring(3, y[0].length - 1);
				}
				break;

			default: if(opts.WTF) throw &#x27;unrecognized &#x27; + y[0] + &#x27; in clrScheme&#x27;;
		}
	});
}

/* 20.1.4.1.18 fontScheme CT_FontScheme */
function parse_fontScheme(t, opts) { }

/* 20.1.4.1.15 fmtScheme CT_StyleMatrix */
function parse_fmtScheme(t, opts) { }

var clrsregex = /&lt;a:clrScheme([^&gt;]*)&gt;[^\u2603]*&lt;\/a:clrScheme&gt;/;
var fntsregex = /&lt;a:fontScheme([^&gt;]*)&gt;[^\u2603]*&lt;\/a:fontScheme&gt;/;
var fmtsregex = /&lt;a:fmtScheme([^&gt;]*)&gt;[^\u2603]*&lt;\/a:fmtScheme&gt;/;

/* 20.1.6.10 themeElements CT_BaseStyles */
function parse_themeElements(data, opts) {
	themes.themeElements = {};

	var t;

	[
		/* clrScheme CT_ColorScheme */
		[&#x27;clrScheme&#x27;, clrsregex, parse_clrScheme],
		/* fontScheme CT_FontScheme */
		[&#x27;fontScheme&#x27;, fntsregex, parse_fontScheme],
		/* fmtScheme CT_StyleMatrix */
		[&#x27;fmtScheme&#x27;, fmtsregex, parse_fmtScheme]
	].forEach(function(m) {
		if(!(t=data.match(m[1]))) throw m[0] + &#x27; not found in themeElements&#x27;;
		m[2](t, opts);
	});
}

var themeltregex = /&lt;a:themeElements([^&gt;]*)&gt;[^\u2603]*&lt;\/a:themeElements&gt;/;

/* 14.2.7 Theme Part */
function parse_theme_xml(data, opts) {
	/* 20.1.6.9 theme CT_OfficeStyleSheet */
	if(!data || data.length === 0) return themes;

	var t;

	/* themeElements CT_BaseStyles */
	if(!(t=data.match(themeltregex))) throw &#x27;themeElements not found in theme&#x27;;
	parse_themeElements(t[0], opts);

	return themes;
}

function write_theme() { return &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;\n&lt;a:theme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Office Theme&quot;&gt;&lt;a:themeElements&gt;&lt;a:clrScheme name=&quot;Office&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;1F497D&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;EEECE1&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;4F81BD&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;C0504D&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;9BBB59&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbClr val=&quot;8064A2&quot;/&gt;&lt;/a:accent4&gt;&lt;a:accent5&gt;&lt;a:srgbClr val=&quot;4BACC6&quot;/&gt;&lt;/a:accent5&gt;&lt;a:accent6&gt;&lt;a:srgbClr val=&quot;F79646&quot;/&gt;&lt;/a:accent6&gt;&lt;a:hlink&gt;&lt;a:srgbClr val=&quot;0000FF&quot;/&gt;&lt;/a:hlink&gt;&lt;a:folHlink&gt;&lt;a:srgbClr val=&quot;800080&quot;/&gt;&lt;/a:folHlink&gt;&lt;/a:clrScheme&gt;&lt;a:fontScheme name=&quot;Office&quot;&gt;&lt;a:majorFont&gt;&lt;a:latin typeface=&quot;Cambria&quot;/&gt;&lt;a:ea typeface=&quot;&quot;/&gt;&lt;a:cs typeface=&quot;&quot;/&gt;&lt;a:font script=&quot;Jpan&quot; typeface=&quot;ＭＳ Ｐゴシック&quot;/&gt;&lt;a:font script=&quot;Hang&quot; typeface=&quot;맑은 고딕&quot;/&gt;&lt;a:font script=&quot;Hans&quot; typeface=&quot;宋体&quot;/&gt;&lt;a:font script=&quot;Hant&quot; typeface=&quot;新細明體&quot;/&gt;&lt;a:font script=&quot;Arab&quot; typeface=&quot;Times New Roman&quot;/&gt;&lt;a:font script=&quot;Hebr&quot; typeface=&quot;Times New Roman&quot;/&gt;&lt;a:font script=&quot;Thai&quot; typeface=&quot;Tahoma&quot;/&gt;&lt;a:font script=&quot;Ethi&quot; typeface=&quot;Nyala&quot;/&gt;&lt;a:font script=&quot;Beng&quot; typeface=&quot;Vrinda&quot;/&gt;&lt;a:font script=&quot;Gujr&quot; typeface=&quot;Shruti&quot;/&gt;&lt;a:font script=&quot;Khmr&quot; typeface=&quot;MoolBoran&quot;/&gt;&lt;a:font script=&quot;Knda&quot; typeface=&quot;Tunga&quot;/&gt;&lt;a:font script=&quot;Guru&quot; typeface=&quot;Raavi&quot;/&gt;&lt;a:font script=&quot;Cans&quot; typeface=&quot;Euphemia&quot;/&gt;&lt;a:font script=&quot;Cher&quot; typeface=&quot;Plantagenet Cherokee&quot;/&gt;&lt;a:font script=&quot;Yiii&quot; typeface=&quot;Microsoft Yi Baiti&quot;/&gt;&lt;a:font script=&quot;Tibt&quot; typeface=&quot;Microsoft Himalaya&quot;/&gt;&lt;a:font script=&quot;Thaa&quot; typeface=&quot;MV Boli&quot;/&gt;&lt;a:font script=&quot;Deva&quot; typeface=&quot;Mangal&quot;/&gt;&lt;a:font script=&quot;Telu&quot; typeface=&quot;Gautami&quot;/&gt;&lt;a:font script=&quot;Taml&quot; typeface=&quot;Latha&quot;/&gt;&lt;a:font script=&quot;Syrc&quot; typeface=&quot;Estrangelo Edessa&quot;/&gt;&lt;a:font script=&quot;Orya&quot; typeface=&quot;Kalinga&quot;/&gt;&lt;a:font script=&quot;Mlym&quot; typeface=&quot;Kartika&quot;/&gt;&lt;a:font script=&quot;Laoo&quot; typeface=&quot;DokChampa&quot;/&gt;&lt;a:font script=&quot;Sinh&quot; typeface=&quot;Iskoola Pota&quot;/&gt;&lt;a:font script=&quot;Mong&quot; typeface=&quot;Mongolian Baiti&quot;/&gt;&lt;a:font script=&quot;Viet&quot; typeface=&quot;Times New Roman&quot;/&gt;&lt;a:font script=&quot;Uigh&quot; typeface=&quot;Microsoft Uighur&quot;/&gt;&lt;a:font script=&quot;Geor&quot; typeface=&quot;Sylfaen&quot;/&gt;&lt;/a:majorFont&gt;&lt;a:minorFont&gt;&lt;a:latin typeface=&quot;Calibri&quot;/&gt;&lt;a:ea typeface=&quot;&quot;/&gt;&lt;a:cs typeface=&quot;&quot;/&gt;&lt;a:font script=&quot;Jpan&quot; typeface=&quot;ＭＳ Ｐゴシック&quot;/&gt;&lt;a:font script=&quot;Hang&quot; typeface=&quot;맑은 고딕&quot;/&gt;&lt;a:font script=&quot;Hans&quot; typeface=&quot;宋体&quot;/&gt;&lt;a:font script=&quot;Hant&quot; typeface=&quot;新細明體&quot;/&gt;&lt;a:font script=&quot;Arab&quot; typeface=&quot;Arial&quot;/&gt;&lt;a:font script=&quot;Hebr&quot; typeface=&quot;Arial&quot;/&gt;&lt;a:font script=&quot;Thai&quot; typeface=&quot;Tahoma&quot;/&gt;&lt;a:font script=&quot;Ethi&quot; typeface=&quot;Nyala&quot;/&gt;&lt;a:font script=&quot;Beng&quot; typeface=&quot;Vrinda&quot;/&gt;&lt;a:font script=&quot;Gujr&quot; typeface=&quot;Shruti&quot;/&gt;&lt;a:font script=&quot;Khmr&quot; typeface=&quot;DaunPenh&quot;/&gt;&lt;a:font script=&quot;Knda&quot; typeface=&quot;Tunga&quot;/&gt;&lt;a:font script=&quot;Guru&quot; typeface=&quot;Raavi&quot;/&gt;&lt;a:font script=&quot;Cans&quot; typeface=&quot;Euphemia&quot;/&gt;&lt;a:font script=&quot;Cher&quot; typeface=&quot;Plantagenet Cherokee&quot;/&gt;&lt;a:font script=&quot;Yiii&quot; typeface=&quot;Microsoft Yi Baiti&quot;/&gt;&lt;a:font script=&quot;Tibt&quot; typeface=&quot;Microsoft Himalaya&quot;/&gt;&lt;a:font script=&quot;Thaa&quot; typeface=&quot;MV Boli&quot;/&gt;&lt;a:font script=&quot;Deva&quot; typeface=&quot;Mangal&quot;/&gt;&lt;a:font script=&quot;Telu&quot; typeface=&quot;Gautami&quot;/&gt;&lt;a:font script=&quot;Taml&quot; typeface=&quot;Latha&quot;/&gt;&lt;a:font script=&quot;Syrc&quot; typeface=&quot;Estrangelo Edessa&quot;/&gt;&lt;a:font script=&quot;Orya&quot; typeface=&quot;Kalinga&quot;/&gt;&lt;a:font script=&quot;Mlym&quot; typeface=&quot;Kartika&quot;/&gt;&lt;a:font script=&quot;Laoo&quot; typeface=&quot;DokChampa&quot;/&gt;&lt;a:font script=&quot;Sinh&quot; typeface=&quot;Iskoola Pota&quot;/&gt;&lt;a:font script=&quot;Mong&quot; typeface=&quot;Mongolian Baiti&quot;/&gt;&lt;a:font script=&quot;Viet&quot; typeface=&quot;Arial&quot;/&gt;&lt;a:font script=&quot;Uigh&quot; typeface=&quot;Microsoft Uighur&quot;/&gt;&lt;a:font script=&quot;Geor&quot; typeface=&quot;Sylfaen&quot;/&gt;&lt;/a:minorFont&gt;&lt;/a:fontScheme&gt;&lt;a:fmtScheme name=&quot;Office&quot;&gt;&lt;a:fillStyleLst&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=&quot;phClr&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:gradFill rotWithShape=&quot;1&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=&quot;0&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;50000&quot;/&gt;&lt;a:satMod val=&quot;300000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;35000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;37000&quot;/&gt;&lt;a:satMod val=&quot;300000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;100000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;15000&quot;/&gt;&lt;a:satMod val=&quot;350000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:lin ang=&quot;16200000&quot; scaled=&quot;1&quot;/&gt;&lt;/a:gradFill&gt;&lt;a:gradFill rotWithShape=&quot;1&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=&quot;0&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;100000&quot;/&gt;&lt;a:shade val=&quot;100000&quot;/&gt;&lt;a:satMod val=&quot;130000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;100000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;50000&quot;/&gt;&lt;a:shade val=&quot;100000&quot;/&gt;&lt;a:satMod val=&quot;350000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:lin ang=&quot;16200000&quot; scaled=&quot;0&quot;/&gt;&lt;/a:gradFill&gt;&lt;/a:fillStyleLst&gt;&lt;a:lnStyleLst&gt;&lt;a:ln w=&quot;9525&quot; cap=&quot;flat&quot; cmpd=&quot;sng&quot; algn=&quot;ctr&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:shade val=&quot;95000&quot;/&gt;&lt;a:satMod val=&quot;105000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=&quot;solid&quot;/&gt;&lt;/a:ln&gt;&lt;a:ln w=&quot;25400&quot; cap=&quot;flat&quot; cmpd=&quot;sng&quot; algn=&quot;ctr&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=&quot;phClr&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=&quot;solid&quot;/&gt;&lt;/a:ln&gt;&lt;a:ln w=&quot;38100&quot; cap=&quot;flat&quot; cmpd=&quot;sng&quot; algn=&quot;ctr&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=&quot;phClr&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=&quot;solid&quot;/&gt;&lt;/a:ln&gt;&lt;/a:lnStyleLst&gt;&lt;a:effectStyleLst&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=&quot;40000&quot; dist=&quot;20000&quot; dir=&quot;5400000&quot; rotWithShape=&quot;0&quot;&gt;&lt;a:srgbClr val=&quot;000000&quot;&gt;&lt;a:alpha val=&quot;38000&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;/a:effectStyle&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=&quot;40000&quot; dist=&quot;23000&quot; dir=&quot;5400000&quot; rotWithShape=&quot;0&quot;&gt;&lt;a:srgbClr val=&quot;000000&quot;&gt;&lt;a:alpha val=&quot;35000&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;/a:effectStyle&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=&quot;40000&quot; dist=&quot;23000&quot; dir=&quot;5400000&quot; rotWithShape=&quot;0&quot;&gt;&lt;a:srgbClr val=&quot;000000&quot;&gt;&lt;a:alpha val=&quot;35000&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;a:scene3d&gt;&lt;a:camera prst=&quot;orthographicFront&quot;&gt;&lt;a:rot lat=&quot;0&quot; lon=&quot;0&quot; rev=&quot;0&quot;/&gt;&lt;/a:camera&gt;&lt;a:lightRig rig=&quot;threePt&quot; dir=&quot;t&quot;&gt;&lt;a:rot lat=&quot;0&quot; lon=&quot;0&quot; rev=&quot;1200000&quot;/&gt;&lt;/a:lightRig&gt;&lt;/a:scene3d&gt;&lt;a:sp3d&gt;&lt;a:bevelT w=&quot;63500&quot; h=&quot;25400&quot;/&gt;&lt;/a:sp3d&gt;&lt;/a:effectStyle&gt;&lt;/a:effectStyleLst&gt;&lt;a:bgFillStyleLst&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=&quot;phClr&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:gradFill rotWithShape=&quot;1&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=&quot;0&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;40000&quot;/&gt;&lt;a:satMod val=&quot;350000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;40000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;45000&quot;/&gt;&lt;a:shade val=&quot;99000&quot;/&gt;&lt;a:satMod val=&quot;350000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;100000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:shade val=&quot;20000&quot;/&gt;&lt;a:satMod val=&quot;255000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:path path=&quot;circle&quot;&gt;&lt;a:fillToRect l=&quot;50000&quot; t=&quot;-80000&quot; r=&quot;50000&quot; b=&quot;180000&quot;/&gt;&lt;/a:path&gt;&lt;/a:gradFill&gt;&lt;a:gradFill rotWithShape=&quot;1&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=&quot;0&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:tint val=&quot;80000&quot;/&gt;&lt;a:satMod val=&quot;300000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=&quot;100000&quot;&gt;&lt;a:schemeClr val=&quot;phClr&quot;&gt;&lt;a:shade val=&quot;30000&quot;/&gt;&lt;a:satMod val=&quot;200000&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:path path=&quot;circle&quot;&gt;&lt;a:fillToRect l=&quot;50000&quot; t=&quot;50000&quot; r=&quot;50000&quot; b=&quot;50000&quot;/&gt;&lt;/a:path&gt;&lt;/a:gradFill&gt;&lt;/a:bgFillStyleLst&gt;&lt;/a:fmtScheme&gt;&lt;/a:themeElements&gt;&lt;a:objectDefaults&gt;&lt;a:spDef&gt;&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx=&quot;1&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx=&quot;3&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx=&quot;2&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx=&quot;minor&quot;&gt;&lt;a:schemeClr val=&quot;lt1&quot;/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;&lt;/a:spDef&gt;&lt;a:lnDef&gt;&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx=&quot;2&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx=&quot;0&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx=&quot;1&quot;&gt;&lt;a:schemeClr val=&quot;accent1&quot;/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx=&quot;minor&quot;&gt;&lt;a:schemeClr val=&quot;tx1&quot;/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;&lt;/a:lnDef&gt;&lt;/a:objectDefaults&gt;&lt;a:extraClrSchemeLst/&gt;&lt;/a:theme&gt;&#x27;; }
/* [MS-XLS] 2.4.326 TODO: payload is a zip file */
function parse_Theme(blob, length) {
	var dwThemeVersion = blob.read_shift(4);
	if(dwThemeVersion === 124226) return;
	blob.l += length-4;
}

/* 2.5.49 */
function parse_ColorTheme(blob, length) { return blob.read_shift(4); }

/* 2.5.155 */
function parse_FullColorExt(blob, length) {
	var o = {};
	o.xclrType = blob.read_shift(2);
	o.nTintShade = blob.read_shift(2);
	switch(o.xclrType) {
		case 0: blob.l += 4; break;
		case 1: o.xclrValue = parse_IcvXF(blob, 4); break;
		case 2: o.xclrValue = parse_LongRGBA(blob, 4); break;
		case 3: o.xclrValue = parse_ColorTheme(blob, 4); break;
		case 4: blob.l += 4; break;
	}
	blob.l += 8;
	return o;
}

/* 2.5.164 TODO: read 7 bits*/
function parse_IcvXF(blob, length) {
	return parsenoop(blob, length);
}

/* 2.5.280 */
function parse_XFExtGradient(blob, length) {
	return parsenoop(blob, length);
}

/* 2.5.108 */
function parse_ExtProp(blob, length) {
	var extType = blob.read_shift(2);
	var cb = blob.read_shift(2);
	var o = [extType];
	switch(extType) {
		case 0x04: case 0x05: case 0x07: case 0x08:
		case 0x09: case 0x0A: case 0x0B: case 0x0D:
			o[1] = parse_FullColorExt(blob, cb); break;
		case 0x06: o[1] = parse_XFExtGradient(blob, cb); break;
		case 0x0E: case 0x0F: o[1] = blob.read_shift(cb === 5 ? 1 : 2); break;
		default: throw new Error(&quot;Unrecognized ExtProp type: &quot; + extType + &quot; &quot; + cb);
	}
	return o;
}

/* 2.4.355 */
function parse_XFExt(blob, length) {
	var end = blob.l + length;
	blob.l += 2;
	var ixfe = blob.read_shift(2);
	blob.l += 2;
	var cexts = blob.read_shift(2);
	var ext = [];
	while(cexts-- &gt; 0) ext.push(parse_ExtProp(blob, end-blob.l));
	return {ixfe:ixfe, ext:ext};
}

/* xf is an XF, see parse_XFExt for xfext */
function update_xfext(xf, xfext) {
	xfext.forEach(function(xfe) {
		switch(xfe[0]) { /* 2.5.108 extPropData */
			case 0x04: break; /* foreground color */
			case 0x05: break; /* background color */
			case 0x07: case 0x08: case 0x09: case 0x0a: break;
			case 0x0d: break; /* text color */
			case 0x0e: break; /* font scheme */
			default: throw &quot;bafuq&quot; + xfe[0].toString(16);
		}
	});
}

/* 18.6 Calculation Chain */
function parse_cc_xml(data, opts) {
	var d = [];
	var l = 0, i = 1;
	(data.match(tagregex)||[]).forEach(function(x) {
		var y = parsexmltag(x);
		switch(y[0]) {
			case &#x27;&lt;?xml&#x27;: break;
			/* 18.6.2  calcChain CT_CalcChain 1 */
			case &#x27;&lt;calcChain&#x27;: case &#x27;&lt;calcChain&gt;&#x27;: case &#x27;&lt;/calcChain&gt;&#x27;: break;
			/* 18.6.1  c CT_CalcCell 1 */
			case &#x27;&lt;c&#x27;: delete y[0]; if(y.i) i = y.i; else y.i = i; d.push(y); break;
		}
	});
	return d;
}

function write_cc_xml(data, opts) { }
/* [MS-XLSB] 2.6.4.1 */
function parse_BrtCalcChainItem$(data, length) {
	var out = {};
	out.i = data.read_shift(4);
	var cell = {};
	cell.r = data.read_shift(4);
	cell.c = data.read_shift(4);
	out.r = encode_cell(cell);
	var flags = data.read_shift(1);
	if(flags &amp; 0x2) out.l = &#x27;1&#x27;;
	if(flags &amp; 0x8) out.a = &#x27;1&#x27;;
	return out;
}

/* 18.6 Calculation Chain */
function parse_cc_bin(data, opts) {
	var out = [];
	var pass = false;
	recordhopper(data, function hopper_cc(val, R, RT) {
		switch(R.n) {
			case &#x27;BrtCalcChainItem$&#x27;: out.push(val); break;
			case &#x27;BrtBeginCalcChain$&#x27;: break;
			case &#x27;BrtEndCalcChain$&#x27;: break;
			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + RT + &quot; &quot; + R.n);
		}
	});
	return out;
}

function write_cc_bin(data, opts) { }

function parse_comments(zip, dirComments, sheets, sheetRels, opts) {
	for(var i = 0; i != dirComments.length; ++i) {
		var canonicalpath=dirComments[i];
		var comments=parse_cmnt(getzipdata(zip, canonicalpath.replace(/^\//,&#x27;&#x27;), true), canonicalpath, opts);
		if(!comments || !comments.length) continue;
		// find the sheets targeted by these comments
		var sheetNames = keys(sheets);
		for(var j = 0; j != sheetNames.length; ++j) {
			var sheetName = sheetNames[j];
			var rels = sheetRels[sheetName];
			if(rels) {
				var rel = rels[canonicalpath];
				if(rel) insertCommentsIntoSheet(sheetName, sheets[sheetName], comments);
			}
		}
	}
}

function insertCommentsIntoSheet(sheetName, sheet, comments) {
	comments.forEach(function(comment) {
		var cell = sheet[comment.ref];
		if (!cell) {
			cell = {};
			sheet[comment.ref] = cell;
			var range = safe_decode_range(sheet[&quot;!ref&quot;]||&quot;BDWGO1000001:A1&quot;);
			var thisCell = decode_cell(comment.ref);
			if(range.s.r &gt; thisCell.r) range.s.r = thisCell.r;
			if(range.e.r &lt; thisCell.r) range.e.r = thisCell.r;
			if(range.s.c &gt; thisCell.c) range.s.c = thisCell.c;
			if(range.e.c &lt; thisCell.c) range.e.c = thisCell.c;
			var encoded = encode_range(range);
			if (encoded !== sheet[&quot;!ref&quot;]) sheet[&quot;!ref&quot;] = encoded;
		}

		if (!cell.c) cell.c = [];
		var o = {a: comment.author, t: comment.t, r: comment.r};
		if(comment.h) o.h = comment.h;
		cell.c.push(o);
	});
}

/* 18.7.3 CT_Comment */
function parse_comments_xml(data, opts) {
	if(data.match(/&lt;(?:\w+:)?comments *\/&gt;/)) return [];
	var authors = [];
	var commentList = [];
	data.match(/&lt;(?:\w+:)?authors&gt;([^\u2603]*)&lt;\/(?:\w+:)?authors&gt;/)[1].split(/&lt;\/\w*:?author&gt;/).forEach(function(x) {
		if(x === &quot;&quot; || x.trim() === &quot;&quot;) return;
		authors.push(x.match(/&lt;(?:\w+:)?author[^&gt;]*&gt;(.*)/)[1]);
	});
	(data.match(/&lt;(?:\w+:)?commentList&gt;([^\u2603]*)&lt;\/(?:\w+:)?commentList&gt;/)||[&quot;&quot;,&quot;&quot;])[1].split(/&lt;\/\w*:?comment&gt;/).forEach(function(x, index) {
		if(x === &quot;&quot; || x.trim() === &quot;&quot;) return;
		var y = parsexmltag(x.match(/&lt;(?:\w+:)?comment[^&gt;]*&gt;/)[0]);
		var comment = { author: y.authorId &amp;&amp; authors[y.authorId] ? authors[y.authorId] : undefined, ref: y.ref, guid: y.guid };
		var cell = decode_cell(y.ref);
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= cell.r) return;
		var textMatch = x.match(/&lt;text&gt;([^\u2603]*)&lt;\/text&gt;/);
		if (!textMatch || !textMatch[1]) return; // a comment may contain an empty text tag.
		var rt = parse_si(textMatch[1]);
		comment.r = rt.r;
		comment.t = rt.t;
		if(opts.cellHTML) comment.h = rt.h;
		commentList.push(comment);
	});
	return commentList;
}

function write_comments_xml(data, opts) { }
/* [MS-XLSB] 2.4.28 BrtBeginComment */
function parse_BrtBeginComment(data, length) {
	var out = {};
	out.iauthor = data.read_shift(4);
	var rfx = parse_UncheckedRfX(data, 16);
	out.rfx = rfx.s;
	out.ref = encode_cell(rfx.s);
	data.l += 16; /*var guid = parse_GUID(data); */
	return out;
}

/* [MS-XLSB] 2.4.324 BrtCommentAuthor */
var parse_BrtCommentAuthor = parse_XLWideString;

/* [MS-XLSB] 2.4.325 BrtCommentText */
var parse_BrtCommentText = parse_RichStr;

/* [MS-XLSB] 2.1.7.8 Comments */
function parse_comments_bin(data, opts) {
	var out = [];
	var authors = [];
	var c = {};
	var pass = false;
	recordhopper(data, function hopper_cmnt(val, R, RT) {
		switch(R.n) {
			case &#x27;BrtCommentAuthor&#x27;: authors.push(val); break;
			case &#x27;BrtBeginComment&#x27;: c = val; break;
			case &#x27;BrtCommentText&#x27;: c.t = val.t; c.h = val.h; c.r = val.r; break;
			case &#x27;BrtEndComment&#x27;:
				c.author = authors[c.iauthor];
				delete c.iauthor;
				if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= c.rfx.r) break;
				delete c.rfx; out.push(c); break;
			case &#x27;BrtBeginComments&#x27;: break;
			case &#x27;BrtEndComments&#x27;: break;
			case &#x27;BrtBeginCommentAuthors&#x27;: break;
			case &#x27;BrtEndCommentAuthors&#x27;: break;
			case &#x27;BrtBeginCommentList&#x27;: break;
			case &#x27;BrtEndCommentList&#x27;: break;
			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + RT + &quot; &quot; + R.n);
		}
	});
	return out;
}

function write_comments_bin(data, opts) { }
/* TODO: it will be useful to parse the function str */
var rc_to_a1 = (function(){
	var rcregex = /(^|[^A-Za-z])R(\[?)(-?\d+|)\]?C(\[?)(-?\d+|)\]?/g;
	var rcbase;
	function rcfunc($$,$1,$2,$3,$4,$5) {
		var R = $3.length&gt;0?parseInt($3,10)|0:0, C = $5.length&gt;0?parseInt($5,10)|0:0;
		if(C&lt;0 &amp;&amp; $4.length === 0) C=0;
		if($4.length &gt; 0) C += rcbase.c;
		if($2.length &gt; 0) R += rcbase.r;
		return $1 + encode_col(C) + encode_row(R);
	}
	return function rc_to_a1(fstr, base) {
		rcbase = base;
		return fstr.replace(rcregex, rcfunc);
	};
})();

/* --- formula references point to MS-XLS --- */
/* Small helpers */
function parseread(l) { return function(blob, length) { blob.l+=l; return; }; }
function parseread1(blob, length) { blob.l+=1; return; }

/* Rgce Helpers */

/* 2.5.51 */
function parse_ColRelU(blob, length) {
	var c = blob.read_shift(2);
	return [c &amp; 0x3FFF, (c &gt;&gt; 14) &amp; 1, (c &gt;&gt; 15) &amp; 1];
}

/* 2.5.198.105 */
function parse_RgceArea(blob, length) {
	var r=blob.read_shift(2), R=blob.read_shift(2);
	var c=parse_ColRelU(blob, 2);
	var C=parse_ColRelU(blob, 2);
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };
}

/* 2.5.198.105 TODO */
function parse_RgceAreaRel(blob, length) {
	var r=blob.read_shift(2), R=blob.read_shift(2);
	var c=parse_ColRelU(blob, 2);
	var C=parse_ColRelU(blob, 2);
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };
}

/* 2.5.198.109 */
function parse_RgceLoc(blob, length) {
	var r = blob.read_shift(2);
	var c = parse_ColRelU(blob, 2);
	return {r:r, c:c[0], cRel:c[1], rRel:c[2]};
}

/* 2.5.198.111 */
function parse_RgceLocRel(blob, length) {
	var r = blob.read_shift(2);
	var cl = blob.read_shift(2);
	var cRel = (cl &amp; 0x8000) &gt;&gt; 15, rRel = (cl &amp; 0x4000) &gt;&gt; 14;
	cl &amp;= 0x3FFF;
	if(cRel !== 0) while(cl &gt;= 0x100) cl -= 0x100;
	return {r:r,c:cl,cRel:cRel,rRel:rRel};
}

/* Ptg Tokens */

/* 2.5.198.27 */
function parse_PtgArea(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	var area = parse_RgceArea(blob, 8);
	return [type, area];
}

/* 2.5.198.28 */
function parse_PtgArea3d(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	var ixti = blob.read_shift(2);
	var area = parse_RgceArea(blob, 8);
	return [type, ixti, area];
}

/* 2.5.198.29 */
function parse_PtgAreaErr(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	blob.l += 8;
	return [type];
}
/* 2.5.198.30 */
function parse_PtgAreaErr3d(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	var ixti = blob.read_shift(2);
	blob.l += 8;
	return [type, ixti];
}

/* 2.5.198.31 */
function parse_PtgAreaN(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	var area = parse_RgceAreaRel(blob, 8);
	return [type, area];
}

/* 2.5.198.32 -- ignore this and look in PtgExtraArray for shape + values */
function parse_PtgArray(blob, length) {
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;
	blob.l += 7;
	return [type];
}

/* 2.5.198.33 */
function parse_PtgAttrBaxcel(blob, length) {
	var bitSemi = blob[blob.l+1] &amp; 0x01; /* 1 = volatile */
	var bitBaxcel = 1;
	blob.l += 4;
	return [bitSemi, bitBaxcel];
}

/* 2.5.198.34 */
function parse_PtgAttrChoose(blob, length) {
	blob.l +=2;
	var offset = blob.read_shift(2);
	var o = [];
	/* offset is 1 less than the number of elements */
	for(var i = 0; i &lt;= offset; ++i) o.push(blob.read_shift(2));
	return o;
}

/* 2.5.198.35 */
function parse_PtgAttrGoto(blob, length) {
	var bitGoto = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;
	blob.l += 2;
	return [bitGoto, blob.read_shift(2)];
}

/* 2.5.198.36 */
function parse_PtgAttrIf(blob, length) {
	var bitIf = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;
	blob.l += 2;
	return [bitIf, blob.read_shift(2)];
}

/* 2.5.198.37 */
function parse_PtgAttrSemi(blob, length) {
	var bitSemi = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;
	blob.l += 4;
	return [bitSemi];
}

/* 2.5.198.40 (used by PtgAttrSpace and PtgAttrSpaceSemi) */
function parse_PtgAttrSpaceType(blob, length) {
	var type = blob.read_shift(1), cch = blob.read_shift(1);
	return [type, cch];
}

/* 2.5.198.38 */
function parse_PtgAttrSpace(blob, length) {
	blob.read_shift(2);
	return parse_PtgAttrSpaceType(blob, 2);
}

/* 2.5.198.39 */
function parse_PtgAttrSpaceSemi(blob, length) {
	blob.read_shift(2);
	return parse_PtgAttrSpaceType(blob, 2);
}

/* 2.5.198.84 TODO */
function parse_PtgRef(blob, length) {
	var ptg = blob[blob.l] &amp; 0x1F;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;
	blob.l += 1;
	var loc = parse_RgceLoc(blob,4);
	return [type, loc];
}

/* 2.5.198.88 TODO */
function parse_PtgRefN(blob, length) {
	var ptg = blob[blob.l] &amp; 0x1F;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;
	blob.l += 1;
	var loc = parse_RgceLocRel(blob,4);
	return [type, loc];
}

/* 2.5.198.85 TODO */
function parse_PtgRef3d(blob, length) {
	var ptg = blob[blob.l] &amp; 0x1F;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;
	blob.l += 1;
	var ixti = blob.read_shift(2); // XtiIndex
	var loc = parse_RgceLoc(blob,4);
	return [type, ixti, loc];
}


/* 2.5.198.62 TODO */
function parse_PtgFunc(blob, length) {
	var ptg = blob[blob.l] &amp; 0x1F;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;
	blob.l += 1;
	var iftab = blob.read_shift(2);
	return [FtabArgc[iftab], Ftab[iftab]];
}
/* 2.5.198.63 TODO */
function parse_PtgFuncVar(blob, length) {
	blob.l++;
	var cparams = blob.read_shift(1), tab = parsetab(blob);
	return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}

function parsetab(blob, length) {
	return [blob[blob.l+1]&gt;&gt;7, blob.read_shift(2) &amp; 0x7FFF];
}

/* 2.5.198.41 */
var parse_PtgAttrSum = parseread(4);
/* 2.5.198.43 */
var parse_PtgConcat = parseread1;

/* 2.5.198.58 */
function parse_PtgExp(blob, length) {
	blob.l++;
	var row = blob.read_shift(2);
	var col = blob.read_shift(2);
	return [row, col];
}

/* 2.5.198.57 */
function parse_PtgErr(blob, length) { blob.l++; return BErr[blob.read_shift(1)]; }

/* 2.5.198.66 TODO */
function parse_PtgInt(blob, length) { blob.l++; return blob.read_shift(2); }

/* 2.5.198.42 */
function parse_PtgBool(blob, length) { blob.l++; return blob.read_shift(1)!==0;}

/* 2.5.198.79 */
function parse_PtgNum(blob, length) { blob.l++; return parse_Xnum(blob, 8); }

/* 2.5.198.89 */
function parse_PtgStr(blob, length) { blob.l++; return parse_ShortXLUnicodeString(blob); }

/* 2.5.192.112 + 2.5.192.11{3,4,5,6,7} */
function parse_SerAr(blob) {
	var val = [];
	switch((val[0] = blob.read_shift(1))) {
		/* 2.5.192.113 */
		case 0x04: /* SerBool -- boolean */
			val[1] = parsebool(blob, 1) ? &#x27;TRUE&#x27; : &#x27;FALSE&#x27;;
			blob.l += 7; break;
		/* 2.5.192.114 */
		case 0x10: /* SerErr -- error */
			val[1] = BErr[blob[blob.l]];
			blob.l += 8; break;
		/* 2.5.192.115 */
		case 0x00: /* SerNil -- honestly, I&#x27;m not sure how to reproduce this */
			blob.l += 8; break;
		/* 2.5.192.116 */
		case 0x01: /* SerNum -- Xnum */
			val[1] = parse_Xnum(blob, 8); break;
		/* 2.5.192.117 */
		case 0x02: /* SerStr -- XLUnicodeString (&lt;256 chars) */
			val[1] = parse_XLUnicodeString(blob); break;
		// default: throw &quot;Bad SerAr: &quot; + val[0]; /* Unreachable */
	}
	return val;
}

/* 2.5.198.61 */
function parse_PtgExtraMem(blob, cce) {
	var count = blob.read_shift(2);
	var out = [];
	for(var i = 0; i != count; ++i) out.push(parse_Ref8U(blob, 8));
	return out;
}

/* 2.5.198.59 */
function parse_PtgExtraArray(blob) {
	var cols = 1 + blob.read_shift(1); //DColByteU
	var rows = 1 + blob.read_shift(2); //DRw
	for(var i = 0, o=[]; i != rows &amp;&amp; (o[i] = []); ++i)
		for(var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob);
	return o;
}

/* 2.5.198.76 */
function parse_PtgName(blob, length) {
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;
	var nameindex = blob.read_shift(4);
	return [type, 0, nameindex];
}

/* 2.5.198.77 */
function parse_PtgNameX(blob, length) {
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;
	var ixti = blob.read_shift(2); // XtiIndex
	var nameindex = blob.read_shift(4);
	return [type, ixti, nameindex];
}

/* 2.5.198.70 */
function parse_PtgMemArea(blob, length) {
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;
	blob.l += 4;
	var cce = blob.read_shift(2);
	return [type, cce];
}

/* 2.5.198.72 */
function parse_PtgMemFunc(blob, length) {
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;
	var cce = blob.read_shift(2);
	return [type, cce];
}


/* 2.5.198.86 */
function parse_PtgRefErr(blob, length) {
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;
	blob.l += 4;
	return [type];
}

/* 2.5.198.26 */
var parse_PtgAdd = parseread1;
/* 2.5.198.45 */
var parse_PtgDiv = parseread1;
/* 2.5.198.56 */
var parse_PtgEq = parseread1;
/* 2.5.198.64 */
var parse_PtgGe = parseread1;
/* 2.5.198.65 */
var parse_PtgGt = parseread1;
/* 2.5.198.67 */
var parse_PtgIsect = parseread1;
/* 2.5.198.68 */
var parse_PtgLe = parseread1;
/* 2.5.198.69 */
var parse_PtgLt = parseread1;
/* 2.5.198.74 */
var parse_PtgMissArg = parseread1;
/* 2.5.198.75 */
var parse_PtgMul = parseread1;
/* 2.5.198.78 */
var parse_PtgNe = parseread1;
/* 2.5.198.80 */
var parse_PtgParen = parseread1;
/* 2.5.198.81 */
var parse_PtgPercent = parseread1;
/* 2.5.198.82 */
var parse_PtgPower = parseread1;
/* 2.5.198.83 */
var parse_PtgRange = parseread1;
/* 2.5.198.90 */
var parse_PtgSub = parseread1;
/* 2.5.198.93 */
var parse_PtgUminus = parseread1;
/* 2.5.198.94 */
var parse_PtgUnion = parseread1;
/* 2.5.198.95 */
var parse_PtgUplus = parseread1;

/* 2.5.198.71 */
var parse_PtgMemErr = parsenoop;
/* 2.5.198.73 */
var parse_PtgMemNoMem = parsenoop;
/* 2.5.198.87 */
var parse_PtgRefErr3d = parsenoop;
/* 2.5.198.92 */
var parse_PtgTbl = parsenoop;

/* 2.5.198.25 */
var PtgTypes = {
	0x01: { n:&#x27;PtgExp&#x27;, f:parse_PtgExp },
	0x02: { n:&#x27;PtgTbl&#x27;, f:parse_PtgTbl },
	0x03: { n:&#x27;PtgAdd&#x27;, f:parse_PtgAdd },
	0x04: { n:&#x27;PtgSub&#x27;, f:parse_PtgSub },
	0x05: { n:&#x27;PtgMul&#x27;, f:parse_PtgMul },
	0x06: { n:&#x27;PtgDiv&#x27;, f:parse_PtgDiv },
	0x07: { n:&#x27;PtgPower&#x27;, f:parse_PtgPower },
	0x08: { n:&#x27;PtgConcat&#x27;, f:parse_PtgConcat },
	0x09: { n:&#x27;PtgLt&#x27;, f:parse_PtgLt },
	0x0A: { n:&#x27;PtgLe&#x27;, f:parse_PtgLe },
	0x0B: { n:&#x27;PtgEq&#x27;, f:parse_PtgEq },
	0x0C: { n:&#x27;PtgGe&#x27;, f:parse_PtgGe },
	0x0D: { n:&#x27;PtgGt&#x27;, f:parse_PtgGt },
	0x0E: { n:&#x27;PtgNe&#x27;, f:parse_PtgNe },
	0x0F: { n:&#x27;PtgIsect&#x27;, f:parse_PtgIsect },
	0x10: { n:&#x27;PtgUnion&#x27;, f:parse_PtgUnion },
	0x11: { n:&#x27;PtgRange&#x27;, f:parse_PtgRange },
	0x12: { n:&#x27;PtgUplus&#x27;, f:parse_PtgUplus },
	0x13: { n:&#x27;PtgUminus&#x27;, f:parse_PtgUminus },
	0x14: { n:&#x27;PtgPercent&#x27;, f:parse_PtgPercent },
	0x15: { n:&#x27;PtgParen&#x27;, f:parse_PtgParen },
	0x16: { n:&#x27;PtgMissArg&#x27;, f:parse_PtgMissArg },
	0x17: { n:&#x27;PtgStr&#x27;, f:parse_PtgStr },
	0x1C: { n:&#x27;PtgErr&#x27;, f:parse_PtgErr },
	0x1D: { n:&#x27;PtgBool&#x27;, f:parse_PtgBool },
	0x1E: { n:&#x27;PtgInt&#x27;, f:parse_PtgInt },
	0x1F: { n:&#x27;PtgNum&#x27;, f:parse_PtgNum },
	0x20: { n:&#x27;PtgArray&#x27;, f:parse_PtgArray },
	0x21: { n:&#x27;PtgFunc&#x27;, f:parse_PtgFunc },
	0x22: { n:&#x27;PtgFuncVar&#x27;, f:parse_PtgFuncVar },
	0x23: { n:&#x27;PtgName&#x27;, f:parse_PtgName },
	0x24: { n:&#x27;PtgRef&#x27;, f:parse_PtgRef },
	0x25: { n:&#x27;PtgArea&#x27;, f:parse_PtgArea },
	0x26: { n:&#x27;PtgMemArea&#x27;, f:parse_PtgMemArea },
	0x27: { n:&#x27;PtgMemErr&#x27;, f:parse_PtgMemErr },
	0x28: { n:&#x27;PtgMemNoMem&#x27;, f:parse_PtgMemNoMem },
	0x29: { n:&#x27;PtgMemFunc&#x27;, f:parse_PtgMemFunc },
	0x2A: { n:&#x27;PtgRefErr&#x27;, f:parse_PtgRefErr },
	0x2B: { n:&#x27;PtgAreaErr&#x27;, f:parse_PtgAreaErr },
	0x2C: { n:&#x27;PtgRefN&#x27;, f:parse_PtgRefN },
	0x2D: { n:&#x27;PtgAreaN&#x27;, f:parse_PtgAreaN },
	0x39: { n:&#x27;PtgNameX&#x27;, f:parse_PtgNameX },
	0x3A: { n:&#x27;PtgRef3d&#x27;, f:parse_PtgRef3d },
	0x3B: { n:&#x27;PtgArea3d&#x27;, f:parse_PtgArea3d },
	0x3C: { n:&#x27;PtgRefErr3d&#x27;, f:parse_PtgRefErr3d },
	0x3D: { n:&#x27;PtgAreaErr3d&#x27;, f:parse_PtgAreaErr3d },
	0xFF: {}
};
/* These are duplicated in the PtgTypes table */
var PtgDupes = {
	0x40: 0x20, 0x60: 0x20,
	0x41: 0x21, 0x61: 0x21,
	0x42: 0x22, 0x62: 0x22,
	0x43: 0x23, 0x63: 0x23,
	0x44: 0x24, 0x64: 0x24,
	0x45: 0x25, 0x65: 0x25,
	0x46: 0x26, 0x66: 0x26,
	0x47: 0x27, 0x67: 0x27,
	0x48: 0x28, 0x68: 0x28,
	0x49: 0x29, 0x69: 0x29,
	0x4A: 0x2A, 0x6A: 0x2A,
	0x4B: 0x2B, 0x6B: 0x2B,
	0x4C: 0x2C, 0x6C: 0x2C,
	0x4D: 0x2D, 0x6D: 0x2D,
	0x59: 0x39, 0x79: 0x39,
	0x5A: 0x3A, 0x7A: 0x3A,
	0x5B: 0x3B, 0x7B: 0x3B,
	0x5C: 0x3C, 0x7C: 0x3C,
	0x5D: 0x3D, 0x7D: 0x3D
};
(function(){for(var y in PtgDupes) PtgTypes[y] = PtgTypes[PtgDupes[y]];})();

var Ptg18 = {};
var Ptg19 = {
	0x01: { n:&#x27;PtgAttrSemi&#x27;, f:parse_PtgAttrSemi },
	0x02: { n:&#x27;PtgAttrIf&#x27;, f:parse_PtgAttrIf },
	0x04: { n:&#x27;PtgAttrChoose&#x27;, f:parse_PtgAttrChoose },
	0x08: { n:&#x27;PtgAttrGoto&#x27;, f:parse_PtgAttrGoto },
	0x10: { n:&#x27;PtgAttrSum&#x27;, f:parse_PtgAttrSum },
	0x20: { n:&#x27;PtgAttrBaxcel&#x27;, f:parse_PtgAttrBaxcel },
	0x40: { n:&#x27;PtgAttrSpace&#x27;, f:parse_PtgAttrSpace },
	0x41: { n:&#x27;PtgAttrSpaceSemi&#x27;, f:parse_PtgAttrSpaceSemi },
	0xFF: {}
};

/* 2.4.127 TODO */
function parse_Formula(blob, length, opts) {
	var cell = parse_XLSCell(blob, 6);
	var val = parse_FormulaValue(blob,8);
	var flags = blob.read_shift(1);
	blob.read_shift(1);
	var chn = blob.read_shift(4);
	var cbf = &quot;&quot;;
	if(opts.biff === 5) blob.l += length-20;
	else cbf = parse_XLSCellParsedFormula(blob, length-20, opts);
	return {cell:cell, val:val[0], formula:cbf, shared: (flags &gt;&gt; 3) &amp; 1, tt:val[1]};
}

/* 2.5.133 TODO: how to emit empty strings? */
function parse_FormulaValue(blob) {
	var b;
	if(__readUInt16LE(blob,blob.l + 6) !== 0xFFFF) return [parse_Xnum(blob),&#x27;n&#x27;];
	switch(blob[blob.l]) {
		case 0x00: blob.l += 8; return [&quot;String&quot;, &#x27;s&#x27;];
		case 0x01: b = blob[blob.l+2] === 0x1; blob.l += 8; return [b,&#x27;b&#x27;];
		case 0x02: b = blob[blob.l+2]; blob.l += 8; return [b,&#x27;e&#x27;];
		case 0x03: blob.l += 8; return [&quot;&quot;,&#x27;s&#x27;];
	}
}

/* 2.5.198.103 */
function parse_RgbExtra(blob, length, rgce, opts) {
	if(opts.biff &lt; 8) return parsenoop(blob, length);
	var target = blob.l + length;
	var o = [];
	for(var i = 0; i !== rgce.length; ++i) {
		switch(rgce[i][0]) {
			case &#x27;PtgArray&#x27;: /* PtgArray -&gt; PtgExtraArray */
				rgce[i][1] = parse_PtgExtraArray(blob);
				o.push(rgce[i][1]);
				break;
			case &#x27;PtgMemArea&#x27;: /* PtgMemArea -&gt; PtgExtraMem */
				rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1]);
				o.push(rgce[i][2]);
				break;
			default: break;
		}
	}
	length = target - blob.l;
	if(length !== 0) o.push(parsenoop(blob, length));
	return o;
}

/* 2.5.198.21 */
function parse_NameParsedFormula(blob, length, opts, cce) {
	var target = blob.l + length;
	var rgce = parse_Rgce(blob, cce);
	var rgcb;
	if(target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
	return [rgce, rgcb];
}

/* 2.5.198.3 TODO */
function parse_XLSCellParsedFormula(blob, length, opts) {
	var target = blob.l + length;
	var rgcb, cce = blob.read_shift(2); // length of rgce
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];
	var rgce = parse_Rgce(blob, cce);
	if(length !== cce + 2) rgcb = parse_RgbExtra(blob, length - cce - 2, rgce, opts);
	return [rgce, rgcb];
}

/* 2.5.198.118 TODO */
function parse_SharedParsedFormula(blob, length, opts) {
	var target = blob.l + length;
	var rgcb, cce = blob.read_shift(2); // length of rgce
	var rgce = parse_Rgce(blob, cce);
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];
	if(length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
	return [rgce, rgcb];
}

/* 2.5.198.1 TODO */
function parse_ArrayParsedFormula(blob, length, opts, ref) {
	var target = blob.l + length;
	var rgcb, cce = blob.read_shift(2); // length of rgce
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];
	var rgce = parse_Rgce(blob, cce);
	if(length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
	return [rgce, rgcb];
}

/* 2.5.198.104 */
function parse_Rgce(blob, length) {
	var target = blob.l + length;
	var R, id, ptgs = [];
	while(target != blob.l) {
		length = target - blob.l;
		id = blob[blob.l];
		R = PtgTypes[id];
		//console.log(&quot;ptg&quot;, id, R)
		if(id === 0x18 || id === 0x19) {
			id = blob[blob.l + 1];
			R = (id === 0x18 ? Ptg18 : Ptg19)[id];
		}
		if(!R || !R.f) { ptgs.push(parsenoop(blob, length)); }
		else { ptgs.push([R.n, R.f(blob, length)]); }
	}
	return ptgs;
}

function mapper(x) { return x.map(function f2(y) { return y[1];}).join(&quot;,&quot;);}

/* 2.2.2 + Magic TODO */
function stringify_formula(formula, range, cell, supbooks, opts) {
	if(opts !== undefined &amp;&amp; opts.biff === 5) return &quot;BIFF5??&quot;;
	var _range = range !== undefined ? range : {s:{c:0, r:0}};
	var stack = [], e1, e2, type, c, ixti, nameidx, r;
	if(!formula[0] || !formula[0][0]) return &quot;&quot;;
	//console.log(&quot;--&quot;,cell,formula[0])
	for(var ff = 0, fflen = formula[0].length; ff &lt; fflen; ++ff) {
		var f = formula[0][ff];
		//console.log(&quot;++&quot;,f, stack)
		switch(f[0]) {
		/* 2.2.2.1 Unary Operator Tokens */
			/* 2.5.198.93 */
			case &#x27;PtgUminus&#x27;: stack.push(&quot;-&quot; + stack.pop()); break;
			/* 2.5.198.95 */
			case &#x27;PtgUplus&#x27;: stack.push(&quot;+&quot; + stack.pop()); break;
			/* 2.5.198.81 */
			case &#x27;PtgPercent&#x27;: stack.push(stack.pop() + &quot;%&quot;); break;

		/* 2.2.2.1 Binary Value Operator Token */
			/* 2.5.198.26 */
			case &#x27;PtgAdd&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;+&quot;+e1);
				break;
			/* 2.5.198.90 */
			case &#x27;PtgSub&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;-&quot;+e1);
				break;
			/* 2.5.198.75 */
			case &#x27;PtgMul&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;*&quot;+e1);
				break;
			/* 2.5.198.45 */
			case &#x27;PtgDiv&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;/&quot;+e1);
				break;
			/* 2.5.198.82 */
			case &#x27;PtgPower&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;^&quot;+e1);
				break;
			/* 2.5.198.43 */
			case &#x27;PtgConcat&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&amp;&quot;+e1);
				break;
			/* 2.5.198.69 */
			case &#x27;PtgLt&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&lt;&quot;+e1);
				break;
			/* 2.5.198.68 */
			case &#x27;PtgLe&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&lt;=&quot;+e1);
				break;
			/* 2.5.198.56 */
			case &#x27;PtgEq&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;=&quot;+e1);
				break;
			/* 2.5.198.64 */
			case &#x27;PtgGe&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&gt;=&quot;+e1);
				break;
			/* 2.5.198.65 */
			case &#x27;PtgGt&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&gt;&quot;+e1);
				break;
			/* 2.5.198.78 */
			case &#x27;PtgNe&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;&lt;&gt;&quot;+e1);
				break;

		/* 2.2.2.1 Binary Reference Operator Token */
			/* 2.5.198.67 */
			case &#x27;PtgIsect&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot; &quot;+e1);
				break;
			case &#x27;PtgUnion&#x27;:
				e1 = stack.pop(); e2 = stack.pop();
				stack.push(e2+&quot;,&quot;+e1);
				break;
			case &#x27;PtgRange&#x27;: break;

		/* 2.2.2.3 Control Tokens &quot;can be ignored&quot; */
			/* 2.5.198.34 */
			case &#x27;PtgAttrChoose&#x27;: break;
			/* 2.5.198.35 */
			case &#x27;PtgAttrGoto&#x27;: break;
			/* 2.5.198.36 */
			case &#x27;PtgAttrIf&#x27;: break;


			/* 2.5.198.84 */
			case &#x27;PtgRef&#x27;:
				type = f[1][0]; c = shift_cell_xls(decode_cell(encode_cell(f[1][1])), _range);
				stack.push(encode_cell(c));
				break;
			/* 2.5.198.88 */
			case &#x27;PtgRefN&#x27;:
				type = f[1][0]; c = shift_cell_xls(decode_cell(encode_cell(f[1][1])), cell);
				stack.push(encode_cell(c));
				break;
			case &#x27;PtgRef3d&#x27;: // TODO: lots of stuff
				type = f[1][0]; ixti = f[1][1]; c = shift_cell_xls(f[1][2], _range);
				stack.push(supbooks[1][ixti+1]+&quot;!&quot;+encode_cell(c));
				break;

		/* Function Call */
			/* 2.5.198.62 */
			case &#x27;PtgFunc&#x27;:
			/* 2.5.198.63 */
			case &#x27;PtgFuncVar&#x27;:
				/* f[1] = [argc, func] */
				var argc = f[1][0], func = f[1][1];
				if(!argc) argc = 0;
				var args = stack.slice(-argc);
				stack.length -= argc;
				if(func === &#x27;User&#x27;) func = args.shift();
				stack.push(func + &quot;(&quot; + args.join(&quot;,&quot;) + &quot;)&quot;);
				break;

			/* 2.5.198.42 */
			case &#x27;PtgBool&#x27;: stack.push(f[1] ? &quot;TRUE&quot; : &quot;FALSE&quot;); break;
			/* 2.5.198.66 */
			case &#x27;PtgInt&#x27;: stack.push(f[1]); break;
			/* 2.5.198.79 TODO: precision? */
			case &#x27;PtgNum&#x27;: stack.push(String(f[1])); break;
			/* 2.5.198.89 */
			case &#x27;PtgStr&#x27;: stack.push(&#x27;&quot;&#x27; + f[1] + &#x27;&quot;&#x27;); break;
			/* 2.5.198.57 */
			case &#x27;PtgErr&#x27;: stack.push(f[1]); break;
			/* 2.5.198.27 TODO: fixed points */
			case &#x27;PtgArea&#x27;:
				type = f[1][0]; r = shift_range_xls(f[1][1], _range);
				stack.push(encode_range(r));
				break;
			/* 2.5.198.28 */
			case &#x27;PtgArea3d&#x27;: // TODO: lots of stuff
				type = f[1][0]; ixti = f[1][1]; r = f[1][2];
				stack.push(supbooks[1][ixti+1]+&quot;!&quot;+encode_range(r));
				break;
			/* 2.5.198.41 */
			case &#x27;PtgAttrSum&#x27;:
				stack.push(&quot;SUM(&quot; + stack.pop() + &quot;)&quot;);
				break;

		/* Expression Prefixes */
			/* 2.5.198.37 */
			case &#x27;PtgAttrSemi&#x27;: break;

			/* 2.5.97.60 TODO: do something different for revisions */
			case &#x27;PtgName&#x27;:
				/* f[1] = type, 0, nameindex */
				nameidx = f[1][2];
				var lbl = supbooks[0][nameidx];
				var name = lbl.Name;
				if(name in XLSXFutureFunctions) name = XLSXFutureFunctions[name];
				stack.push(name);
				break;

			/* 2.5.97.61 TODO: do something different for revisions */
			case &#x27;PtgNameX&#x27;:
				/* f[1] = type, ixti, nameindex */
				var bookidx = f[1][1]; nameidx = f[1][2]; var externbook;
				/* TODO: Properly handle missing values */
				if(supbooks[bookidx+1]) externbook = supbooks[bookidx+1][nameidx];
				else if(supbooks[bookidx-1]) externbook = supbooks[bookidx-1][nameidx];
				if(!externbook) externbook = {body: &quot;??NAMEX??&quot;};
				stack.push(externbook.body);
				break;

		/* 2.2.2.4 Display Tokens */
			/* 2.5.198.80 */
			case &#x27;PtgParen&#x27;: stack.push(&#x27;(&#x27; + stack.pop() + &#x27;)&#x27;); break;

			/* 2.5.198.86 */
			case &#x27;PtgRefErr&#x27;: stack.push(&#x27;#REF!&#x27;); break;

		/* */
			/* 2.5.198.58 TODO */
			case &#x27;PtgExp&#x27;:
				c = {c:f[1][1],r:f[1][0]};
				var q = {c: cell.c, r:cell.r};
				if(supbooks.sharedf[encode_cell(c)]) {
					var parsedf = (supbooks.sharedf[encode_cell(c)]);
					stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
				}
				else {
					var fnd = false;
					for(e1=0;e1!=supbooks.arrayf.length; ++e1) {
						/* TODO: should be something like range_has */
						e2 = supbooks.arrayf[e1];
						if(c.c &lt; e2[0].s.c || c.c &gt; e2[0].e.c) continue;
						if(c.r &lt; e2[0].s.r || c.r &gt; e2[0].e.r) continue;
						stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
					}
					if(!fnd) stack.push(f[1]);
				}
				break;

			/* 2.5.198.32 TODO */
			case &#x27;PtgArray&#x27;:
				stack.push(&quot;{&quot; + f[1].map(mapper).join(&quot;;&quot;) + &quot;}&quot;);
				break;

		/* 2.2.2.5 Mem Tokens */
			/* 2.5.198.70 TODO: confirm this is a non-display */
			case &#x27;PtgMemArea&#x27;:
				//stack.push(&quot;(&quot; + f[2].map(encode_range).join(&quot;,&quot;) + &quot;)&quot;);
				break;

			/* 2.5.198.38 TODO */
			case &#x27;PtgAttrSpace&#x27;: break;

			/* 2.5.198.92 TODO */
			case &#x27;PtgTbl&#x27;: break;

			/* 2.5.198.71 */
			case &#x27;PtgMemErr&#x27;: break;

			/* 2.5.198.74 */
			case &#x27;PtgMissArg&#x27;:
				stack.push(&quot;&quot;);
				break;

			/* 2.5.198.29 TODO */
			case &#x27;PtgAreaErr&#x27;: break;

			/* 2.5.198.31 TODO */
			case &#x27;PtgAreaN&#x27;: stack.push(&quot;&quot;); break;

			/* 2.5.198.87 TODO */
			case &#x27;PtgRefErr3d&#x27;: break;

			/* 2.5.198.72 TODO */
			case &#x27;PtgMemFunc&#x27;: break;

			default: throw &#x27;Unrecognized Formula Token: &#x27; + f;
		}
		//console.log(&quot;::&quot;,f, stack)
	}
	//console.log(&quot;--&quot;,stack);
	return stack[0];
}

/* [MS-XLSB] 2.5.97.4 CellParsedFormula TODO: use similar logic to js-xls */
function parse_XLSBCellParsedFormula(data, length) {
	var cce = data.read_shift(4);
	return parsenoop(data, length-4);
}
/* [MS-XLS] 2.5.198.44 */
var PtgDataType = {
	0x1: &quot;REFERENCE&quot;, // reference to range
	0x2: &quot;VALUE&quot;, // single value
	0x3: &quot;ARRAY&quot; // array of values
};

/* [MS-XLS] 2.5.198.4 */
var Cetab = {
	0x0000: &#x27;BEEP&#x27;,
	0x0001: &#x27;OPEN&#x27;,
	0x0002: &#x27;OPEN.LINKS&#x27;,
	0x0003: &#x27;CLOSE.ALL&#x27;,
	0x0004: &#x27;SAVE&#x27;,
	0x0005: &#x27;SAVE.AS&#x27;,
	0x0006: &#x27;FILE.DELETE&#x27;,
	0x0007: &#x27;PAGE.SETUP&#x27;,
	0x0008: &#x27;PRINT&#x27;,
	0x0009: &#x27;PRINTER.SETUP&#x27;,
	0x000A: &#x27;QUIT&#x27;,
	0x000B: &#x27;NEW.WINDOW&#x27;,
	0x000C: &#x27;ARRANGE.ALL&#x27;,
	0x000D: &#x27;WINDOW.SIZE&#x27;,
	0x000E: &#x27;WINDOW.MOVE&#x27;,
	0x000F: &#x27;FULL&#x27;,
	0x0010: &#x27;CLOSE&#x27;,
	0x0011: &#x27;RUN&#x27;,
	0x0016: &#x27;SET.PRINT.AREA&#x27;,
	0x0017: &#x27;SET.PRINT.TITLES&#x27;,
	0x0018: &#x27;SET.PAGE.BREAK&#x27;,
	0x0019: &#x27;REMOVE.PAGE.BREAK&#x27;,
	0x001A: &#x27;FONT&#x27;,
	0x001B: &#x27;DISPLAY&#x27;,
	0x001C: &#x27;PROTECT.DOCUMENT&#x27;,
	0x001D: &#x27;PRECISION&#x27;,
	0x001E: &#x27;A1.R1C1&#x27;,
	0x001F: &#x27;CALCULATE.NOW&#x27;,
	0x0020: &#x27;CALCULATION&#x27;,
	0x0022: &#x27;DATA.FIND&#x27;,
	0x0023: &#x27;EXTRACT&#x27;,
	0x0024: &#x27;DATA.DELETE&#x27;,
	0x0025: &#x27;SET.DATABASE&#x27;,
	0x0026: &#x27;SET.CRITERIA&#x27;,
	0x0027: &#x27;SORT&#x27;,
	0x0028: &#x27;DATA.SERIES&#x27;,
	0x0029: &#x27;TABLE&#x27;,
	0x002A: &#x27;FORMAT.NUMBER&#x27;,
	0x002B: &#x27;ALIGNMENT&#x27;,
	0x002C: &#x27;STYLE&#x27;,
	0x002D: &#x27;BORDER&#x27;,
	0x002E: &#x27;CELL.PROTECTION&#x27;,
	0x002F: &#x27;COLUMN.WIDTH&#x27;,
	0x0030: &#x27;UNDO&#x27;,
	0x0031: &#x27;CUT&#x27;,
	0x0032: &#x27;COPY&#x27;,
	0x0033: &#x27;PASTE&#x27;,
	0x0034: &#x27;CLEAR&#x27;,
	0x0035: &#x27;PASTE.SPECIAL&#x27;,
	0x0036: &#x27;EDIT.DELETE&#x27;,
	0x0037: &#x27;INSERT&#x27;,
	0x0038: &#x27;FILL.RIGHT&#x27;,
	0x0039: &#x27;FILL.DOWN&#x27;,
	0x003D: &#x27;DEFINE.NAME&#x27;,
	0x003E: &#x27;CREATE.NAMES&#x27;,
	0x003F: &#x27;FORMULA.GOTO&#x27;,
	0x0040: &#x27;FORMULA.FIND&#x27;,
	0x0041: &#x27;SELECT.LAST.CELL&#x27;,
	0x0042: &#x27;SHOW.ACTIVE.CELL&#x27;,
	0x0043: &#x27;GALLERY.AREA&#x27;,
	0x0044: &#x27;GALLERY.BAR&#x27;,
	0x0045: &#x27;GALLERY.COLUMN&#x27;,
	0x0046: &#x27;GALLERY.LINE&#x27;,
	0x0047: &#x27;GALLERY.PIE&#x27;,
	0x0048: &#x27;GALLERY.SCATTER&#x27;,
	0x0049: &#x27;COMBINATION&#x27;,
	0x004A: &#x27;PREFERRED&#x27;,
	0x004B: &#x27;ADD.OVERLAY&#x27;,
	0x004C: &#x27;GRIDLINES&#x27;,
	0x004D: &#x27;SET.PREFERRED&#x27;,
	0x004E: &#x27;AXES&#x27;,
	0x004F: &#x27;LEGEND&#x27;,
	0x0050: &#x27;ATTACH.TEXT&#x27;,
	0x0051: &#x27;ADD.ARROW&#x27;,
	0x0052: &#x27;SELECT.CHART&#x27;,
	0x0053: &#x27;SELECT.PLOT.AREA&#x27;,
	0x0054: &#x27;PATTERNS&#x27;,
	0x0055: &#x27;MAIN.CHART&#x27;,
	0x0056: &#x27;OVERLAY&#x27;,
	0x0057: &#x27;SCALE&#x27;,
	0x0058: &#x27;FORMAT.LEGEND&#x27;,
	0x0059: &#x27;FORMAT.TEXT&#x27;,
	0x005A: &#x27;EDIT.REPEAT&#x27;,
	0x005B: &#x27;PARSE&#x27;,
	0x005C: &#x27;JUSTIFY&#x27;,
	0x005D: &#x27;HIDE&#x27;,
	0x005E: &#x27;UNHIDE&#x27;,
	0x005F: &#x27;WORKSPACE&#x27;,
	0x0060: &#x27;FORMULA&#x27;,
	0x0061: &#x27;FORMULA.FILL&#x27;,
	0x0062: &#x27;FORMULA.ARRAY&#x27;,
	0x0063: &#x27;DATA.FIND.NEXT&#x27;,
	0x0064: &#x27;DATA.FIND.PREV&#x27;,
	0x0065: &#x27;FORMULA.FIND.NEXT&#x27;,
	0x0066: &#x27;FORMULA.FIND.PREV&#x27;,
	0x0067: &#x27;ACTIVATE&#x27;,
	0x0068: &#x27;ACTIVATE.NEXT&#x27;,
	0x0069: &#x27;ACTIVATE.PREV&#x27;,
	0x006A: &#x27;UNLOCKED.NEXT&#x27;,
	0x006B: &#x27;UNLOCKED.PREV&#x27;,
	0x006C: &#x27;COPY.PICTURE&#x27;,
	0x006D: &#x27;SELECT&#x27;,
	0x006E: &#x27;DELETE.NAME&#x27;,
	0x006F: &#x27;DELETE.FORMAT&#x27;,
	0x0070: &#x27;VLINE&#x27;,
	0x0071: &#x27;HLINE&#x27;,
	0x0072: &#x27;VPAGE&#x27;,
	0x0073: &#x27;HPAGE&#x27;,
	0x0074: &#x27;VSCROLL&#x27;,
	0x0075: &#x27;HSCROLL&#x27;,
	0x0076: &#x27;ALERT&#x27;,
	0x0077: &#x27;NEW&#x27;,
	0x0078: &#x27;CANCEL.COPY&#x27;,
	0x0079: &#x27;SHOW.CLIPBOARD&#x27;,
	0x007A: &#x27;MESSAGE&#x27;,
	0x007C: &#x27;PASTE.LINK&#x27;,
	0x007D: &#x27;APP.ACTIVATE&#x27;,
	0x007E: &#x27;DELETE.ARROW&#x27;,
	0x007F: &#x27;ROW.HEIGHT&#x27;,
	0x0080: &#x27;FORMAT.MOVE&#x27;,
	0x0081: &#x27;FORMAT.SIZE&#x27;,
	0x0082: &#x27;FORMULA.REPLACE&#x27;,
	0x0083: &#x27;SEND.KEYS&#x27;,
	0x0084: &#x27;SELECT.SPECIAL&#x27;,
	0x0085: &#x27;APPLY.NAMES&#x27;,
	0x0086: &#x27;REPLACE.FONT&#x27;,
	0x0087: &#x27;FREEZE.PANES&#x27;,
	0x0088: &#x27;SHOW.INFO&#x27;,
	0x0089: &#x27;SPLIT&#x27;,
	0x008A: &#x27;ON.WINDOW&#x27;,
	0x008B: &#x27;ON.DATA&#x27;,
	0x008C: &#x27;DISABLE.INPUT&#x27;,
	0x008E: &#x27;OUTLINE&#x27;,
	0x008F: &#x27;LIST.NAMES&#x27;,
	0x0090: &#x27;FILE.CLOSE&#x27;,
	0x0091: &#x27;SAVE.WORKBOOK&#x27;,
	0x0092: &#x27;DATA.FORM&#x27;,
	0x0093: &#x27;COPY.CHART&#x27;,
	0x0094: &#x27;ON.TIME&#x27;,
	0x0095: &#x27;WAIT&#x27;,
	0x0096: &#x27;FORMAT.FONT&#x27;,
	0x0097: &#x27;FILL.UP&#x27;,
	0x0098: &#x27;FILL.LEFT&#x27;,
	0x0099: &#x27;DELETE.OVERLAY&#x27;,
	0x009B: &#x27;SHORT.MENUS&#x27;,
	0x009F: &#x27;SET.UPDATE.STATUS&#x27;,
	0x00A1: &#x27;COLOR.PALETTE&#x27;,
	0x00A2: &#x27;DELETE.STYLE&#x27;,
	0x00A3: &#x27;WINDOW.RESTORE&#x27;,
	0x00A4: &#x27;WINDOW.MAXIMIZE&#x27;,
	0x00A6: &#x27;CHANGE.LINK&#x27;,
	0x00A7: &#x27;CALCULATE.DOCUMENT&#x27;,
	0x00A8: &#x27;ON.KEY&#x27;,
	0x00A9: &#x27;APP.RESTORE&#x27;,
	0x00AA: &#x27;APP.MOVE&#x27;,
	0x00AB: &#x27;APP.SIZE&#x27;,
	0x00AC: &#x27;APP.MINIMIZE&#x27;,
	0x00AD: &#x27;APP.MAXIMIZE&#x27;,
	0x00AE: &#x27;BRING.TO.FRONT&#x27;,
	0x00AF: &#x27;SEND.TO.BACK&#x27;,
	0x00B9: &#x27;MAIN.CHART.TYPE&#x27;,
	0x00BA: &#x27;OVERLAY.CHART.TYPE&#x27;,
	0x00BB: &#x27;SELECT.END&#x27;,
	0x00BC: &#x27;OPEN.MAIL&#x27;,
	0x00BD: &#x27;SEND.MAIL&#x27;,
	0x00BE: &#x27;STANDARD.FONT&#x27;,
	0x00BF: &#x27;CONSOLIDATE&#x27;,
	0x00C0: &#x27;SORT.SPECIAL&#x27;,
	0x00C1: &#x27;GALLERY.3D.AREA&#x27;,
	0x00C2: &#x27;GALLERY.3D.COLUMN&#x27;,
	0x00C3: &#x27;GALLERY.3D.LINE&#x27;,
	0x00C4: &#x27;GALLERY.3D.PIE&#x27;,
	0x00C5: &#x27;VIEW.3D&#x27;,
	0x00C6: &#x27;GOAL.SEEK&#x27;,
	0x00C7: &#x27;WORKGROUP&#x27;,
	0x00C8: &#x27;FILL.GROUP&#x27;,
	0x00C9: &#x27;UPDATE.LINK&#x27;,
	0x00CA: &#x27;PROMOTE&#x27;,
	0x00CB: &#x27;DEMOTE&#x27;,
	0x00CC: &#x27;SHOW.DETAIL&#x27;,
	0x00CE: &#x27;UNGROUP&#x27;,
	0x00CF: &#x27;OBJECT.PROPERTIES&#x27;,
	0x00D0: &#x27;SAVE.NEW.OBJECT&#x27;,
	0x00D1: &#x27;SHARE&#x27;,
	0x00D2: &#x27;SHARE.NAME&#x27;,
	0x00D3: &#x27;DUPLICATE&#x27;,
	0x00D4: &#x27;APPLY.STYLE&#x27;,
	0x00D5: &#x27;ASSIGN.TO.OBJECT&#x27;,
	0x00D6: &#x27;OBJECT.PROTECTION&#x27;,
	0x00D7: &#x27;HIDE.OBJECT&#x27;,
	0x00D8: &#x27;SET.EXTRACT&#x27;,
	0x00D9: &#x27;CREATE.PUBLISHER&#x27;,
	0x00DA: &#x27;SUBSCRIBE.TO&#x27;,
	0x00DB: &#x27;ATTRIBUTES&#x27;,
	0x00DC: &#x27;SHOW.TOOLBAR&#x27;,
	0x00DE: &#x27;PRINT.PREVIEW&#x27;,
	0x00DF: &#x27;EDIT.COLOR&#x27;,
	0x00E0: &#x27;SHOW.LEVELS&#x27;,
	0x00E1: &#x27;FORMAT.MAIN&#x27;,
	0x00E2: &#x27;FORMAT.OVERLAY&#x27;,
	0x00E3: &#x27;ON.RECALC&#x27;,
	0x00E4: &#x27;EDIT.SERIES&#x27;,
	0x00E5: &#x27;DEFINE.STYLE&#x27;,
	0x00F0: &#x27;LINE.PRINT&#x27;,
	0x00F3: &#x27;ENTER.DATA&#x27;,
	0x00F9: &#x27;GALLERY.RADAR&#x27;,
	0x00FA: &#x27;MERGE.STYLES&#x27;,
	0x00FB: &#x27;EDITION.OPTIONS&#x27;,
	0x00FC: &#x27;PASTE.PICTURE&#x27;,
	0x00FD: &#x27;PASTE.PICTURE.LINK&#x27;,
	0x00FE: &#x27;SPELLING&#x27;,
	0x0100: &#x27;ZOOM&#x27;,
	0x0103: &#x27;INSERT.OBJECT&#x27;,
	0x0104: &#x27;WINDOW.MINIMIZE&#x27;,
	0x0109: &#x27;SOUND.NOTE&#x27;,
	0x010A: &#x27;SOUND.PLAY&#x27;,
	0x010B: &#x27;FORMAT.SHAPE&#x27;,
	0x010C: &#x27;EXTEND.POLYGON&#x27;,
	0x010D: &#x27;FORMAT.AUTO&#x27;,
	0x0110: &#x27;GALLERY.3D.BAR&#x27;,
	0x0111: &#x27;GALLERY.3D.SURFACE&#x27;,
	0x0112: &#x27;FILL.AUTO&#x27;,
	0x0114: &#x27;CUSTOMIZE.TOOLBAR&#x27;,
	0x0115: &#x27;ADD.TOOL&#x27;,
	0x0116: &#x27;EDIT.OBJECT&#x27;,
	0x0117: &#x27;ON.DOUBLECLICK&#x27;,
	0x0118: &#x27;ON.ENTRY&#x27;,
	0x0119: &#x27;WORKBOOK.ADD&#x27;,
	0x011A: &#x27;WORKBOOK.MOVE&#x27;,
	0x011B: &#x27;WORKBOOK.COPY&#x27;,
	0x011C: &#x27;WORKBOOK.OPTIONS&#x27;,
	0x011D: &#x27;SAVE.WORKSPACE&#x27;,
	0x0120: &#x27;CHART.WIZARD&#x27;,
	0x0121: &#x27;DELETE.TOOL&#x27;,
	0x0122: &#x27;MOVE.TOOL&#x27;,
	0x0123: &#x27;WORKBOOK.SELECT&#x27;,
	0x0124: &#x27;WORKBOOK.ACTIVATE&#x27;,
	0x0125: &#x27;ASSIGN.TO.TOOL&#x27;,
	0x0127: &#x27;COPY.TOOL&#x27;,
	0x0128: &#x27;RESET.TOOL&#x27;,
	0x0129: &#x27;CONSTRAIN.NUMERIC&#x27;,
	0x012A: &#x27;PASTE.TOOL&#x27;,
	0x012E: &#x27;WORKBOOK.NEW&#x27;,
	0x0131: &#x27;SCENARIO.CELLS&#x27;,
	0x0132: &#x27;SCENARIO.DELETE&#x27;,
	0x0133: &#x27;SCENARIO.ADD&#x27;,
	0x0134: &#x27;SCENARIO.EDIT&#x27;,
	0x0135: &#x27;SCENARIO.SHOW&#x27;,
	0x0136: &#x27;SCENARIO.SHOW.NEXT&#x27;,
	0x0137: &#x27;SCENARIO.SUMMARY&#x27;,
	0x0138: &#x27;PIVOT.TABLE.WIZARD&#x27;,
	0x0139: &#x27;PIVOT.FIELD.PROPERTIES&#x27;,
	0x013A: &#x27;PIVOT.FIELD&#x27;,
	0x013B: &#x27;PIVOT.ITEM&#x27;,
	0x013C: &#x27;PIVOT.ADD.FIELDS&#x27;,
	0x013E: &#x27;OPTIONS.CALCULATION&#x27;,
	0x013F: &#x27;OPTIONS.EDIT&#x27;,
	0x0140: &#x27;OPTIONS.VIEW&#x27;,
	0x0141: &#x27;ADDIN.MANAGER&#x27;,
	0x0142: &#x27;MENU.EDITOR&#x27;,
	0x0143: &#x27;ATTACH.TOOLBARS&#x27;,
	0x0144: &#x27;VBAActivate&#x27;,
	0x0145: &#x27;OPTIONS.CHART&#x27;,
	0x0148: &#x27;VBA.INSERT.FILE&#x27;,
	0x014A: &#x27;VBA.PROCEDURE.DEFINITION&#x27;,
	0x0150: &#x27;ROUTING.SLIP&#x27;,
	0x0152: &#x27;ROUTE.DOCUMENT&#x27;,
	0x0153: &#x27;MAIL.LOGON&#x27;,
	0x0156: &#x27;INSERT.PICTURE&#x27;,
	0x0157: &#x27;EDIT.TOOL&#x27;,
	0x0158: &#x27;GALLERY.DOUGHNUT&#x27;,
	0x015E: &#x27;CHART.TREND&#x27;,
	0x0160: &#x27;PIVOT.ITEM.PROPERTIES&#x27;,
	0x0162: &#x27;WORKBOOK.INSERT&#x27;,
	0x0163: &#x27;OPTIONS.TRANSITION&#x27;,
	0x0164: &#x27;OPTIONS.GENERAL&#x27;,
	0x0172: &#x27;FILTER.ADVANCED&#x27;,
	0x0175: &#x27;MAIL.ADD.MAILER&#x27;,
	0x0176: &#x27;MAIL.DELETE.MAILER&#x27;,
	0x0177: &#x27;MAIL.REPLY&#x27;,
	0x0178: &#x27;MAIL.REPLY.ALL&#x27;,
	0x0179: &#x27;MAIL.FORWARD&#x27;,
	0x017A: &#x27;MAIL.NEXT.LETTER&#x27;,
	0x017B: &#x27;DATA.LABEL&#x27;,
	0x017C: &#x27;INSERT.TITLE&#x27;,
	0x017D: &#x27;FONT.PROPERTIES&#x27;,
	0x017E: &#x27;MACRO.OPTIONS&#x27;,
	0x017F: &#x27;WORKBOOK.HIDE&#x27;,
	0x0180: &#x27;WORKBOOK.UNHIDE&#x27;,
	0x0181: &#x27;WORKBOOK.DELETE&#x27;,
	0x0182: &#x27;WORKBOOK.NAME&#x27;,
	0x0184: &#x27;GALLERY.CUSTOM&#x27;,
	0x0186: &#x27;ADD.CHART.AUTOFORMAT&#x27;,
	0x0187: &#x27;DELETE.CHART.AUTOFORMAT&#x27;,
	0x0188: &#x27;CHART.ADD.DATA&#x27;,
	0x0189: &#x27;AUTO.OUTLINE&#x27;,
	0x018A: &#x27;TAB.ORDER&#x27;,
	0x018B: &#x27;SHOW.DIALOG&#x27;,
	0x018C: &#x27;SELECT.ALL&#x27;,
	0x018D: &#x27;UNGROUP.SHEETS&#x27;,
	0x018E: &#x27;SUBTOTAL.CREATE&#x27;,
	0x018F: &#x27;SUBTOTAL.REMOVE&#x27;,
	0x0190: &#x27;RENAME.OBJECT&#x27;,
	0x019C: &#x27;WORKBOOK.SCROLL&#x27;,
	0x019D: &#x27;WORKBOOK.NEXT&#x27;,
	0x019E: &#x27;WORKBOOK.PREV&#x27;,
	0x019F: &#x27;WORKBOOK.TAB.SPLIT&#x27;,
	0x01A0: &#x27;FULL.SCREEN&#x27;,
	0x01A1: &#x27;WORKBOOK.PROTECT&#x27;,
	0x01A4: &#x27;SCROLLBAR.PROPERTIES&#x27;,
	0x01A5: &#x27;PIVOT.SHOW.PAGES&#x27;,
	0x01A6: &#x27;TEXT.TO.COLUMNS&#x27;,
	0x01A7: &#x27;FORMAT.CHARTTYPE&#x27;,
	0x01A8: &#x27;LINK.FORMAT&#x27;,
	0x01A9: &#x27;TRACER.DISPLAY&#x27;,
	0x01AE: &#x27;TRACER.NAVIGATE&#x27;,
	0x01AF: &#x27;TRACER.CLEAR&#x27;,
	0x01B0: &#x27;TRACER.ERROR&#x27;,
	0x01B1: &#x27;PIVOT.FIELD.GROUP&#x27;,
	0x01B2: &#x27;PIVOT.FIELD.UNGROUP&#x27;,
	0x01B3: &#x27;CHECKBOX.PROPERTIES&#x27;,
	0x01B4: &#x27;LABEL.PROPERTIES&#x27;,
	0x01B5: &#x27;LISTBOX.PROPERTIES&#x27;,
	0x01B6: &#x27;EDITBOX.PROPERTIES&#x27;,
	0x01B7: &#x27;PIVOT.REFRESH&#x27;,
	0x01B8: &#x27;LINK.COMBO&#x27;,
	0x01B9: &#x27;OPEN.TEXT&#x27;,
	0x01BA: &#x27;HIDE.DIALOG&#x27;,
	0x01BB: &#x27;SET.DIALOG.FOCUS&#x27;,
	0x01BC: &#x27;ENABLE.OBJECT&#x27;,
	0x01BD: &#x27;PUSHBUTTON.PROPERTIES&#x27;,
	0x01BE: &#x27;SET.DIALOG.DEFAULT&#x27;,
	0x01BF: &#x27;FILTER&#x27;,
	0x01C0: &#x27;FILTER.SHOW.ALL&#x27;,
	0x01C1: &#x27;CLEAR.OUTLINE&#x27;,
	0x01C2: &#x27;FUNCTION.WIZARD&#x27;,
	0x01C3: &#x27;ADD.LIST.ITEM&#x27;,
	0x01C4: &#x27;SET.LIST.ITEM&#x27;,
	0x01C5: &#x27;REMOVE.LIST.ITEM&#x27;,
	0x01C6: &#x27;SELECT.LIST.ITEM&#x27;,
	0x01C7: &#x27;SET.CONTROL.VALUE&#x27;,
	0x01C8: &#x27;SAVE.COPY.AS&#x27;,
	0x01CA: &#x27;OPTIONS.LISTS.ADD&#x27;,
	0x01CB: &#x27;OPTIONS.LISTS.DELETE&#x27;,
	0x01CC: &#x27;SERIES.AXES&#x27;,
	0x01CD: &#x27;SERIES.X&#x27;,
	0x01CE: &#x27;SERIES.Y&#x27;,
	0x01CF: &#x27;ERRORBAR.X&#x27;,
	0x01D0: &#x27;ERRORBAR.Y&#x27;,
	0x01D1: &#x27;FORMAT.CHART&#x27;,
	0x01D2: &#x27;SERIES.ORDER&#x27;,
	0x01D3: &#x27;MAIL.LOGOFF&#x27;,
	0x01D4: &#x27;CLEAR.ROUTING.SLIP&#x27;,
	0x01D5: &#x27;APP.ACTIVATE.MICROSOFT&#x27;,
	0x01D6: &#x27;MAIL.EDIT.MAILER&#x27;,
	0x01D7: &#x27;ON.SHEET&#x27;,
	0x01D8: &#x27;STANDARD.WIDTH&#x27;,
	0x01D9: &#x27;SCENARIO.MERGE&#x27;,
	0x01DA: &#x27;SUMMARY.INFO&#x27;,
	0x01DB: &#x27;FIND.FILE&#x27;,
	0x01DC: &#x27;ACTIVE.CELL.FONT&#x27;,
	0x01DD: &#x27;ENABLE.TIPWIZARD&#x27;,
	0x01DE: &#x27;VBA.MAKE.ADDIN&#x27;,
	0x01E0: &#x27;INSERTDATATABLE&#x27;,
	0x01E1: &#x27;WORKGROUP.OPTIONS&#x27;,
	0x01E2: &#x27;MAIL.SEND.MAILER&#x27;,
	0x01E5: &#x27;AUTOCORRECT&#x27;,
	0x01E9: &#x27;POST.DOCUMENT&#x27;,
	0x01EB: &#x27;PICKLIST&#x27;,
	0x01ED: &#x27;VIEW.SHOW&#x27;,
	0x01EE: &#x27;VIEW.DEFINE&#x27;,
	0x01EF: &#x27;VIEW.DELETE&#x27;,
	0x01FD: &#x27;SHEET.BACKGROUND&#x27;,
	0x01FE: &#x27;INSERT.MAP.OBJECT&#x27;,
	0x01FF: &#x27;OPTIONS.MENONO&#x27;,
	0x0205: &#x27;MSOCHECKS&#x27;,
	0x0206: &#x27;NORMAL&#x27;,
	0x0207: &#x27;LAYOUT&#x27;,
	0x0208: &#x27;RM.PRINT.AREA&#x27;,
	0x0209: &#x27;CLEAR.PRINT.AREA&#x27;,
	0x020A: &#x27;ADD.PRINT.AREA&#x27;,
	0x020B: &#x27;MOVE.BRK&#x27;,
	0x0221: &#x27;HIDECURR.NOTE&#x27;,
	0x0222: &#x27;HIDEALL.NOTES&#x27;,
	0x0223: &#x27;DELETE.NOTE&#x27;,
	0x0224: &#x27;TRAVERSE.NOTES&#x27;,
	0x0225: &#x27;ACTIVATE.NOTES&#x27;,
	0x026C: &#x27;PROTECT.REVISIONS&#x27;,
	0x026D: &#x27;UNPROTECT.REVISIONS&#x27;,
	0x0287: &#x27;OPTIONS.ME&#x27;,
	0x028D: &#x27;WEB.PUBLISH&#x27;,
	0x029B: &#x27;NEWWEBQUERY&#x27;,
	0x02A1: &#x27;PIVOT.TABLE.CHART&#x27;,
	0x02F1: &#x27;OPTIONS.SAVE&#x27;,
	0x02F3: &#x27;OPTIONS.SPELL&#x27;,
	0x0328: &#x27;HIDEALL.INKANNOTS&#x27;
};

/* [MS-XLS] 2.5.198.17 */
var Ftab = {
	0x0000: &#x27;COUNT&#x27;,
	0x0001: &#x27;IF&#x27;,
	0x0002: &#x27;ISNA&#x27;,
	0x0003: &#x27;ISERROR&#x27;,
	0x0004: &#x27;SUM&#x27;,
	0x0005: &#x27;AVERAGE&#x27;,
	0x0006: &#x27;MIN&#x27;,
	0x0007: &#x27;MAX&#x27;,
	0x0008: &#x27;ROW&#x27;,
	0x0009: &#x27;COLUMN&#x27;,
	0x000A: &#x27;NA&#x27;,
	0x000B: &#x27;NPV&#x27;,
	0x000C: &#x27;STDEV&#x27;,
	0x000D: &#x27;DOLLAR&#x27;,
	0x000E: &#x27;FIXED&#x27;,
	0x000F: &#x27;SIN&#x27;,
	0x0010: &#x27;COS&#x27;,
	0x0011: &#x27;TAN&#x27;,
	0x0012: &#x27;ATAN&#x27;,
	0x0013: &#x27;PI&#x27;,
	0x0014: &#x27;SQRT&#x27;,
	0x0015: &#x27;EXP&#x27;,
	0x0016: &#x27;LN&#x27;,
	0x0017: &#x27;LOG10&#x27;,
	0x0018: &#x27;ABS&#x27;,
	0x0019: &#x27;INT&#x27;,
	0x001A: &#x27;SIGN&#x27;,
	0x001B: &#x27;ROUND&#x27;,
	0x001C: &#x27;LOOKUP&#x27;,
	0x001D: &#x27;INDEX&#x27;,
	0x001E: &#x27;REPT&#x27;,
	0x001F: &#x27;MID&#x27;,
	0x0020: &#x27;LEN&#x27;,
	0x0021: &#x27;VALUE&#x27;,
	0x0022: &#x27;TRUE&#x27;,
	0x0023: &#x27;FALSE&#x27;,
	0x0024: &#x27;AND&#x27;,
	0x0025: &#x27;OR&#x27;,
	0x0026: &#x27;NOT&#x27;,
	0x0027: &#x27;MOD&#x27;,
	0x0028: &#x27;DCOUNT&#x27;,
	0x0029: &#x27;DSUM&#x27;,
	0x002A: &#x27;DAVERAGE&#x27;,
	0x002B: &#x27;DMIN&#x27;,
	0x002C: &#x27;DMAX&#x27;,
	0x002D: &#x27;DSTDEV&#x27;,
	0x002E: &#x27;VAR&#x27;,
	0x002F: &#x27;DVAR&#x27;,
	0x0030: &#x27;TEXT&#x27;,
	0x0031: &#x27;LINEST&#x27;,
	0x0032: &#x27;TREND&#x27;,
	0x0033: &#x27;LOGEST&#x27;,
	0x0034: &#x27;GROWTH&#x27;,
	0x0035: &#x27;GOTO&#x27;,
	0x0036: &#x27;HALT&#x27;,
	0x0037: &#x27;RETURN&#x27;,
	0x0038: &#x27;PV&#x27;,
	0x0039: &#x27;FV&#x27;,
	0x003A: &#x27;NPER&#x27;,
	0x003B: &#x27;PMT&#x27;,
	0x003C: &#x27;RATE&#x27;,
	0x003D: &#x27;MIRR&#x27;,
	0x003E: &#x27;IRR&#x27;,
	0x003F: &#x27;RAND&#x27;,
	0x0040: &#x27;MATCH&#x27;,
	0x0041: &#x27;DATE&#x27;,
	0x0042: &#x27;TIME&#x27;,
	0x0043: &#x27;DAY&#x27;,
	0x0044: &#x27;MONTH&#x27;,
	0x0045: &#x27;YEAR&#x27;,
	0x0046: &#x27;WEEKDAY&#x27;,
	0x0047: &#x27;HOUR&#x27;,
	0x0048: &#x27;MINUTE&#x27;,
	0x0049: &#x27;SECOND&#x27;,
	0x004A: &#x27;NOW&#x27;,
	0x004B: &#x27;AREAS&#x27;,
	0x004C: &#x27;ROWS&#x27;,
	0x004D: &#x27;COLUMNS&#x27;,
	0x004E: &#x27;OFFSET&#x27;,
	0x004F: &#x27;ABSREF&#x27;,
	0x0050: &#x27;RELREF&#x27;,
	0x0051: &#x27;ARGUMENT&#x27;,
	0x0052: &#x27;SEARCH&#x27;,
	0x0053: &#x27;TRANSPOSE&#x27;,
	0x0054: &#x27;ERROR&#x27;,
	0x0055: &#x27;STEP&#x27;,
	0x0056: &#x27;TYPE&#x27;,
	0x0057: &#x27;ECHO&#x27;,
	0x0058: &#x27;SET.NAME&#x27;,
	0x0059: &#x27;CALLER&#x27;,
	0x005A: &#x27;DEREF&#x27;,
	0x005B: &#x27;WINDOWS&#x27;,
	0x005C: &#x27;SERIES&#x27;,
	0x005D: &#x27;DOCUMENTS&#x27;,
	0x005E: &#x27;ACTIVE.CELL&#x27;,
	0x005F: &#x27;SELECTION&#x27;,
	0x0060: &#x27;RESULT&#x27;,
	0x0061: &#x27;ATAN2&#x27;,
	0x0062: &#x27;ASIN&#x27;,
	0x0063: &#x27;ACOS&#x27;,
	0x0064: &#x27;CHOOSE&#x27;,
	0x0065: &#x27;HLOOKUP&#x27;,
	0x0066: &#x27;VLOOKUP&#x27;,
	0x0067: &#x27;LINKS&#x27;,
	0x0068: &#x27;INPUT&#x27;,
	0x0069: &#x27;ISREF&#x27;,
	0x006A: &#x27;GET.FORMULA&#x27;,
	0x006B: &#x27;GET.NAME&#x27;,
	0x006C: &#x27;SET.VALUE&#x27;,
	0x006D: &#x27;LOG&#x27;,
	0x006E: &#x27;EXEC&#x27;,
	0x006F: &#x27;CHAR&#x27;,
	0x0070: &#x27;LOWER&#x27;,
	0x0071: &#x27;UPPER&#x27;,
	0x0072: &#x27;PROPER&#x27;,
	0x0073: &#x27;LEFT&#x27;,
	0x0074: &#x27;RIGHT&#x27;,
	0x0075: &#x27;EXACT&#x27;,
	0x0076: &#x27;TRIM&#x27;,
	0x0077: &#x27;REPLACE&#x27;,
	0x0078: &#x27;SUBSTITUTE&#x27;,
	0x0079: &#x27;CODE&#x27;,
	0x007A: &#x27;NAMES&#x27;,
	0x007B: &#x27;DIRECTORY&#x27;,
	0x007C: &#x27;FIND&#x27;,
	0x007D: &#x27;CELL&#x27;,
	0x007E: &#x27;ISERR&#x27;,
	0x007F: &#x27;ISTEXT&#x27;,
	0x0080: &#x27;ISNUMBER&#x27;,
	0x0081: &#x27;ISBLANK&#x27;,
	0x0082: &#x27;T&#x27;,
	0x0083: &#x27;N&#x27;,
	0x0084: &#x27;FOPEN&#x27;,
	0x0085: &#x27;FCLOSE&#x27;,
	0x0086: &#x27;FSIZE&#x27;,
	0x0087: &#x27;FREADLN&#x27;,
	0x0088: &#x27;FREAD&#x27;,
	0x0089: &#x27;FWRITELN&#x27;,
	0x008A: &#x27;FWRITE&#x27;,
	0x008B: &#x27;FPOS&#x27;,
	0x008C: &#x27;DATEVALUE&#x27;,
	0x008D: &#x27;TIMEVALUE&#x27;,
	0x008E: &#x27;SLN&#x27;,
	0x008F: &#x27;SYD&#x27;,
	0x0090: &#x27;DDB&#x27;,
	0x0091: &#x27;GET.DEF&#x27;,
	0x0092: &#x27;REFTEXT&#x27;,
	0x0093: &#x27;TEXTREF&#x27;,
	0x0094: &#x27;INDIRECT&#x27;,
	0x0095: &#x27;REGISTER&#x27;,
	0x0096: &#x27;CALL&#x27;,
	0x0097: &#x27;ADD.BAR&#x27;,
	0x0098: &#x27;ADD.MENU&#x27;,
	0x0099: &#x27;ADD.COMMAND&#x27;,
	0x009A: &#x27;ENABLE.COMMAND&#x27;,
	0x009B: &#x27;CHECK.COMMAND&#x27;,
	0x009C: &#x27;RENAME.COMMAND&#x27;,
	0x009D: &#x27;SHOW.BAR&#x27;,
	0x009E: &#x27;DELETE.MENU&#x27;,
	0x009F: &#x27;DELETE.COMMAND&#x27;,
	0x00A0: &#x27;GET.CHART.ITEM&#x27;,
	0x00A1: &#x27;DIALOG.BOX&#x27;,
	0x00A2: &#x27;CLEAN&#x27;,
	0x00A3: &#x27;MDETERM&#x27;,
	0x00A4: &#x27;MINVERSE&#x27;,
	0x00A5: &#x27;MMULT&#x27;,
	0x00A6: &#x27;FILES&#x27;,
	0x00A7: &#x27;IPMT&#x27;,
	0x00A8: &#x27;PPMT&#x27;,
	0x00A9: &#x27;COUNTA&#x27;,
	0x00AA: &#x27;CANCEL.KEY&#x27;,
	0x00AB: &#x27;FOR&#x27;,
	0x00AC: &#x27;WHILE&#x27;,
	0x00AD: &#x27;BREAK&#x27;,
	0x00AE: &#x27;NEXT&#x27;,
	0x00AF: &#x27;INITIATE&#x27;,
	0x00B0: &#x27;REQUEST&#x27;,
	0x00B1: &#x27;POKE&#x27;,
	0x00B2: &#x27;EXECUTE&#x27;,
	0x00B3: &#x27;TERMINATE&#x27;,
	0x00B4: &#x27;RESTART&#x27;,
	0x00B5: &#x27;HELP&#x27;,
	0x00B6: &#x27;GET.BAR&#x27;,
	0x00B7: &#x27;PRODUCT&#x27;,
	0x00B8: &#x27;FACT&#x27;,
	0x00B9: &#x27;GET.CELL&#x27;,
	0x00BA: &#x27;GET.WORKSPACE&#x27;,
	0x00BB: &#x27;GET.WINDOW&#x27;,
	0x00BC: &#x27;GET.DOCUMENT&#x27;,
	0x00BD: &#x27;DPRODUCT&#x27;,
	0x00BE: &#x27;ISNONTEXT&#x27;,
	0x00BF: &#x27;GET.NOTE&#x27;,
	0x00C0: &#x27;NOTE&#x27;,
	0x00C1: &#x27;STDEVP&#x27;,
	0x00C2: &#x27;VARP&#x27;,
	0x00C3: &#x27;DSTDEVP&#x27;,
	0x00C4: &#x27;DVARP&#x27;,
	0x00C5: &#x27;TRUNC&#x27;,
	0x00C6: &#x27;ISLOGICAL&#x27;,
	0x00C7: &#x27;DCOUNTA&#x27;,
	0x00C8: &#x27;DELETE.BAR&#x27;,
	0x00C9: &#x27;UNREGISTER&#x27;,
	0x00CC: &#x27;USDOLLAR&#x27;,
	0x00CD: &#x27;FINDB&#x27;,
	0x00CE: &#x27;SEARCHB&#x27;,
	0x00CF: &#x27;REPLACEB&#x27;,
	0x00D0: &#x27;LEFTB&#x27;,
	0x00D1: &#x27;RIGHTB&#x27;,
	0x00D2: &#x27;MIDB&#x27;,
	0x00D3: &#x27;LENB&#x27;,
	0x00D4: &#x27;ROUNDUP&#x27;,
	0x00D5: &#x27;ROUNDDOWN&#x27;,
	0x00D6: &#x27;ASC&#x27;,
	0x00D7: &#x27;DBCS&#x27;,
	0x00D8: &#x27;RANK&#x27;,
	0x00DB: &#x27;ADDRESS&#x27;,
	0x00DC: &#x27;DAYS360&#x27;,
	0x00DD: &#x27;TODAY&#x27;,
	0x00DE: &#x27;VDB&#x27;,
	0x00DF: &#x27;ELSE&#x27;,
	0x00E0: &#x27;ELSE.IF&#x27;,
	0x00E1: &#x27;END.IF&#x27;,
	0x00E2: &#x27;FOR.CELL&#x27;,
	0x00E3: &#x27;MEDIAN&#x27;,
	0x00E4: &#x27;SUMPRODUCT&#x27;,
	0x00E5: &#x27;SINH&#x27;,
	0x00E6: &#x27;COSH&#x27;,
	0x00E7: &#x27;TANH&#x27;,
	0x00E8: &#x27;ASINH&#x27;,
	0x00E9: &#x27;ACOSH&#x27;,
	0x00EA: &#x27;ATANH&#x27;,
	0x00EB: &#x27;DGET&#x27;,
	0x00EC: &#x27;CREATE.OBJECT&#x27;,
	0x00ED: &#x27;VOLATILE&#x27;,
	0x00EE: &#x27;LAST.ERROR&#x27;,
	0x00EF: &#x27;CUSTOM.UNDO&#x27;,
	0x00F0: &#x27;CUSTOM.REPEAT&#x27;,
	0x00F1: &#x27;FORMULA.CONVERT&#x27;,
	0x00F2: &#x27;GET.LINK.INFO&#x27;,
	0x00F3: &#x27;TEXT.BOX&#x27;,
	0x00F4: &#x27;INFO&#x27;,
	0x00F5: &#x27;GROUP&#x27;,
	0x00F6: &#x27;GET.OBJECT&#x27;,
	0x00F7: &#x27;DB&#x27;,
	0x00F8: &#x27;PAUSE&#x27;,
	0x00FB: &#x27;RESUME&#x27;,
	0x00FC: &#x27;FREQUENCY&#x27;,
	0x00FD: &#x27;ADD.TOOLBAR&#x27;,
	0x00FE: &#x27;DELETE.TOOLBAR&#x27;,
	0x00FF: &#x27;User&#x27;,
	0x0100: &#x27;RESET.TOOLBAR&#x27;,
	0x0101: &#x27;EVALUATE&#x27;,
	0x0102: &#x27;GET.TOOLBAR&#x27;,
	0x0103: &#x27;GET.TOOL&#x27;,
	0x0104: &#x27;SPELLING.CHECK&#x27;,
	0x0105: &#x27;ERROR.TYPE&#x27;,
	0x0106: &#x27;APP.TITLE&#x27;,
	0x0107: &#x27;WINDOW.TITLE&#x27;,
	0x0108: &#x27;SAVE.TOOLBAR&#x27;,
	0x0109: &#x27;ENABLE.TOOL&#x27;,
	0x010A: &#x27;PRESS.TOOL&#x27;,
	0x010B: &#x27;REGISTER.ID&#x27;,
	0x010C: &#x27;GET.WORKBOOK&#x27;,
	0x010D: &#x27;AVEDEV&#x27;,
	0x010E: &#x27;BETADIST&#x27;,
	0x010F: &#x27;GAMMALN&#x27;,
	0x0110: &#x27;BETAINV&#x27;,
	0x0111: &#x27;BINOMDIST&#x27;,
	0x0112: &#x27;CHIDIST&#x27;,
	0x0113: &#x27;CHIINV&#x27;,
	0x0114: &#x27;COMBIN&#x27;,
	0x0115: &#x27;CONFIDENCE&#x27;,
	0x0116: &#x27;CRITBINOM&#x27;,
	0x0117: &#x27;EVEN&#x27;,
	0x0118: &#x27;EXPONDIST&#x27;,
	0x0119: &#x27;FDIST&#x27;,
	0x011A: &#x27;FINV&#x27;,
	0x011B: &#x27;FISHER&#x27;,
	0x011C: &#x27;FISHERINV&#x27;,
	0x011D: &#x27;FLOOR&#x27;,
	0x011E: &#x27;GAMMADIST&#x27;,
	0x011F: &#x27;GAMMAINV&#x27;,
	0x0120: &#x27;CEILING&#x27;,
	0x0121: &#x27;HYPGEOMDIST&#x27;,
	0x0122: &#x27;LOGNORMDIST&#x27;,
	0x0123: &#x27;LOGINV&#x27;,
	0x0124: &#x27;NEGBINOMDIST&#x27;,
	0x0125: &#x27;NORMDIST&#x27;,
	0x0126: &#x27;NORMSDIST&#x27;,
	0x0127: &#x27;NORMINV&#x27;,
	0x0128: &#x27;NORMSINV&#x27;,
	0x0129: &#x27;STANDARDIZE&#x27;,
	0x012A: &#x27;ODD&#x27;,
	0x012B: &#x27;PERMUT&#x27;,
	0x012C: &#x27;POISSON&#x27;,
	0x012D: &#x27;TDIST&#x27;,
	0x012E: &#x27;WEIBULL&#x27;,
	0x012F: &#x27;SUMXMY2&#x27;,
	0x0130: &#x27;SUMX2MY2&#x27;,
	0x0131: &#x27;SUMX2PY2&#x27;,
	0x0132: &#x27;CHITEST&#x27;,
	0x0133: &#x27;CORREL&#x27;,
	0x0134: &#x27;COVAR&#x27;,
	0x0135: &#x27;FORECAST&#x27;,
	0x0136: &#x27;FTEST&#x27;,
	0x0137: &#x27;INTERCEPT&#x27;,
	0x0138: &#x27;PEARSON&#x27;,
	0x0139: &#x27;RSQ&#x27;,
	0x013A: &#x27;STEYX&#x27;,
	0x013B: &#x27;SLOPE&#x27;,
	0x013C: &#x27;TTEST&#x27;,
	0x013D: &#x27;PROB&#x27;,
	0x013E: &#x27;DEVSQ&#x27;,
	0x013F: &#x27;GEOMEAN&#x27;,
	0x0140: &#x27;HARMEAN&#x27;,
	0x0141: &#x27;SUMSQ&#x27;,
	0x0142: &#x27;KURT&#x27;,
	0x0143: &#x27;SKEW&#x27;,
	0x0144: &#x27;ZTEST&#x27;,
	0x0145: &#x27;LARGE&#x27;,
	0x0146: &#x27;SMALL&#x27;,
	0x0147: &#x27;QUARTILE&#x27;,
	0x0148: &#x27;PERCENTILE&#x27;,
	0x0149: &#x27;PERCENTRANK&#x27;,
	0x014A: &#x27;MODE&#x27;,
	0x014B: &#x27;TRIMMEAN&#x27;,
	0x014C: &#x27;TINV&#x27;,
	0x014E: &#x27;MOVIE.COMMAND&#x27;,
	0x014F: &#x27;GET.MOVIE&#x27;,
	0x0150: &#x27;CONCATENATE&#x27;,
	0x0151: &#x27;POWER&#x27;,
	0x0152: &#x27;PIVOT.ADD.DATA&#x27;,
	0x0153: &#x27;GET.PIVOT.TABLE&#x27;,
	0x0154: &#x27;GET.PIVOT.FIELD&#x27;,
	0x0155: &#x27;GET.PIVOT.ITEM&#x27;,
	0x0156: &#x27;RADIANS&#x27;,
	0x0157: &#x27;DEGREES&#x27;,
	0x0158: &#x27;SUBTOTAL&#x27;,
	0x0159: &#x27;SUMIF&#x27;,
	0x015A: &#x27;COUNTIF&#x27;,
	0x015B: &#x27;COUNTBLANK&#x27;,
	0x015C: &#x27;SCENARIO.GET&#x27;,
	0x015D: &#x27;OPTIONS.LISTS.GET&#x27;,
	0x015E: &#x27;ISPMT&#x27;,
	0x015F: &#x27;DATEDIF&#x27;,
	0x0160: &#x27;DATESTRING&#x27;,
	0x0161: &#x27;NUMBERSTRING&#x27;,
	0x0162: &#x27;ROMAN&#x27;,
	0x0163: &#x27;OPEN.DIALOG&#x27;,
	0x0164: &#x27;SAVE.DIALOG&#x27;,
	0x0165: &#x27;VIEW.GET&#x27;,
	0x0166: &#x27;GETPIVOTDATA&#x27;,
	0x0167: &#x27;HYPERLINK&#x27;,
	0x0168: &#x27;PHONETIC&#x27;,
	0x0169: &#x27;AVERAGEA&#x27;,
	0x016A: &#x27;MAXA&#x27;,
	0x016B: &#x27;MINA&#x27;,
	0x016C: &#x27;STDEVPA&#x27;,
	0x016D: &#x27;VARPA&#x27;,
	0x016E: &#x27;STDEVA&#x27;,
	0x016F: &#x27;VARA&#x27;,
	0x0170: &#x27;BAHTTEXT&#x27;,
	0x0171: &#x27;THAIDAYOFWEEK&#x27;,
	0x0172: &#x27;THAIDIGIT&#x27;,
	0x0173: &#x27;THAIMONTHOFYEAR&#x27;,
	0x0174: &#x27;THAINUMSOUND&#x27;,
	0x0175: &#x27;THAINUMSTRING&#x27;,
	0x0176: &#x27;THAISTRINGLENGTH&#x27;,
	0x0177: &#x27;ISTHAIDIGIT&#x27;,
	0x0178: &#x27;ROUNDBAHTDOWN&#x27;,
	0x0179: &#x27;ROUNDBAHTUP&#x27;,
	0x017A: &#x27;THAIYEAR&#x27;,
	0x017B: &#x27;RTD&#x27;
};
var FtabArgc = {
	0x0002: 1, /* ISNA */
	0x0003: 1, /* ISERROR */
	0x000F: 1, /* SIN */
	0x0010: 1, /* COS */
	0x0011: 1, /* TAN */
	0x0012: 1, /* ATAN */
	0x0014: 1, /* SQRT */
	0x0015: 1, /* EXP */
	0x0016: 1, /* LN */
	0x0017: 1, /* LOG10 */
	0x0018: 1, /* ABS */
	0x0019: 1, /* INT */
	0x001A: 1, /* SIGN */
	0x001B: 2, /* ROUND */
	0x001E: 2, /* REPT */
	0x001F: 3, /* MID */
	0x0020: 1, /* LEN */
	0x0021: 1, /* VALUE */
	0x0026: 1, /* NOT */
	0x0027: 2, /* MOD */
	0x0028: 3, /* DCOUNT */
	0x0029: 3, /* DSUM */
	0x002A: 3, /* DAVERAGE */
	0x002B: 3, /* DMIN */
	0x002C: 3, /* DMAX */
	0x002D: 3, /* DSTDEV */
	0x002F: 3, /* DVAR */
	0x0030: 2, /* TEXT */
	0x0035: 1, /* GOTO */
	0x003D: 3, /* MIRR */
	0x0041: 3, /* DATE */
	0x0042: 3, /* TIME */
	0x0043: 1, /* DAY */
	0x0044: 1, /* MONTH */
	0x0045: 1, /* YEAR */
	0x0047: 1, /* HOUR */
	0x0048: 1, /* MINUTE */
	0x0049: 1, /* SECOND */
	0x004B: 1, /* AREAS */
	0x004C: 1, /* ROWS */
	0x004D: 1, /* COLUMNS */
	0x004F: 2, /* ABSREF */
	0x0050: 2, /* RELREF */
	0x0053: 1, /* TRANSPOSE */
	0x0056: 1, /* TYPE */
	0x005A: 1, /* DEREF */
	0x0061: 2, /* ATAN2 */
	0x0062: 1, /* ASIN */
	0x0063: 1, /* ACOS */
	0x0069: 1, /* ISREF */
	0x006F: 1, /* CHAR */
	0x0070: 1, /* LOWER */
	0x0071: 1, /* UPPER */
	0x0072: 1, /* PROPER */
	0x0075: 2, /* EXACT */
	0x0076: 1, /* TRIM */
	0x0077: 4, /* REPLACE */
	0x0079: 1, /* CODE */
	0x007E: 1, /* ISERR */
	0x007F: 1, /* ISTEXT */
	0x0080: 1, /* ISNUMBER */
	0x0081: 1, /* ISBLANK */
	0x0082: 1, /* T */
	0x0083: 1, /* N */
	0x0085: 1, /* FCLOSE */
	0x0086: 1, /* FSIZE */
	0x0087: 1, /* FREADLN */
	0x0088: 2, /* FREAD */
	0x0089: 2, /* FWRITELN */
	0x008A: 2, /* FWRITE */
	0x008C: 1, /* DATEVALUE */
	0x008D: 1, /* TIMEVALUE */
	0x008E: 3, /* SLN */
	0x008F: 4, /* SYD */
	0x00A2: 1, /* CLEAN */
	0x00A3: 1, /* MDETERM */
	0x00A4: 1, /* MINVERSE */
	0x00A5: 2, /* MMULT */
	0x00AC: 1, /* WHILE */
	0x00AF: 2, /* INITIATE */
	0x00B0: 2, /* REQUEST */
	0x00B1: 3, /* POKE */
	0x00B2: 2, /* EXECUTE */
	0x00B3: 1, /* TERMINATE */
	0x00B8: 1, /* FACT */
	0x00BD: 3, /* DPRODUCT */
	0x00BE: 1, /* ISNONTEXT */
	0x00C3: 3, /* DSTDEVP */
	0x00C4: 3, /* DVARP */
	0x00C6: 1, /* ISLOGICAL */
	0x00C7: 3, /* DCOUNTA */
	0x00C9: 1, /* UNREGISTER */
	0x00CF: 4, /* REPLACEB */
	0x00D2: 3, /* MIDB */
	0x00D3: 1, /* LENB */
	0x00D4: 2, /* ROUNDUP */
	0x00D5: 2, /* ROUNDDOWN */
	0x00D6: 1, /* ASC */
	0x00D7: 1, /* DBCS */
	0x00E5: 1, /* SINH */
	0x00E6: 1, /* COSH */
	0x00E7: 1, /* TANH */
	0x00E8: 1, /* ASINH */
	0x00E9: 1, /* ACOSH */
	0x00EA: 1, /* ATANH */
	0x00EB: 3, /* DGET */
	0x00F4: 1, /* INFO */
	0x00FC: 2, /* FREQUENCY */
	0x0101: 1, /* EVALUATE */
	0x0105: 1, /* ERROR.TYPE */
	0x010F: 1, /* GAMMALN */
	0x0111: 4, /* BINOMDIST */
	0x0112: 2, /* CHIDIST */
	0x0113: 2, /* CHIINV */
	0x0114: 2, /* COMBIN */
	0x0115: 3, /* CONFIDENCE */
	0x0116: 3, /* CRITBINOM */
	0x0117: 1, /* EVEN */
	0x0118: 3, /* EXPONDIST */
	0x0119: 3, /* FDIST */
	0x011A: 3, /* FINV */
	0x011B: 1, /* FISHER */
	0x011C: 1, /* FISHERINV */
	0x011D: 2, /* FLOOR */
	0x011E: 4, /* GAMMADIST */
	0x011F: 3, /* GAMMAINV */
	0x0120: 2, /* CEILING */
	0x0121: 4, /* HYPGEOMDIST */
	0x0122: 3, /* LOGNORMDIST */
	0x0123: 3, /* LOGINV */
	0x0124: 3, /* NEGBINOMDIST */
	0x0125: 4, /* NORMDIST */
	0x0126: 1, /* NORMSDIST */
	0x0127: 3, /* NORMINV */
	0x0128: 1, /* NORMSINV */
	0x0129: 3, /* STANDARDIZE */
	0x012A: 1, /* ODD */
	0x012B: 2, /* PERMUT */
	0x012C: 3, /* POISSON */
	0x012D: 3, /* TDIST */
	0x012E: 4, /* WEIBULL */
	0x012F: 2, /* SUMXMY2 */
	0x0130: 2, /* SUMX2MY2 */
	0x0131: 2, /* SUMX2PY2 */
	0x0132: 2, /* CHITEST */
	0x0133: 2, /* CORREL */
	0x0134: 2, /* COVAR */
	0x0135: 3, /* FORECAST */
	0x0136: 2, /* FTEST */
	0x0137: 2, /* INTERCEPT */
	0x0138: 2, /* PEARSON */
	0x0139: 2, /* RSQ */
	0x013A: 2, /* STEYX */
	0x013B: 2, /* SLOPE */
	0x013C: 4, /* TTEST */
	0x0145: 2, /* LARGE */
	0x0146: 2, /* SMALL */
	0x0147: 2, /* QUARTILE */
	0x0148: 2, /* PERCENTILE */
	0x014B: 2, /* TRIMMEAN */
	0x014C: 2, /* TINV */
	0x0151: 2, /* POWER */
	0x0156: 1, /* RADIANS */
	0x0157: 1, /* DEGREES */
	0x015A: 2, /* COUNTIF */
	0x015B: 1, /* COUNTBLANK */
	0x015E: 4, /* ISPMT */
	0x015F: 3, /* DATEDIF */
	0x0160: 1, /* DATESTRING */
	0x0161: 2, /* NUMBERSTRING */
	0x0168: 1, /* PHONETIC */
	0x0170: 1, /* BAHTTEXT */
	0x0171: 1, /* THAIDAYOFWEEK */
	0x0172: 1, /* THAIDIGIT */
	0x0173: 1, /* THAIMONTHOFYEAR */
	0x0174: 1, /* THAINUMSOUND */
	0x0175: 1, /* THAINUMSTRING */
	0x0176: 1, /* THAISTRINGLENGTH */
	0x0177: 1, /* ISTHAIDIGIT */
	0x0178: 1, /* ROUNDBAHTDOWN */
	0x0179: 1, /* ROUNDBAHTUP */
	0x017A: 1, /* THAIYEAR */
	0xFFFF: 0
};
/* [MS-XLSX] 2.2.3 Functions */
var XLSXFutureFunctions = {
	&quot;_xlfn.ACOT&quot;: &quot;ACOT&quot;,
	&quot;_xlfn.ACOTH&quot;: &quot;ACOTH&quot;,
	&quot;_xlfn.AGGREGATE&quot;: &quot;AGGREGATE&quot;,
	&quot;_xlfn.ARABIC&quot;: &quot;ARABIC&quot;,
	&quot;_xlfn.AVERAGEIF&quot;: &quot;AVERAGEIF&quot;,
	&quot;_xlfn.AVERAGEIFS&quot;: &quot;AVERAGEIFS&quot;,
	&quot;_xlfn.BASE&quot;: &quot;BASE&quot;,
	&quot;_xlfn.BETA.DIST&quot;: &quot;BETA.DIST&quot;,
	&quot;_xlfn.BETA.INV&quot;: &quot;BETA.INV&quot;,
	&quot;_xlfn.BINOM.DIST&quot;: &quot;BINOM.DIST&quot;,
	&quot;_xlfn.BINOM.DIST.RANGE&quot;: &quot;BINOM.DIST.RANGE&quot;,
	&quot;_xlfn.BINOM.INV&quot;: &quot;BINOM.INV&quot;,
	&quot;_xlfn.BITAND&quot;: &quot;BITAND&quot;,
	&quot;_xlfn.BITLSHIFT&quot;: &quot;BITLSHIFT&quot;,
	&quot;_xlfn.BITOR&quot;: &quot;BITOR&quot;,
	&quot;_xlfn.BITRSHIFT&quot;: &quot;BITRSHIFT&quot;,
	&quot;_xlfn.BITXOR&quot;: &quot;BITXOR&quot;,
	&quot;_xlfn.CEILING.MATH&quot;: &quot;CEILING.MATH&quot;,
	&quot;_xlfn.CEILING.PRECISE&quot;: &quot;CEILING.PRECISE&quot;,
	&quot;_xlfn.CHISQ.DIST&quot;: &quot;CHISQ.DIST&quot;,
	&quot;_xlfn.CHISQ.DIST.RT&quot;: &quot;CHISQ.DIST.RT&quot;,
	&quot;_xlfn.CHISQ.INV&quot;: &quot;CHISQ.INV&quot;,
	&quot;_xlfn.CHISQ.INV.RT&quot;: &quot;CHISQ.INV.RT&quot;,
	&quot;_xlfn.CHISQ.TEST&quot;: &quot;CHISQ.TEST&quot;,
	&quot;_xlfn.COMBINA&quot;: &quot;COMBINA&quot;,
	&quot;_xlfn.CONFIDENCE.NORM&quot;: &quot;CONFIDENCE.NORM&quot;,
	&quot;_xlfn.CONFIDENCE.T&quot;: &quot;CONFIDENCE.T&quot;,
	&quot;_xlfn.COT&quot;: &quot;COT&quot;,
	&quot;_xlfn.COTH&quot;: &quot;COTH&quot;,
	&quot;_xlfn.COUNTIFS&quot;: &quot;COUNTIFS&quot;,
	&quot;_xlfn.COVARIANCE.P&quot;: &quot;COVARIANCE.P&quot;,
	&quot;_xlfn.COVARIANCE.S&quot;: &quot;COVARIANCE.S&quot;,
	&quot;_xlfn.CSC&quot;: &quot;CSC&quot;,
	&quot;_xlfn.CSCH&quot;: &quot;CSCH&quot;,
	&quot;_xlfn.DAYS&quot;: &quot;DAYS&quot;,
	&quot;_xlfn.DECIMAL&quot;: &quot;DECIMAL&quot;,
	&quot;_xlfn.ECMA.CEILING&quot;: &quot;ECMA.CEILING&quot;,
	&quot;_xlfn.ERF.PRECISE&quot;: &quot;ERF.PRECISE&quot;,
	&quot;_xlfn.ERFC.PRECISE&quot;: &quot;ERFC.PRECISE&quot;,
	&quot;_xlfn.EXPON.DIST&quot;: &quot;EXPON.DIST&quot;,
	&quot;_xlfn.F.DIST&quot;: &quot;F.DIST&quot;,
	&quot;_xlfn.F.DIST.RT&quot;: &quot;F.DIST.RT&quot;,
	&quot;_xlfn.F.INV&quot;: &quot;F.INV&quot;,
	&quot;_xlfn.F.INV.RT&quot;: &quot;F.INV.RT&quot;,
	&quot;_xlfn.F.TEST&quot;: &quot;F.TEST&quot;,
	&quot;_xlfn.FILTERXML&quot;: &quot;FILTERXML&quot;,
	&quot;_xlfn.FLOOR.MATH&quot;: &quot;FLOOR.MATH&quot;,
	&quot;_xlfn.FLOOR.PRECISE&quot;: &quot;FLOOR.PRECISE&quot;,
	&quot;_xlfn.FORMULATEXT&quot;: &quot;FORMULATEXT&quot;,
	&quot;_xlfn.GAMMA&quot;: &quot;GAMMA&quot;,
	&quot;_xlfn.GAMMA.DIST&quot;: &quot;GAMMA.DIST&quot;,
	&quot;_xlfn.GAMMA.INV&quot;: &quot;GAMMA.INV&quot;,
	&quot;_xlfn.GAMMALN.PRECISE&quot;: &quot;GAMMALN.PRECISE&quot;,
	&quot;_xlfn.GAUSS&quot;: &quot;GAUSS&quot;,
	&quot;_xlfn.HYPGEOM.DIST&quot;: &quot;HYPGEOM.DIST&quot;,
	&quot;_xlfn.IFNA&quot;: &quot;IFNA&quot;,
	&quot;_xlfn.IFERROR&quot;: &quot;IFERROR&quot;,
	&quot;_xlfn.IMCOSH&quot;: &quot;IMCOSH&quot;,
	&quot;_xlfn.IMCOT&quot;: &quot;IMCOT&quot;,
	&quot;_xlfn.IMCSC&quot;: &quot;IMCSC&quot;,
	&quot;_xlfn.IMCSCH&quot;: &quot;IMCSCH&quot;,
	&quot;_xlfn.IMSEC&quot;: &quot;IMSEC&quot;,
	&quot;_xlfn.IMSECH&quot;: &quot;IMSECH&quot;,
	&quot;_xlfn.IMSINH&quot;: &quot;IMSINH&quot;,
	&quot;_xlfn.IMTAN&quot;: &quot;IMTAN&quot;,
	&quot;_xlfn.ISFORMULA&quot;: &quot;ISFORMULA&quot;,
	&quot;_xlfn.ISO.CEILING&quot;: &quot;ISO.CEILING&quot;,
	&quot;_xlfn.ISOWEEKNUM&quot;: &quot;ISOWEEKNUM&quot;,
	&quot;_xlfn.LOGNORM.DIST&quot;: &quot;LOGNORM.DIST&quot;,
	&quot;_xlfn.LOGNORM.INV&quot;: &quot;LOGNORM.INV&quot;,
	&quot;_xlfn.MODE.MULT&quot;: &quot;MODE.MULT&quot;,
	&quot;_xlfn.MODE.SNGL&quot;: &quot;MODE.SNGL&quot;,
	&quot;_xlfn.MUNIT&quot;: &quot;MUNIT&quot;,
	&quot;_xlfn.NEGBINOM.DIST&quot;: &quot;NEGBINOM.DIST&quot;,
	&quot;_xlfn.NETWORKDAYS.INTL&quot;: &quot;NETWORKDAYS.INTL&quot;,
	&quot;_xlfn.NIGBINOM&quot;: &quot;NIGBINOM&quot;,
	&quot;_xlfn.NORM.DIST&quot;: &quot;NORM.DIST&quot;,
	&quot;_xlfn.NORM.INV&quot;: &quot;NORM.INV&quot;,
	&quot;_xlfn.NORM.S.DIST&quot;: &quot;NORM.S.DIST&quot;,
	&quot;_xlfn.NORM.S.INV&quot;: &quot;NORM.S.INV&quot;,
	&quot;_xlfn.NUMBERVALUE&quot;: &quot;NUMBERVALUE&quot;,
	&quot;_xlfn.PDURATION&quot;: &quot;PDURATION&quot;,
	&quot;_xlfn.PERCENTILE.EXC&quot;: &quot;PERCENTILE.EXC&quot;,
	&quot;_xlfn.PERCENTILE.INC&quot;: &quot;PERCENTILE.INC&quot;,
	&quot;_xlfn.PERCENTRANK.EXC&quot;: &quot;PERCENTRANK.EXC&quot;,
	&quot;_xlfn.PERCENTRANK.INC&quot;: &quot;PERCENTRANK.INC&quot;,
	&quot;_xlfn.PERMUTATIONA&quot;: &quot;PERMUTATIONA&quot;,
	&quot;_xlfn.PHI&quot;: &quot;PHI&quot;,
	&quot;_xlfn.POISSON.DIST&quot;: &quot;POISSON.DIST&quot;,
	&quot;_xlfn.QUARTILE.EXC&quot;: &quot;QUARTILE.EXC&quot;,
	&quot;_xlfn.QUARTILE.INC&quot;: &quot;QUARTILE.INC&quot;,
	&quot;_xlfn.QUERYSTRING&quot;: &quot;QUERYSTRING&quot;,
	&quot;_xlfn.RANK.AVG&quot;: &quot;RANK.AVG&quot;,
	&quot;_xlfn.RANK.EQ&quot;: &quot;RANK.EQ&quot;,
	&quot;_xlfn.RRI&quot;: &quot;RRI&quot;,
	&quot;_xlfn.SEC&quot;: &quot;SEC&quot;,
	&quot;_xlfn.SECH&quot;: &quot;SECH&quot;,
	&quot;_xlfn.SHEET&quot;: &quot;SHEET&quot;,
	&quot;_xlfn.SHEETS&quot;: &quot;SHEETS&quot;,
	&quot;_xlfn.SKEW.P&quot;: &quot;SKEW.P&quot;,
	&quot;_xlfn.STDEV.P&quot;: &quot;STDEV.P&quot;,
	&quot;_xlfn.STDEV.S&quot;: &quot;STDEV.S&quot;,
	&quot;_xlfn.SUMIFS&quot;: &quot;SUMIFS&quot;,
	&quot;_xlfn.T.DIST&quot;: &quot;T.DIST&quot;,
	&quot;_xlfn.T.DIST.2T&quot;: &quot;T.DIST.2T&quot;,
	&quot;_xlfn.T.DIST.RT&quot;: &quot;T.DIST.RT&quot;,
	&quot;_xlfn.T.INV&quot;: &quot;T.INV&quot;,
	&quot;_xlfn.T.INV.2T&quot;: &quot;T.INV.2T&quot;,
	&quot;_xlfn.T.TEST&quot;: &quot;T.TEST&quot;,
	&quot;_xlfn.UNICHAR&quot;: &quot;UNICHAR&quot;,
	&quot;_xlfn.UNICODE&quot;: &quot;UNICODE&quot;,
	&quot;_xlfn.VAR.P&quot;: &quot;VAR.P&quot;,
	&quot;_xlfn.VAR.S&quot;: &quot;VAR.S&quot;,
	&quot;_xlfn.WEBSERVICE&quot;: &quot;WEBSERVICE&quot;,
	&quot;_xlfn.WEIBULL.DIST&quot;: &quot;WEIBULL.DIST&quot;,
	&quot;_xlfn.WORKDAY.INTL&quot;: &quot;WORKDAY.INTL&quot;,
	&quot;_xlfn.XOR&quot;: &quot;XOR&quot;,
	&quot;_xlfn.Z.TEST&quot;: &quot;Z.TEST&quot;
};

var strs = {}; // shared strings
var _ssfopts = {}; // spreadsheet formatting options

RELS.WS = &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet&quot;;

function get_sst_id(sst, str) {
	for(var i = 0, len = sst.length; i &lt; len; ++i) if(sst[i].t === str) { sst.Count ++; return i; }
	sst[len] = {t:str}; sst.Count ++; sst.Unique ++; return len;
}

function get_cell_style(styles, cell, opts) {
	var z = opts.revssf[cell.z != null ? cell.z : &quot;General&quot;];
	for(var i = 0, len = styles.length; i != len; ++i) if(styles[i].numFmtId === z) return i;
	styles[len] = {
		numFmtId:z,
		fontId:0,
		fillId:0,
		borderId:0,
		xfId:0,
		applyNumberFormat:1
	};
	return len;
}

function safe_format(p, fmtid, fillid, opts) {
	try {
		if(p.t === &#x27;e&#x27;) p.w = p.w || BErr[p.v];
		else if(fmtid === 0) {
			if(p.t === &#x27;n&#x27;) {
				if((p.v|0) === p.v) p.w = SSF._general_int(p.v,_ssfopts);
				else p.w = SSF._general_num(p.v,_ssfopts);
			}
			else if(p.t === &#x27;d&#x27;) {
				var dd = datenum(p.v);
				if((dd|0) === dd) p.w = SSF._general_int(dd,_ssfopts);
				else p.w = SSF._general_num(dd,_ssfopts);
			}
			else if(p.v === undefined) return &quot;&quot;;
			else p.w = SSF._general(p.v,_ssfopts);
		}
		else if(p.t === &#x27;d&#x27;) p.w = SSF.format(fmtid,datenum(p.v),_ssfopts);
		else p.w = SSF.format(fmtid,p.v,_ssfopts);
		if(opts.cellNF) p.z = SSF._table[fmtid];
	} catch(e) { if(opts.WTF) throw e; }
	if(fillid) try {
		p.s = styles.Fills[fillid];
		if (p.s.fgColor &amp;&amp; p.s.fgColor.theme) {
			p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
			if(opts.WTF) p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;
		}
		if (p.s.bgColor &amp;&amp; p.s.bgColor.theme) {
			p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
			if(opts.WTF) p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;
		}
	} catch(e) { if(opts.WTF) throw e; }
}
function parse_ws_xml_dim(ws, s) {
	var d = safe_decode_range(s);
	if(d.s.r&lt;=d.e.r &amp;&amp; d.s.c&lt;=d.e.c &amp;&amp; d.s.r&gt;=0 &amp;&amp; d.s.c&gt;=0) ws[&quot;!ref&quot;] = encode_range(d);
}
var mergecregex = /&lt;mergeCell ref=&quot;[A-Z0-9:]+&quot;\s*\/&gt;/g;
var sheetdataregex = /&lt;(?:\w+:)?sheetData&gt;([^\u2603]*)&lt;\/(?:\w+:)?sheetData&gt;/;
var hlinkregex = /&lt;hyperlink[^&gt;]*\/&gt;/g;
var dimregex = /&quot;(\w*:\w*)&quot;/;
var colregex = /&lt;col[^&gt;]*\/&gt;/g;
/* 18.3 Worksheets */
function parse_ws_xml(data, opts, rels) {
	if(!data) return data;
	/* 18.3.1.99 worksheet CT_Worksheet */
	var s = {};

	/* 18.3.1.35 dimension CT_SheetDimension ? */
	var ridx = data.indexOf(&quot;&lt;dimension&quot;);
	if(ridx &gt; 0) {
		var ref = data.substr(ridx,50).match(dimregex);
		if(ref != null) parse_ws_xml_dim(s, ref[1]);
	}

	/* 18.3.1.55 mergeCells CT_MergeCells */
	var mergecells = [];
	if(data.indexOf(&quot;&lt;/mergeCells&gt;&quot;)!==-1) {
		var merges = data.match(mergecregex);
		for(ridx = 0; ridx != merges.length; ++ridx)
			mergecells[ridx] = safe_decode_range(merges[ridx].substr(merges[ridx].indexOf(&quot;\&quot;&quot;)+1));
	}

	/* 18.3.1.17 cols CT_Cols */
	var columns = [];
	if(opts.cellStyles &amp;&amp; data.indexOf(&quot;&lt;/cols&gt;&quot;)!==-1) {
		/* 18.3.1.13 col CT_Col */
		var cols = data.match(colregex);
		parse_ws_xml_cols(columns, cols);
	}

	var refguess = {s: {r:1000000, c:1000000}, e: {r:0, c:0} };

	/* 18.3.1.80 sheetData CT_SheetData ? */
	var mtch=data.match(sheetdataregex);
	if(mtch) parse_ws_xml_data(mtch[1], s, opts, refguess);

	/* 18.3.1.48 hyperlinks CT_Hyperlinks */
	if(data.indexOf(&quot;&lt;/hyperlinks&gt;&quot;)!==-1) parse_ws_xml_hlinks(s, data.match(hlinkregex), rels);

	if(!s[&quot;!ref&quot;] &amp;&amp; refguess.e.c &gt;= refguess.s.c &amp;&amp; refguess.e.r &gt;= refguess.s.r) s[&quot;!ref&quot;] = encode_range(refguess);
	if(opts.sheetRows &gt; 0 &amp;&amp; s[&quot;!ref&quot;]) {
		var tmpref = safe_decode_range(s[&quot;!ref&quot;]);
		if(opts.sheetRows &lt; +tmpref.e.r) {
			tmpref.e.r = opts.sheetRows - 1;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;
			s[&quot;!fullref&quot;] = s[&quot;!ref&quot;];
			s[&quot;!ref&quot;] = encode_range(tmpref);
		}
	}
	if(mergecells.length &gt; 0) s[&quot;!merges&quot;] = mergecells;
	if(columns.length &gt; 0) s[&quot;!cols&quot;] = columns;
	return s;
}

function write_ws_xml_merges(merges) {
	if(merges.length == 0) return &quot;&quot;;
	var o = &#x27;&lt;mergeCells count=&quot;&#x27; + merges.length + &#x27;&quot;&gt;&#x27;;
	for(var i = 0; i != merges.length; ++i) o += &#x27;&lt;mergeCell ref=&quot;&#x27; + encode_range(merges[i]) + &#x27;&quot;/&gt;&#x27;;
	return o + &#x27;&lt;/mergeCells&gt;&#x27;;
}

function parse_ws_xml_hlinks(s, data, rels) {
	for(var i = 0; i != data.length; ++i) {
		var val = parsexmltag(data[i], true);
		if(!val.ref) return;
		var rel = rels ? rels[&#x27;!id&#x27;][val.id] : null;
		if(rel) {
			val.Target = rel.Target;
			if(val.location) val.Target += &quot;#&quot;+val.location;
			val.Rel = rel;
		} else {
			val.Target = val.location;
			rel = {Target: val.location, TargetMode: &#x27;Internal&#x27;};
			val.Rel = rel;
		}
		var rng = safe_decode_range(val.ref);
		for(var R=rng.s.r;R&lt;=rng.e.r;++R) for(var C=rng.s.c;C&lt;=rng.e.c;++C) {
			var addr = encode_cell({c:C,r:R});
			if(!s[addr]) s[addr] = {t:&quot;stub&quot;,v:undefined};
			s[addr].l = val;
		}
	}
}

function parse_ws_xml_cols(columns, cols) {
	var seencol = false;
	for(var coli = 0; coli != cols.length; ++coli) {
		var coll = parsexmltag(cols[coli], true);
		var colm=parseInt(coll.min, 10)-1, colM=parseInt(coll.max,10)-1;
		delete coll.min; delete coll.max;
		if(!seencol &amp;&amp; coll.width) { seencol = true; find_mdw(+coll.width, coll); }
		if(coll.width) {
			coll.wpx = width2px(+coll.width);
			coll.wch = px2char(coll.wpx);
			coll.MDW = MDW;
		}
		while(colm &lt;= colM) columns[colm++] = coll;
	}
}

function write_ws_xml_cols(ws, cols) {
	var o = [&quot;&lt;cols&gt;&quot;], col, width;
	for(var i = 0; i != cols.length; ++i) {
		if(!(col = cols[i])) continue;
		var p = {min:i+1,max:i+1};
		/* wch (chars), wpx (pixels) */
		width = -1;
		if(col.wpx) width = px2char(col.wpx);
		else if(col.wch) width = col.wch;
		if(width &gt; -1) { p.width = char2width(width); p.customWidth= 1; }
		o[o.length] = (writextag(&#x27;col&#x27;, null, p));
	}
	o[o.length] = &quot;&lt;/cols&gt;&quot;;
	return o.join(&quot;&quot;);
}

function write_ws_xml_cell(cell, ref, ws, opts, idx, wb) {
	if(cell.v === undefined) return &quot;&quot;;
	var vv = &quot;&quot;;
	var oldt = cell.t, oldv = cell.v;
	switch(cell.t) {
		case &#x27;b&#x27;: vv = cell.v ? &quot;1&quot; : &quot;0&quot;; break;
		case &#x27;n&#x27;: vv = &#x27;&#x27;+cell.v; break;
		case &#x27;e&#x27;: vv = BErr[cell.v]; break;
		case &#x27;d&#x27;:
			if(opts.cellDates) vv = new Date(cell.v).toISOString();
			else {
				cell.t = &#x27;n&#x27;;
				vv = &#x27;&#x27;+(cell.v = datenum(cell.v));
				if(typeof cell.z === &#x27;undefined&#x27;) cell.z = SSF._table[14];
			}
			break;
		default: vv = cell.v; break;
	}
	var v = writetag(&#x27;v&#x27;, escapexml(vv)), o = {r:ref};
	/* TODO: cell style */
	var os = get_cell_style(opts.cellXfs, cell, opts);
	if(os !== 0) o.s = os;
	switch(cell.t) {
		case &#x27;n&#x27;: break;
		case &#x27;d&#x27;: o.t = &quot;d&quot;; break;
		case &#x27;b&#x27;: o.t = &quot;b&quot;; break;
		case &#x27;e&#x27;: o.t = &quot;e&quot;; break;
		default:
			if(opts.bookSST) {
				v = writetag(&#x27;v&#x27;, &#x27;&#x27;+get_sst_id(opts.Strings, cell.v));
				o.t = &quot;s&quot;; break;
			}
			o.t = &quot;str&quot;; break;
	}
	if(cell.t != oldt) { cell.t = oldt; cell.v = oldv; }
	return writextag(&#x27;c&#x27;, v, o);
}

var parse_ws_xml_data = (function parse_ws_xml_data_factory() {
	var cellregex = /&lt;(?:\w+:)?c[ &gt;]/, rowregex = /&lt;\/(?:\w+:)?row&gt;/;
	var rregex = /r=[&quot;&#x27;]([^&quot;&#x27;]*)[&quot;&#x27;]/, isregex = /&lt;is&gt;([\S\s]*?)&lt;\/is&gt;/;
	var match_v = matchtag(&quot;v&quot;), match_f = matchtag(&quot;f&quot;);

return function parse_ws_xml_data(sdata, s, opts, guess) {
	var ri = 0, x = &quot;&quot;, cells = [], cref = [], idx = 0, i=0, cc=0, d=&quot;&quot;, p;
	var tag, tagr = 0, tagc = 0;
	var sstr;
	var fmtid = 0, fillid = 0, do_format = Array.isArray(styles.CellXf), cf;
	for(var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
		x = marr[mt].trim();
		var xlen = x.length;
		if(xlen === 0) continue;

		/* 18.3.1.73 row CT_Row */
		for(ri = 0; ri &lt; xlen; ++ri) if(x.charCodeAt(ri) === 62) break; ++ri;
		tag = parsexmltag(x.substr(0,ri), true);
		/* SpreadSheetGear uses implicit r/c */
		tagr = typeof tag.r !== &#x27;undefined&#x27; ? parseInt(tag.r, 10) : tagr+1; tagc = -1;
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt; tagr) continue;
		if(guess.s.r &gt; tagr - 1) guess.s.r = tagr - 1;
		if(guess.e.r &lt; tagr - 1) guess.e.r = tagr - 1;

		/* 18.3.1.4 c CT_Cell */
		cells = x.substr(ri).split(cellregex);
		for(ri = typeof tag.r === &#x27;undefined&#x27; ? 0 : 1; ri != cells.length; ++ri) {
			x = cells[ri].trim();
			if(x.length === 0) continue;
			cref = x.match(rregex); idx = ri; i=0; cc=0;
			x = &quot;&lt;c &quot; + (x.substr(0,1)==&quot;&lt;&quot;?&quot;&gt;&quot;:&quot;&quot;) + x;
			if(cref !== null &amp;&amp; cref.length === 2) {
				idx = 0; d=cref[1];
				for(i=0; i != d.length; ++i) {
					if((cc=d.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;
					idx = 26*idx + cc;
				}
				--idx;
				tagc = idx;
			} else ++tagc;
			for(i = 0; i != x.length; ++i) if(x.charCodeAt(i) === 62) break; ++i;
			tag = parsexmltag(x.substr(0,i), true);
			if(!tag.r) tag.r = utils.encode_cell({r:tagr-1, c:tagc});
			d = x.substr(i);
			p = {t:&quot;&quot;};

			if((cref=d.match(match_v))!== null &amp;&amp; cref[1] !== &#x27;&#x27;) p.v=unescapexml(cref[1]);
			if(opts.cellFormula &amp;&amp; (cref=d.match(match_f))!== null) p.f=unescapexml(cref[1]);

			/* SCHEMA IS ACTUALLY INCORRECT HERE.  IF A CELL HAS NO T, EMIT &quot;&quot; */
			if(tag.t === undefined &amp;&amp; p.v === undefined) {
				if(!opts.sheetStubs) continue;
				p.t = &quot;stub&quot;;
			}
			else p.t = tag.t || &quot;n&quot;;
			if(guess.s.c &gt; idx) guess.s.c = idx;
			if(guess.e.c &lt; idx) guess.e.c = idx;
			/* 18.18.11 t ST_CellType */
			switch(p.t) {
				case &#x27;n&#x27;: p.v = parseFloat(p.v); break;
				case &#x27;s&#x27;:
					sstr = strs[parseInt(p.v, 10)];
					p.v = sstr.t;
					p.r = sstr.r;
					if(opts.cellHTML) p.h = sstr.h;
					break;
				case &#x27;str&#x27;:
					p.t = &quot;s&quot;;
					p.v = (p.v!=null) ? utf8read(p.v) : &#x27;&#x27;;
					if(opts.cellHTML) p.h = p.v;
					break;
				case &#x27;inlineStr&#x27;:
					cref = d.match(isregex);
					p.t = &#x27;s&#x27;;
					if(cref !== null) { sstr = parse_si(cref[1]); p.v = sstr.t; } else p.v = &quot;&quot;;
					break; // inline string
				case &#x27;b&#x27;: p.v = parsexmlbool(p.v); break;
				case &#x27;d&#x27;:
					if(!opts.cellDates) { p.v = datenum(p.v); p.t = &#x27;n&#x27;; }
					break;
				/* error string in .v, number in .v */
				case &#x27;e&#x27;: p.w = p.v; p.v = RBErr[p.v]; break;
			}
			/* formatting */
			fmtid = fillid = 0;
			if(do_format &amp;&amp; tag.s !== undefined) {
				cf = styles.CellXf[tag.s];
				if(cf != null) {
					if(cf.numFmtId != null) fmtid = cf.numFmtId;
					if(opts.cellStyles &amp;&amp; cf.fillId != null) fillid = cf.fillId;
				}
			}
			safe_format(p, fmtid, fillid, opts);
			s[tag.r] = p;
		}
	}
}; })();

function write_ws_xml_data(ws, opts, idx, wb) {
	var o = [], r = [], range = safe_decode_range(ws[&#x27;!ref&#x27;]), cell, ref, rr = &quot;&quot;, cols = [], R, C;
	for(C = range.s.c; C &lt;= range.e.c; ++C) cols[C] = encode_col(C);
	for(R = range.s.r; R &lt;= range.e.r; ++R) {
		r = [];
		rr = encode_row(R);
		for(C = range.s.c; C &lt;= range.e.c; ++C) {
			ref = cols[C] + rr;
			if(ws[ref] === undefined) continue;
			if((cell = write_ws_xml_cell(ws[ref], ref, ws, opts, idx, wb)) != null) r.push(cell);
		}
		if(r.length &gt; 0) o[o.length] = (writextag(&#x27;row&#x27;, r.join(&quot;&quot;), {r:rr}));
	}
	return o.join(&quot;&quot;);
}

var WS_XML_ROOT = writextag(&#x27;worksheet&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.main[0],
	&#x27;xmlns:r&#x27;: XMLNS.r
});

function write_ws_xml(idx, opts, wb) {
	var o = [XML_HEADER, WS_XML_ROOT];
	var s = wb.SheetNames[idx], sidx = 0, rdata = &quot;&quot;;
	var ws = wb.Sheets[s];
	if(ws === undefined) ws = {};
	var ref = ws[&#x27;!ref&#x27;]; if(ref === undefined) ref = &#x27;A1&#x27;;
	o[o.length] = (writextag(&#x27;dimension&#x27;, null, {&#x27;ref&#x27;: ref}));

	if(ws[&#x27;!cols&#x27;] !== undefined &amp;&amp; ws[&#x27;!cols&#x27;].length &gt; 0) o[o.length] = (write_ws_xml_cols(ws, ws[&#x27;!cols&#x27;]));
	o[sidx = o.length] = &#x27;&lt;sheetData/&gt;&#x27;;
	if(ws[&#x27;!ref&#x27;] !== undefined) {
		rdata = write_ws_xml_data(ws, opts, idx, wb);
		if(rdata.length &gt; 0) o[o.length] = (rdata);
	}
	if(o.length&gt;sidx+1) { o[o.length] = (&#x27;&lt;/sheetData&gt;&#x27;); o[sidx]=o[sidx].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }

	if(ws[&#x27;!merges&#x27;] !== undefined &amp;&amp; ws[&#x27;!merges&#x27;].length &gt; 0) o[o.length] = (write_ws_xml_merges(ws[&#x27;!merges&#x27;]));

	if(o.length&gt;2) { o[o.length] = (&#x27;&lt;/worksheet&gt;&#x27;); o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}

/* [MS-XLSB] 2.4.718 BrtRowHdr */
function parse_BrtRowHdr(data, length) {
	var z = [];
	z.r = data.read_shift(4);
	data.l += length-4;
	return z;
}

/* [MS-XLSB] 2.4.812 BrtWsDim */
var parse_BrtWsDim = parse_UncheckedRfX;
var write_BrtWsDim = write_UncheckedRfX;

/* [MS-XLSB] 2.4.815 BrtWsProp */
function parse_BrtWsProp(data, length) {
	var z = {};
	/* TODO: pull flags */
	data.l += 19;
	z.name = parse_XLSBCodeName(data, length - 19);
	return z;
}

/* [MS-XLSB] 2.4.303 BrtCellBlank */
function parse_BrtCellBlank(data, length) {
	var cell = parse_XLSBCell(data);
	return [cell];
}
function write_BrtCellBlank(cell, val, o) {
	if(o == null) o = new_buf(8);
	return write_XLSBCell(val, o);
}


/* [MS-XLSB] 2.4.304 BrtCellBool */
function parse_BrtCellBool(data, length) {
	var cell = parse_XLSBCell(data);
	var fBool = data.read_shift(1);
	return [cell, fBool, &#x27;b&#x27;];
}

/* [MS-XLSB] 2.4.305 BrtCellError */
function parse_BrtCellError(data, length) {
	var cell = parse_XLSBCell(data);
	var fBool = data.read_shift(1);
	return [cell, fBool, &#x27;e&#x27;];
}

/* [MS-XLSB] 2.4.308 BrtCellIsst */
function parse_BrtCellIsst(data, length) {
	var cell = parse_XLSBCell(data);
	var isst = data.read_shift(4);
	return [cell, isst, &#x27;s&#x27;];
}

/* [MS-XLSB] 2.4.310 BrtCellReal */
function parse_BrtCellReal(data, length) {
	var cell = parse_XLSBCell(data);
	var value = parse_Xnum(data);
	return [cell, value, &#x27;n&#x27;];
}

/* [MS-XLSB] 2.4.311 BrtCellRk */
function parse_BrtCellRk(data, length) {
	var cell = parse_XLSBCell(data);
	var value = parse_RkNumber(data);
	return [cell, value, &#x27;n&#x27;];
}

/* [MS-XLSB] 2.4.314 BrtCellSt */
function parse_BrtCellSt(data, length) {
	var cell = parse_XLSBCell(data);
	var value = parse_XLWideString(data);
	return [cell, value, &#x27;str&#x27;];
}

/* [MS-XLSB] 2.4.647 BrtFmlaBool */
function parse_BrtFmlaBool(data, length, opts) {
	var cell = parse_XLSBCell(data);
	var value = data.read_shift(1);
	var o = [cell, value, &#x27;b&#x27;];
	if(opts.cellFormula) {
		var formula = parse_XLSBCellParsedFormula(data, length-9);
		o[3] = &quot;&quot;; /* TODO */
	}
	else data.l += length-9;
	return o;
}

/* [MS-XLSB] 2.4.648 BrtFmlaError */
function parse_BrtFmlaError(data, length, opts) {
	var cell = parse_XLSBCell(data);
	var value = data.read_shift(1);
	var o = [cell, value, &#x27;e&#x27;];
	if(opts.cellFormula) {
		var formula = parse_XLSBCellParsedFormula(data, length-9);
		o[3] = &quot;&quot;; /* TODO */
	}
	else data.l += length-9;
	return o;
}

/* [MS-XLSB] 2.4.649 BrtFmlaNum */
function parse_BrtFmlaNum(data, length, opts) {
	var cell = parse_XLSBCell(data);
	var value = parse_Xnum(data);
	var o = [cell, value, &#x27;n&#x27;];
	if(opts.cellFormula) {
		var formula = parse_XLSBCellParsedFormula(data, length - 16);
		o[3] = &quot;&quot;; /* TODO */
	}
	else data.l += length-16;
	return o;
}

/* [MS-XLSB] 2.4.650 BrtFmlaString */
function parse_BrtFmlaString(data, length, opts) {
	var start = data.l;
	var cell = parse_XLSBCell(data);
	var value = parse_XLWideString(data);
	var o = [cell, value, &#x27;str&#x27;];
	if(opts.cellFormula) {
		var formula = parse_XLSBCellParsedFormula(data, start + length - data.l);
	}
	else data.l = start + length;
	return o;
}

/* [MS-XLSB] 2.4.676 BrtMergeCell */
var parse_BrtMergeCell = parse_UncheckedRfX;

/* [MS-XLSB] 2.4.656 BrtHLink */
function parse_BrtHLink(data, length, opts) {
	var end = data.l + length;
	var rfx = parse_UncheckedRfX(data, 16);
	var relId = parse_XLNullableWideString(data);
	var loc = parse_XLWideString(data);
	var tooltip = parse_XLWideString(data);
	var display = parse_XLWideString(data);
	data.l = end;
	return {rfx:rfx, relId:relId, loc:loc, tooltip:tooltip, display:display};
}

/* [MS-XLSB] 2.1.7.61 Worksheet */
function parse_ws_bin(data, opts, rels) {
	if(!data) return data;
	if(!rels) rels = {&#x27;!id&#x27;:{}};
	var s = {};

	var ref;
	var refguess = {s: {r:1000000, c:1000000}, e: {r:0, c:0} };

	var pass = false, end = false;
	var row, p, cf, R, C, addr, sstr, rr;
	var mergecells = [];
	recordhopper(data, function ws_parse(val, R) {
		if(end) return;
		switch(R.n) {
			case &#x27;BrtWsDim&#x27;: ref = val; break;
			case &#x27;BrtRowHdr&#x27;:
				row = val;
				if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= row.r) end=true;
				rr = encode_row(row.r);
				break;

			case &#x27;BrtFmlaBool&#x27;:
			case &#x27;BrtFmlaError&#x27;:
			case &#x27;BrtFmlaNum&#x27;:
			case &#x27;BrtFmlaString&#x27;:
			case &#x27;BrtCellBool&#x27;:
			case &#x27;BrtCellError&#x27;:
			case &#x27;BrtCellIsst&#x27;:
			case &#x27;BrtCellReal&#x27;:
			case &#x27;BrtCellRk&#x27;:
			case &#x27;BrtCellSt&#x27;:
				p = {t:val[2]};
				switch(val[2]) {
					case &#x27;n&#x27;: p.v = val[1]; break;
					case &#x27;s&#x27;: sstr = strs[val[1]]; p.v = sstr.t; p.r = sstr.r; break;
					case &#x27;b&#x27;: p.v = val[1] ? true : false; break;
					case &#x27;e&#x27;: p.v = val[1]; p.w = BErr[p.v]; break;
					case &#x27;str&#x27;: p.t = &#x27;s&#x27;; p.v = utf8read(val[1]); break;
				}
				if(opts.cellFormula &amp;&amp; val.length &gt; 3) p.f = val[3];
				if((cf = styles.CellXf[val[0].iStyleRef])) safe_format(p,cf.ifmt,null,opts);
				s[encode_col(C=val[0].c) + rr] = p;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;
				if(refguess.s.c &gt; C) refguess.s.c = C;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;
				if(refguess.e.c &lt; C) refguess.e.c = C;
				break;

			case &#x27;BrtCellBlank&#x27;: if(!opts.sheetStubs) break;
				p = {t:&#x27;s&#x27;,v:undefined};
				s[encode_col(C=val[0].c) + rr] = p;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;
				if(refguess.s.c &gt; C) refguess.s.c = C;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;
				if(refguess.e.c &lt; C) refguess.e.c = C;
				break;

			/* Merge Cells */
			case &#x27;BrtBeginMergeCells&#x27;: break;
			case &#x27;BrtEndMergeCells&#x27;: break;
			case &#x27;BrtMergeCell&#x27;: mergecells.push(val); break;

			case &#x27;BrtHLink&#x27;:
				var rel = rels[&#x27;!id&#x27;][val.relId];
				if(rel) {
					val.Target = rel.Target;
					if(val.loc) val.Target += &quot;#&quot;+val.loc;
					val.Rel = rel;
				}
				for(R=val.rfx.s.r;R&lt;=val.rfx.e.r;++R) for(C=val.rfx.s.c;C&lt;=val.rfx.e.c;++C) {
					addr = encode_cell({c:C,r:R});
					if(!s[addr]) s[addr] = {t:&#x27;s&#x27;,v:undefined};
					s[addr].l = val;
				}
				break;

			case &#x27;BrtArrFmla&#x27;: break; // TODO
			case &#x27;BrtShrFmla&#x27;: break; // TODO
			case &#x27;BrtBeginSheet&#x27;: break;
			case &#x27;BrtWsProp&#x27;: break; // TODO
			case &#x27;BrtSheetCalcProp&#x27;: break; // TODO
			case &#x27;BrtBeginWsViews&#x27;: break; // TODO
			case &#x27;BrtBeginWsView&#x27;: break; // TODO
			case &#x27;BrtPane&#x27;: break; // TODO
			case &#x27;BrtSel&#x27;: break; // TODO
			case &#x27;BrtEndWsView&#x27;: break; // TODO
			case &#x27;BrtEndWsViews&#x27;: break; // TODO
			case &#x27;BrtACBegin&#x27;: break; // TODO
			case &#x27;BrtRwDescent&#x27;: break; // TODO
			case &#x27;BrtACEnd&#x27;: break; // TODO
			case &#x27;BrtWsFmtInfoEx14&#x27;: break; // TODO
			case &#x27;BrtWsFmtInfo&#x27;: break; // TODO
			case &#x27;BrtBeginColInfos&#x27;: break; // TODO
			case &#x27;BrtColInfo&#x27;: break; // TODO
			case &#x27;BrtEndColInfos&#x27;: break; // TODO
			case &#x27;BrtBeginSheetData&#x27;: break; // TODO
			case &#x27;BrtEndSheetData&#x27;: break; // TODO
			case &#x27;BrtSheetProtection&#x27;: break; // TODO
			case &#x27;BrtPrintOptions&#x27;: break; // TODO
			case &#x27;BrtMargins&#x27;: break; // TODO
			case &#x27;BrtPageSetup&#x27;: break; // TODO
			case &#x27;BrtFRTBegin&#x27;: pass = true; break;
			case &#x27;BrtFRTEnd&#x27;: pass = false; break;
			case &#x27;BrtEndSheet&#x27;: break; // TODO
			case &#x27;BrtDrawing&#x27;: break; // TODO
			case &#x27;BrtLegacyDrawing&#x27;: break; // TODO
			case &#x27;BrtLegacyDrawingHF&#x27;: break; // TODO
			case &#x27;BrtPhoneticInfo&#x27;: break; // TODO
			case &#x27;BrtBeginHeaderFooter&#x27;: break; // TODO
			case &#x27;BrtEndHeaderFooter&#x27;: break; // TODO
			case &#x27;BrtBrk&#x27;: break; // TODO
			case &#x27;BrtBeginRwBrk&#x27;: break; // TODO
			case &#x27;BrtEndRwBrk&#x27;: break; // TODO
			case &#x27;BrtBeginColBrk&#x27;: break; // TODO
			case &#x27;BrtEndColBrk&#x27;: break; // TODO
			case &#x27;BrtBeginUserShViews&#x27;: break; // TODO
			case &#x27;BrtBeginUserShView&#x27;: break; // TODO
			case &#x27;BrtEndUserShView&#x27;: break; // TODO
			case &#x27;BrtEndUserShViews&#x27;: break; // TODO
			case &#x27;BrtBkHim&#x27;: break; // TODO
			case &#x27;BrtBeginOleObjects&#x27;: break; // TODO
			case &#x27;BrtOleObject&#x27;: break; // TODO
			case &#x27;BrtEndOleObjects&#x27;: break; // TODO
			case &#x27;BrtBeginListParts&#x27;: break; // TODO
			case &#x27;BrtListPart&#x27;: break; // TODO
			case &#x27;BrtEndListParts&#x27;: break; // TODO
			case &#x27;BrtBeginSortState&#x27;: break; // TODO
			case &#x27;BrtBeginSortCond&#x27;: break; // TODO
			case &#x27;BrtEndSortCond&#x27;: break; // TODO
			case &#x27;BrtEndSortState&#x27;: break; // TODO
			case &#x27;BrtBeginConditionalFormatting&#x27;: break; // TODO
			case &#x27;BrtEndConditionalFormatting&#x27;: break; // TODO
			case &#x27;BrtBeginCFRule&#x27;: break; // TODO
			case &#x27;BrtEndCFRule&#x27;: break; // TODO
			case &#x27;BrtBeginDVals&#x27;: break; // TODO
			case &#x27;BrtDVal&#x27;: break; // TODO
			case &#x27;BrtEndDVals&#x27;: break; // TODO
			case &#x27;BrtRangeProtection&#x27;: break; // TODO
			case &#x27;BrtBeginDCon&#x27;: break; // TODO
			case &#x27;BrtEndDCon&#x27;: break; // TODO
			case &#x27;BrtBeginDRefs&#x27;: break;
			case &#x27;BrtDRef&#x27;: break;
			case &#x27;BrtEndDRefs&#x27;: break;

			/* ActiveX */
			case &#x27;BrtBeginActiveXControls&#x27;: break;
			case &#x27;BrtActiveX&#x27;: break;
			case &#x27;BrtEndActiveXControls&#x27;: break;

			/* AutoFilter */
			case &#x27;BrtBeginAFilter&#x27;: break;
			case &#x27;BrtEndAFilter&#x27;: break;
			case &#x27;BrtBeginFilterColumn&#x27;: break;
			case &#x27;BrtBeginFilters&#x27;: break;
			case &#x27;BrtFilter&#x27;: break;
			case &#x27;BrtEndFilters&#x27;: break;
			case &#x27;BrtEndFilterColumn&#x27;: break;
			case &#x27;BrtDynamicFilter&#x27;: break;
			case &#x27;BrtTop10Filter&#x27;: break;
			case &#x27;BrtBeginCustomFilters&#x27;: break;
			case &#x27;BrtCustomFilter&#x27;: break;
			case &#x27;BrtEndCustomFilters&#x27;: break;

			/* Smart Tags */
			case &#x27;BrtBeginSmartTags&#x27;: break;
			case &#x27;BrtBeginCellSmartTags&#x27;: break;
			case &#x27;BrtBeginCellSmartTag&#x27;: break;
			case &#x27;BrtCellSmartTagProperty&#x27;: break;
			case &#x27;BrtEndCellSmartTag&#x27;: break;
			case &#x27;BrtEndCellSmartTags&#x27;: break;
			case &#x27;BrtEndSmartTags&#x27;: break;

			/* Cell Watch */
			case &#x27;BrtBeginCellWatches&#x27;: break;
			case &#x27;BrtCellWatch&#x27;: break;
			case &#x27;BrtEndCellWatches&#x27;: break;

			/* Table */
			case &#x27;BrtTable&#x27;: break;

			/* Ignore Cell Errors */
			case &#x27;BrtBeginCellIgnoreECs&#x27;: break;
			case &#x27;BrtCellIgnoreEC&#x27;: break;
			case &#x27;BrtEndCellIgnoreECs&#x27;: break;

			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + R.n);
		}
	}, opts);
	if(!s[&quot;!ref&quot;] &amp;&amp; (refguess.s.r &lt; 1000000 || ref.e.r &gt; 0 || ref.e.c &gt; 0 || ref.s.r &gt; 0 || ref.s.c &gt; 0)) s[&quot;!ref&quot;] = encode_range(ref);
	if(opts.sheetRows &amp;&amp; s[&quot;!ref&quot;]) {
		var tmpref = safe_decode_range(s[&quot;!ref&quot;]);
		if(opts.sheetRows &lt; +tmpref.e.r) {
			tmpref.e.r = opts.sheetRows - 1;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;
			s[&quot;!fullref&quot;] = s[&quot;!ref&quot;];
			s[&quot;!ref&quot;] = encode_range(tmpref);
		}
	}
	if(mergecells.length &gt; 0) s[&quot;!merges&quot;] = mergecells;
	return s;
}

/* TODO: something useful -- this is a stub */
function write_ws_bin_cell(ba, cell, R, C, opts) {
	if(cell.v === undefined) return &quot;&quot;;
	var vv = &quot;&quot;;
	switch(cell.t) {
		case &#x27;b&#x27;: vv = cell.v ? &quot;1&quot; : &quot;0&quot;; break;
		case &#x27;n&#x27;: case &#x27;e&#x27;: vv = &#x27;&#x27;+cell.v; break;
		default: vv = cell.v; break;
	}
	var o = {r:R, c:C};
	/* TODO: cell style */
	o.s = get_cell_style(opts.cellXfs, cell, opts);
	switch(cell.t) {
		case &#x27;s&#x27;: case &#x27;str&#x27;:
			if(opts.bookSST) {
				vv = get_sst_id(opts.Strings, cell.v);
				o.t = &quot;s&quot;; break;
			}
			o.t = &quot;str&quot;; break;
		case &#x27;n&#x27;: break;
		case &#x27;b&#x27;: o.t = &quot;b&quot;; break;
		case &#x27;e&#x27;: o.t = &quot;e&quot;; break;
	}
	write_record(ba, &quot;BrtCellBlank&quot;, write_BrtCellBlank(cell, o));
}

function write_CELLTABLE(ba, ws, idx, opts, wb) {
	var range = safe_decode_range(ws[&#x27;!ref&#x27;] || &quot;A1&quot;), ref, rr = &quot;&quot;, cols = [];
	write_record(ba, &#x27;BrtBeginSheetData&#x27;);
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {
		rr = encode_row(R);
		/* [ACCELLTABLE] */
		/* BrtRowHdr */
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {
			/* *16384CELL */
			if(R === range.s.r) cols[C] = encode_col(C);
			ref = cols[C] + rr;
			if(!ws[ref]) continue;
			/* write cell */
			write_ws_bin_cell(ba, ws[ref], R, C, opts);
		}
	}
	write_record(ba, &#x27;BrtEndSheetData&#x27;);
}

function write_ws_bin(idx, opts, wb) {
	var ba = buf_array();
	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
	var r = safe_decode_range(ws[&#x27;!ref&#x27;] || &quot;A1&quot;);
	write_record(ba, &quot;BrtBeginSheet&quot;);
	/* [BrtWsProp] */
	write_record(ba, &quot;BrtWsDim&quot;, write_BrtWsDim(r));
	/* [WSVIEWS2] */
	/* [WSFMTINFO] */
	/* *COLINFOS */
	write_CELLTABLE(ba, ws, idx, opts, wb);
	/* [BrtSheetCalcProp] */
	/* [[BrtSheetProtectionIso] BrtSheetProtection] */
	/* *([BrtRangeProtectionIso] BrtRangeProtection) */
	/* [SCENMAN] */
	/* [AUTOFILTER] */
	/* [SORTSTATE] */
	/* [DCON] */
	/* [USERSHVIEWS] */
	/* [MERGECELLS] */
	/* [BrtPhoneticInfo] */
	/* *CONDITIONALFORMATTING */
	/* [DVALS] */
	/* *BrtHLink */
	/* [BrtPrintOptions] */
	/* [BrtMargins] */
	/* [BrtPageSetup] */
	/* [HEADERFOOTER] */
	/* [RWBRK] */
	/* [COLBRK] */
	/* *BrtBigName */
	/* [CELLWATCHES] */
	/* [IGNOREECS] */
	/* [SMARTTAGS] */
	/* [BrtDrawing] */
	/* [BrtLegacyDrawing] */
	/* [BrtLegacyDrawingHF] */
	/* [BrtBkHim] */
	/* [OLEOBJECTS] */
	/* [ACTIVEXCONTROLS] */
	/* [WEBPUBITEMS] */
	/* [LISTPARTS] */
	/* FRTWORKSHEET */
	write_record(ba, &quot;BrtEndSheet&quot;);
	return ba.end();
}
/* 18.2.28 (CT_WorkbookProtection) Defaults */
var WBPropsDef = [
	[&#x27;allowRefreshQuery&#x27;, &#x27;0&#x27;],
	[&#x27;autoCompressPictures&#x27;, &#x27;1&#x27;],
	[&#x27;backupFile&#x27;, &#x27;0&#x27;],
	[&#x27;checkCompatibility&#x27;, &#x27;0&#x27;],
	[&#x27;codeName&#x27;, &#x27;&#x27;],
	[&#x27;date1904&#x27;, &#x27;0&#x27;],
	[&#x27;dateCompatibility&#x27;, &#x27;1&#x27;],
	//[&#x27;defaultThemeVersion&#x27;, &#x27;0&#x27;],
	[&#x27;filterPrivacy&#x27;, &#x27;0&#x27;],
	[&#x27;hidePivotFieldList&#x27;, &#x27;0&#x27;],
	[&#x27;promptedSolutions&#x27;, &#x27;0&#x27;],
	[&#x27;publishItems&#x27;, &#x27;0&#x27;],
	[&#x27;refreshAllConnections&#x27;, false],
	[&#x27;saveExternalLinkValues&#x27;, &#x27;1&#x27;],
	[&#x27;showBorderUnselectedTables&#x27;, &#x27;1&#x27;],
	[&#x27;showInkAnnotation&#x27;, &#x27;1&#x27;],
	[&#x27;showObjects&#x27;, &#x27;all&#x27;],
	[&#x27;showPivotChartFilter&#x27;, &#x27;0&#x27;]
	//[&#x27;updateLinks&#x27;, &#x27;userSet&#x27;]
];

/* 18.2.30 (CT_BookView) Defaults */
var WBViewDef = [
	[&#x27;activeTab&#x27;, &#x27;0&#x27;],
	[&#x27;autoFilterDateGrouping&#x27;, &#x27;1&#x27;],
	[&#x27;firstSheet&#x27;, &#x27;0&#x27;],
	[&#x27;minimized&#x27;, &#x27;0&#x27;],
	[&#x27;showHorizontalScroll&#x27;, &#x27;1&#x27;],
	[&#x27;showSheetTabs&#x27;, &#x27;1&#x27;],
	[&#x27;showVerticalScroll&#x27;, &#x27;1&#x27;],
	[&#x27;tabRatio&#x27;, &#x27;600&#x27;],
	[&#x27;visibility&#x27;, &#x27;visible&#x27;]
	//window{Height,Width}, {x,y}Window
];

/* 18.2.19 (CT_Sheet) Defaults */
var SheetDef = [
	[&#x27;state&#x27;, &#x27;visible&#x27;]
];

/* 18.2.2  (CT_CalcPr) Defaults */
var CalcPrDef = [
	[&#x27;calcCompleted&#x27;, &#x27;true&#x27;],
	[&#x27;calcMode&#x27;, &#x27;auto&#x27;],
	[&#x27;calcOnSave&#x27;, &#x27;true&#x27;],
	[&#x27;concurrentCalc&#x27;, &#x27;true&#x27;],
	[&#x27;fullCalcOnLoad&#x27;, &#x27;false&#x27;],
	[&#x27;fullPrecision&#x27;, &#x27;true&#x27;],
	[&#x27;iterate&#x27;, &#x27;false&#x27;],
	[&#x27;iterateCount&#x27;, &#x27;100&#x27;],
	[&#x27;iterateDelta&#x27;, &#x27;0.001&#x27;],
	[&#x27;refMode&#x27;, &#x27;A1&#x27;]
];

/* 18.2.3 (CT_CustomWorkbookView) Defaults */
var CustomWBViewDef = [
	[&#x27;autoUpdate&#x27;, &#x27;false&#x27;],
	[&#x27;changesSavedWin&#x27;, &#x27;false&#x27;],
	[&#x27;includeHiddenRowCol&#x27;, &#x27;true&#x27;],
	[&#x27;includePrintSettings&#x27;, &#x27;true&#x27;],
	[&#x27;maximized&#x27;, &#x27;false&#x27;],
	[&#x27;minimized&#x27;, &#x27;false&#x27;],
	[&#x27;onlySync&#x27;, &#x27;false&#x27;],
	[&#x27;personalView&#x27;, &#x27;false&#x27;],
	[&#x27;showComments&#x27;, &#x27;commIndicator&#x27;],
	[&#x27;showFormulaBar&#x27;, &#x27;true&#x27;],
	[&#x27;showHorizontalScroll&#x27;, &#x27;true&#x27;],
	[&#x27;showObjects&#x27;, &#x27;all&#x27;],
	[&#x27;showSheetTabs&#x27;, &#x27;true&#x27;],
	[&#x27;showStatusbar&#x27;, &#x27;true&#x27;],
	[&#x27;showVerticalScroll&#x27;, &#x27;true&#x27;],
	[&#x27;tabRatio&#x27;, &#x27;600&#x27;],
	[&#x27;xWindow&#x27;, &#x27;0&#x27;],
	[&#x27;yWindow&#x27;, &#x27;0&#x27;]
];

function push_defaults_array(target, defaults) {
	for(var j = 0; j != target.length; ++j) { var w = target[j];
		for(var i=0; i != defaults.length; ++i) { var z = defaults[i];
			if(w[z[0]] == null) w[z[0]] = z[1];
		}
	}
}
function push_defaults(target, defaults) {
	for(var i = 0; i != defaults.length; ++i) { var z = defaults[i];
		if(target[z[0]] == null) target[z[0]] = z[1];
	}
}

function parse_wb_defaults(wb) {
	push_defaults(wb.WBProps, WBPropsDef);
	push_defaults(wb.CalcPr, CalcPrDef);

	push_defaults_array(wb.WBView, WBViewDef);
	push_defaults_array(wb.Sheets, SheetDef);

	_ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904, &#x27;date1904&#x27;);
}
/* 18.2 Workbook */
var wbnsregex = /&lt;\w+:workbook/;
function parse_wb_xml(data, opts) {
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, xmlns: &quot;&quot; };
	var pass = false, xmlns = &quot;xmlns&quot;;
	data.match(tagregex).forEach(function xml_wb(x) {
		var y = parsexmltag(x);
		switch(strip_ns(y[0])) {
			case &#x27;&lt;?xml&#x27;: break;

			/* 18.2.27 workbook CT_Workbook 1 */
			case &#x27;&lt;workbook&#x27;:
				if(x.match(wbnsregex)) xmlns = &quot;xmlns&quot; + x.match(/&lt;(\w+):/)[1];
				wb.xmlns = y[xmlns];
				break;
			case &#x27;&lt;/workbook&gt;&#x27;: break;

			/* 18.2.13 fileVersion CT_FileVersion ? */
			case &#x27;&lt;fileVersion&#x27;: delete y[0]; wb.AppVersion = y; break;
			case &#x27;&lt;fileVersion/&gt;&#x27;: break;

			/* 18.2.12 fileSharing CT_FileSharing ? */
			case &#x27;&lt;fileSharing&#x27;: case &#x27;&lt;fileSharing/&gt;&#x27;: break;

			/* 18.2.28 workbookPr CT_WorkbookPr ? */
			case &#x27;&lt;workbookPr&#x27;: delete y[0]; wb.WBProps = y; break;
			case &#x27;&lt;workbookPr/&gt;&#x27;: delete y[0]; wb.WBProps = y; break;

			/* 18.2.29 workbookProtection CT_WorkbookProtection ? */
			case &#x27;&lt;workbookProtection&#x27;: break;
			case &#x27;&lt;workbookProtection/&gt;&#x27;: break;

			/* 18.2.1  bookViews CT_BookViews ? */
			case &#x27;&lt;bookViews&gt;&#x27;: case &#x27;&lt;/bookViews&gt;&#x27;: break;
			/* 18.2.30   workbookView CT_BookView + */
			case &#x27;&lt;workbookView&#x27;: delete y[0]; wb.WBView.push(y); break;

			/* 18.2.20 sheets CT_Sheets 1 */
			case &#x27;&lt;sheets&gt;&#x27;: case &#x27;&lt;/sheets&gt;&#x27;: break; // aggregate sheet
			/* 18.2.19   sheet CT_Sheet + */
			case &#x27;&lt;sheet&#x27;: delete y[0]; y.name = utf8read(y.name); wb.Sheets.push(y); break;

			/* 18.2.15 functionGroups CT_FunctionGroups ? */
			case &#x27;&lt;functionGroups&#x27;: case &#x27;&lt;functionGroups/&gt;&#x27;: break;
			/* 18.2.14   functionGroup CT_FunctionGroup + */
			case &#x27;&lt;functionGroup&#x27;: break;

			/* 18.2.9  externalReferences CT_ExternalReferences ? */
			case &#x27;&lt;externalReferences&#x27;: case &#x27;&lt;/externalReferences&gt;&#x27;: case &#x27;&lt;externalReferences&gt;&#x27;: break;
			/* 18.2.8    externalReference CT_ExternalReference + */
			case &#x27;&lt;externalReference&#x27;: break;

			/* 18.2.6  definedNames CT_DefinedNames ? */
			case &#x27;&lt;definedNames/&gt;&#x27;: break;
			case &#x27;&lt;definedNames&gt;&#x27;: case &#x27;&lt;definedNames&#x27;: pass=true; break;
			case &#x27;&lt;/definedNames&gt;&#x27;: pass=false; break;
			/* 18.2.5    definedName CT_DefinedName + */
			case &#x27;&lt;definedName&#x27;: case &#x27;&lt;definedName/&gt;&#x27;: case &#x27;&lt;/definedName&gt;&#x27;: break;

			/* 18.2.2  calcPr CT_CalcPr ? */
			case &#x27;&lt;calcPr&#x27;: delete y[0]; wb.CalcPr = y; break;
			case &#x27;&lt;calcPr/&gt;&#x27;: delete y[0]; wb.CalcPr = y; break;

			/* 18.2.16 oleSize CT_OleSize ? (ref required) */
			case &#x27;&lt;oleSize&#x27;: break;

			/* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */
			case &#x27;&lt;customWorkbookViews&gt;&#x27;: case &#x27;&lt;/customWorkbookViews&gt;&#x27;: case &#x27;&lt;customWorkbookViews&#x27;: break;
			/* 18.2.3    customWorkbookView CT_CustomWorkbookView + */
			case &#x27;&lt;customWorkbookView&#x27;: case &#x27;&lt;/customWorkbookView&gt;&#x27;: break;

			/* 18.2.18 pivotCaches CT_PivotCaches ? */
			case &#x27;&lt;pivotCaches&gt;&#x27;: case &#x27;&lt;/pivotCaches&gt;&#x27;: case &#x27;&lt;pivotCaches&#x27;: break;
			/* 18.2.17 pivotCache CT_PivotCache ? */
			case &#x27;&lt;pivotCache&#x27;: break;

			/* 18.2.21 smartTagPr CT_SmartTagPr ? */
			case &#x27;&lt;smartTagPr&#x27;: case &#x27;&lt;smartTagPr/&gt;&#x27;: break;

			/* 18.2.23 smartTagTypes CT_SmartTagTypes ? */
			case &#x27;&lt;smartTagTypes&#x27;: case &#x27;&lt;smartTagTypes&gt;&#x27;: case &#x27;&lt;/smartTagTypes&gt;&#x27;: break;
			/* 18.2.22   smartTagType CT_SmartTagType ? */
			case &#x27;&lt;smartTagType&#x27;: break;

			/* 18.2.24 webPublishing CT_WebPublishing ? */
			case &#x27;&lt;webPublishing&#x27;: case &#x27;&lt;webPublishing/&gt;&#x27;: break;

			/* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */
			case &#x27;&lt;fileRecoveryPr&#x27;: case &#x27;&lt;fileRecoveryPr/&gt;&#x27;: break;

			/* 18.2.26 webPublishObjects CT_WebPublishObjects ? */
			case &#x27;&lt;webPublishObjects&gt;&#x27;: case &#x27;&lt;webPublishObjects&#x27;: case &#x27;&lt;/webPublishObjects&gt;&#x27;: break;
			/* 18.2.25 webPublishObject CT_WebPublishObject ? */
			case &#x27;&lt;webPublishObject&#x27;: break;

			/* 18.2.10 extLst CT_ExtensionList ? */
			case &#x27;&lt;extLst&gt;&#x27;: case &#x27;&lt;/extLst&gt;&#x27;: case &#x27;&lt;extLst/&gt;&#x27;: break;
			/* 18.2.7    ext CT_Extension + */
			case &#x27;&lt;ext&#x27;: pass=true; break; //TODO: check with versions of excel
			case &#x27;&lt;/ext&gt;&#x27;: pass=false; break;

			/* Others */
			case &#x27;&lt;ArchID&#x27;: break;
			case &#x27;&lt;AlternateContent&#x27;: pass=true; break;
			case &#x27;&lt;/AlternateContent&gt;&#x27;: pass=false; break;

			default: if(!pass &amp;&amp; opts.WTF) throw &#x27;unrecognized &#x27; + y[0] + &#x27; in workbook&#x27;;
		}
	});
	if(XMLNS.main.indexOf(wb.xmlns) === -1) throw new Error(&quot;Unknown Namespace: &quot; + wb.xmlns);

	parse_wb_defaults(wb);

	return wb;
}

var WB_XML_ROOT = writextag(&#x27;workbook&#x27;, null, {
	&#x27;xmlns&#x27;: XMLNS.main[0],
	//&#x27;xmlns:mx&#x27;: XMLNS.mx,
	//&#x27;xmlns:s&#x27;: XMLNS.main[0],
	&#x27;xmlns:r&#x27;: XMLNS.r
});

function safe1904(wb) {
	/* TODO: store date1904 somewhere else */
	try { return parsexmlbool(wb.Workbook.WBProps.date1904) ? &quot;true&quot; : &quot;false&quot;; } catch(e) { return &quot;false&quot;; }
}

function write_wb_xml(wb, opts) {
	var o = [XML_HEADER];
	o[o.length] = WB_XML_ROOT;
	o[o.length] = (writextag(&#x27;workbookPr&#x27;, null, {date1904:safe1904(wb)}));
	o[o.length] = &quot;&lt;sheets&gt;&quot;;
	for(var i = 0; i != wb.SheetNames.length; ++i)
		o[o.length] = (writextag(&#x27;sheet&#x27;,null,{name:wb.SheetNames[i].substr(0,31), sheetId:&quot;&quot;+(i+1), &quot;r:id&quot;:&quot;rId&quot;+(i+1)}));
	o[o.length] = &quot;&lt;/sheets&gt;&quot;;
	if(o.length&gt;2){ o[o.length] = &#x27;&lt;/workbook&gt;&#x27;; o[1]=o[1].replace(&quot;/&gt;&quot;,&quot;&gt;&quot;); }
	return o.join(&quot;&quot;);
}
/* [MS-XLSB] 2.4.301 BrtBundleSh */
function parse_BrtBundleSh(data, length) {
	var z = {};
	z.hsState = data.read_shift(4); //ST_SheetState
	z.iTabID = data.read_shift(4);
	z.strRelID = parse_RelID(data,length-8);
	z.name = parse_XLWideString(data);
	return z;
}
function write_BrtBundleSh(data, o) {
	if(!o) o = new_buf(127);
	o.write_shift(4, data.hsState);
	o.write_shift(4, data.iTabID);
	write_RelID(data.strRelID, o);
	write_XLWideString(data.name.substr(0,31), o);
	return o;
}

/* [MS-XLSB] 2.4.807 BrtWbProp */
function parse_BrtWbProp(data, length) {
	data.read_shift(4);
	var dwThemeVersion = data.read_shift(4);
	var strName = (length &gt; 8) ? parse_XLWideString(data) : &quot;&quot;;
	return [dwThemeVersion, strName];
}
function write_BrtWbProp(data, o) {
	if(!o) o = new_buf(8);
	o.write_shift(4, 0);
	o.write_shift(4, 0);
	return o;
}

function parse_BrtFRTArchID$(data, length) {
	var o = {};
	data.read_shift(4);
	o.ArchID = data.read_shift(4);
	data.l += length - 8;
	return o;
}

/* [MS-XLSB] 2.1.7.60 Workbook */
function parse_wb_bin(data, opts) {
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, xmlns: &quot;&quot; };
	var pass = false, z;

	recordhopper(data, function hopper_wb(val, R) {
		switch(R.n) {
			case &#x27;BrtBundleSh&#x27;: wb.Sheets.push(val); break;

			case &#x27;BrtBeginBook&#x27;: break;
			case &#x27;BrtFileVersion&#x27;: break;
			case &#x27;BrtWbProp&#x27;: break;
			case &#x27;BrtACBegin&#x27;: break;
			case &#x27;BrtAbsPath15&#x27;: break;
			case &#x27;BrtACEnd&#x27;: break;
			case &#x27;BrtWbFactoid&#x27;: break;
			/*case &#x27;BrtBookProtectionIso&#x27;: break;*/
			case &#x27;BrtBookProtection&#x27;: break;
			case &#x27;BrtBeginBookViews&#x27;: break;
			case &#x27;BrtBookView&#x27;: break;
			case &#x27;BrtEndBookViews&#x27;: break;
			case &#x27;BrtBeginBundleShs&#x27;: break;
			case &#x27;BrtEndBundleShs&#x27;: break;
			case &#x27;BrtBeginFnGroup&#x27;: break;
			case &#x27;BrtEndFnGroup&#x27;: break;
			case &#x27;BrtBeginExternals&#x27;: break;
			case &#x27;BrtSupSelf&#x27;: break;
			case &#x27;BrtSupBookSrc&#x27;: break;
			case &#x27;BrtExternSheet&#x27;: break;
			case &#x27;BrtEndExternals&#x27;: break;
			case &#x27;BrtName&#x27;: break;
			case &#x27;BrtCalcProp&#x27;: break;
			case &#x27;BrtUserBookView&#x27;: break;
			case &#x27;BrtBeginPivotCacheIDs&#x27;: break;
			case &#x27;BrtBeginPivotCacheID&#x27;: break;
			case &#x27;BrtEndPivotCacheID&#x27;: break;
			case &#x27;BrtEndPivotCacheIDs&#x27;: break;
			case &#x27;BrtWebOpt&#x27;: break;
			case &#x27;BrtFileRecover&#x27;: break;
			case &#x27;BrtFileSharing&#x27;: break;
			/*case &#x27;BrtBeginWebPubItems&#x27;: break;
			case &#x27;BrtBeginWebPubItem&#x27;: break;
			case &#x27;BrtEndWebPubItem&#x27;: break;
			case &#x27;BrtEndWebPubItems&#x27;: break;*/

			/* Smart Tags */
			case &#x27;BrtBeginSmartTagTypes&#x27;: break;
			case &#x27;BrtSmartTagType&#x27;: break;
			case &#x27;BrtEndSmartTagTypes&#x27;: break;

			case &#x27;BrtFRTBegin&#x27;: pass = true; break;
			case &#x27;BrtFRTArchID$&#x27;: break;
			case &#x27;BrtWorkBookPr15&#x27;: break;
			case &#x27;BrtFRTEnd&#x27;: pass = false; break;
			case &#x27;BrtEndBook&#x27;: break;
			default: if(!pass || opts.WTF) throw new Error(&quot;Unexpected record &quot; + R.n);
		}
	});

	parse_wb_defaults(wb);

	return wb;
}

/* [MS-XLSB] 2.1.7.60 Workbook */
function write_BUNDLESHS(ba, wb, opts) {
	write_record(ba, &quot;BrtBeginBundleShs&quot;);
	for(var idx = 0; idx != wb.SheetNames.length; ++idx) {
		var d = { hsState: 0, iTabID: idx+1, strRelID: &#x27;rId&#x27; + (idx+1), name: wb.SheetNames[idx] };
		write_record(ba, &quot;BrtBundleSh&quot;, write_BrtBundleSh(d));
	}
	write_record(ba, &quot;BrtEndBundleShs&quot;);
}

/* [MS-XLSB] 2.4.643 BrtFileVersion */
function write_BrtFileVersion(data, o) {
	if(!o) o = new_buf(127);
	for(var i = 0; i != 4; ++i) o.write_shift(4, 0);
	write_XLWideString(&quot;SheetJS&quot;, o);
	write_XLWideString(XLSX.version, o);
	write_XLWideString(XLSX.version, o);
	write_XLWideString(&quot;7262&quot;, o);
	o.length = o.l;
	return o;
}

/* [MS-XLSB] 2.1.7.60 Workbook */
function write_BOOKVIEWS(ba, wb, opts) {
	write_record(ba, &quot;BrtBeginBookViews&quot;);
	/* 1*(BrtBookView *FRT) */
	write_record(ba, &quot;BrtEndBookViews&quot;);
}

/* [MS-XLSB] 2.4.302 BrtCalcProp */
function write_BrtCalcProp(data, o) {
	if(!o) o = new_buf(26);
	o.write_shift(4,0); /* force recalc */
	o.write_shift(4,1);
	o.write_shift(4,0);
	write_Xnum(0, o);
	o.write_shift(-4, 1023);
	o.write_shift(1, 0x33);
	o.write_shift(1, 0x00);
	return o;
}

function write_BrtFileRecover(data, o) {
	if(!o) o = new_buf(1);
	o.write_shift(1,0);
	return o;
}

/* [MS-XLSB] 2.1.7.60 Workbook */
function write_wb_bin(wb, opts) {
	var ba = buf_array();
	write_record(ba, &quot;BrtBeginBook&quot;);
	write_record(ba, &quot;BrtFileVersion&quot;, write_BrtFileVersion());
	/* [[BrtFileSharingIso] BrtFileSharing] */
	write_record(ba, &quot;BrtWbProp&quot;, write_BrtWbProp());
	/* [ACABSPATH] */
	/* [[BrtBookProtectionIso] BrtBookProtection] */
	write_BOOKVIEWS(ba, wb, opts);
	write_BUNDLESHS(ba, wb, opts);
	/* [FNGROUP] */
	/* [EXTERNALS] */
	/* *BrtName */
	write_record(ba, &quot;BrtCalcProp&quot;, write_BrtCalcProp());
	/* [BrtOleSize] */
	/* *(BrtUserBookView *FRT) */
	/* [PIVOTCACHEIDS] */
	/* [BrtWbFactoid] */
	/* [SMARTTAGTYPES] */
	/* [BrtWebOpt] */
	write_record(ba, &quot;BrtFileRecover&quot;, write_BrtFileRecover());
	/* [WEBPUBITEMS] */
	/* [CRERRS] */
	/* FRTWORKBOOK */
	write_record(ba, &quot;BrtEndBook&quot;);

	return ba.end();
}
function parse_wb(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_wb_bin : parse_wb_xml)(data, opts);
}

function parse_ws(data, name, opts, rels) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_ws_bin : parse_ws_xml)(data, opts, rels);
}

function parse_sty(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_sty_bin : parse_sty_xml)(data, opts);
}

function parse_theme(data, name, opts) {
	return parse_theme_xml(data, opts);
}

function parse_sst(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_sst_bin : parse_sst_xml)(data, opts);
}

function parse_cmnt(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_comments_bin : parse_comments_xml)(data, opts);
}

function parse_cc(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? parse_cc_bin : parse_cc_xml)(data, opts);
}

function write_wb(wb, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_wb_bin : write_wb_xml)(wb, opts);
}

function write_ws(data, name, opts, wb) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_ws_bin : write_ws_xml)(data, opts, wb);
}

function write_sty(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_sty_bin : write_sty_xml)(data, opts);
}

function write_sst(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_sst_bin : write_sst_xml)(data, opts);
}
/*
function write_cmnt(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_comments_bin : write_comments_xml)(data, opts);
}

function write_cc(data, name, opts) {
	return (name.substr(-4)===&quot;.bin&quot; ? write_cc_bin : write_cc_xml)(data, opts);
}
*/
var attregexg2=/([\w:]+)=((?:&quot;)([^&quot;]*)(?:&quot;)|(?:&#x27;)([^&#x27;]*)(?:&#x27;))/g;
var attregex2=/([\w:]+)=((?:&quot;)(?:[^&quot;]*)(?:&quot;)|(?:&#x27;)(?:[^&#x27;]*)(?:&#x27;))/;
var _chr = function(c) { return String.fromCharCode(c); };
function xlml_parsexmltag(tag, skip_root) {
	var words = tag.split(/\s+/);
	var z = []; if(!skip_root) z[0] = words[0];
	if(words.length === 1) return z;
	var m = tag.match(attregexg2), y, j, w, i;
	if(m) for(i = 0; i != m.length; ++i) {
		y = m[i].match(attregex2);
		if((j=y[1].indexOf(&quot;:&quot;)) === -1) z[y[1]] = y[2].substr(1,y[2].length-2);
		else {
			if(y[1].substr(0,6) === &quot;xmlns:&quot;) w = &quot;xmlns&quot;+y[1].substr(6);
			else w = y[1].substr(j+1);
			z[w] = y[2].substr(1,y[2].length-2);
		}
	}
	return z;
}
function xlml_parsexmltagobj(tag) {
	var words = tag.split(/\s+/);
	var z = {};
	if(words.length === 1) return z;
	var m = tag.match(attregexg2), y, j, w, i;
	if(m) for(i = 0; i != m.length; ++i) {
		y = m[i].match(attregex2);
		if((j=y[1].indexOf(&quot;:&quot;)) === -1) z[y[1]] = y[2].substr(1,y[2].length-2);
		else {
			if(y[1].substr(0,6) === &quot;xmlns:&quot;) w = &quot;xmlns&quot;+y[1].substr(6);
			else w = y[1].substr(j+1);
			z[w] = y[2].substr(1,y[2].length-2);
		}
	}
	return z;
}

// ----

function xlml_format(format, value) {
	var fmt = XLMLFormatMap[format] || unescapexml(format);
	if(fmt === &quot;General&quot;) return SSF._general(value);
	return SSF.format(fmt, value);
}

function xlml_set_custprop(Custprops, Rn, cp, val) {
	switch((cp[0].match(/dt:dt=&quot;([\w.]+)&quot;/)||[&quot;&quot;,&quot;&quot;])[1]) {
		case &quot;boolean&quot;: val = parsexmlbool(val); break;
		case &quot;i2&quot;: case &quot;int&quot;: val = parseInt(val, 10); break;
		case &quot;r4&quot;: case &quot;float&quot;: val = parseFloat(val); break;
		case &quot;date&quot;: case &quot;dateTime.tz&quot;: val = new Date(val); break;
		case &quot;i8&quot;: case &quot;string&quot;: case &quot;fixed&quot;: case &quot;uuid&quot;: case &quot;bin.base64&quot;: break;
		default: throw &quot;bad custprop:&quot; + cp[0];
	}
	Custprops[unescapexml(Rn[3])] = val;
}

function safe_format_xlml(cell, nf, o) {
	try {
		if(cell.t === &#x27;e&#x27;) { cell.w = cell.w || BErr[cell.v]; }
		else if(nf === &quot;General&quot;) {
			if(cell.t === &#x27;n&#x27;) {
				if((cell.v|0) === cell.v) cell.w = SSF._general_int(cell.v);
				else cell.w = SSF._general_num(cell.v);
			}
			else cell.w = SSF._general(cell.v);
		}
		else cell.w = xlml_format(nf||&quot;General&quot;, cell.v);
		if(o.cellNF) cell.z = XLMLFormatMap[nf]||nf||&quot;General&quot;;
	} catch(e) { if(o.WTF) throw e; }
}

function process_style_xlml(styles, stag, opts) {
	if(opts.cellStyles) {
		if(stag.Interior) {
			var I = stag.Interior;
			if(I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
		}
	}
	styles[stag.ID] = stag;
}

/* TODO: there must exist some form of OSP-blessed spec */
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, o) {
	var nf = &quot;General&quot;, sid = cell.StyleID, S = {}; o = o || {};
	var interiors = [];
	if(sid === undefined &amp;&amp; row) sid = row.StyleID;
	if(sid === undefined &amp;&amp; csty) sid = csty.StyleID;
	while(styles[sid] !== undefined) {
		if(styles[sid].nf) nf = styles[sid].nf;
		if(styles[sid].Interior) interiors.push(styles[sid].Interior);
		if(!styles[sid].Parent) break;
		sid = styles[sid].Parent;
	}
	switch(data.Type) {
		case &#x27;Boolean&#x27;:
			cell.t = &#x27;b&#x27;;
			cell.v = parsexmlbool(xml);
			break;
		case &#x27;String&#x27;:
			cell.t = &#x27;s&#x27;; cell.r = xlml_fixstr(unescapexml(xml));
			cell.v = xml.indexOf(&quot;&lt;&quot;) &gt; -1 ? ss : cell.r;
			break;
		case &#x27;DateTime&#x27;:
			cell.v = (Date.parse(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
			if(cell.v !== cell.v) cell.v = unescapexml(xml);
			else if(cell.v &gt;= 1 &amp;&amp; cell.v&lt;60) cell.v = cell.v -1;
			if(!nf || nf == &quot;General&quot;) nf = &quot;yyyy-mm-dd&quot;;
			/* falls through */
		case &#x27;Number&#x27;:
			if(cell.v === undefined) cell.v=+xml;
			if(!cell.t) cell.t = &#x27;n&#x27;;
			break;
		case &#x27;Error&#x27;: cell.t = &#x27;e&#x27;; cell.v = RBErr[xml]; cell.w = xml; break;
		default: cell.t = &#x27;s&#x27;; cell.v = xlml_fixstr(ss); break;
	}
	safe_format_xlml(cell, nf, o);
	if(o.cellFormula != null &amp;&amp; cell.Formula) {
		cell.f = rc_to_a1(unescapexml(cell.Formula), base);
		cell.Formula = undefined;
	}
	if(o.cellStyles) {
		interiors.forEach(function(x) {
			if(!S.patternType &amp;&amp; x.patternType) S.patternType = x.patternType;
		});
		cell.s = S;
	}
	cell.ixfe = cell.StyleID !== undefined ? cell.StyleID : &#x27;Default&#x27;;
}

function xlml_clean_comment(comment) {
	comment.t = comment.v;
	comment.v = comment.w = comment.ixfe = undefined;
}

function xlml_normalize(d) {
	if(has_buf &amp;&amp; Buffer.isBuffer(d)) return d.toString(&#x27;utf8&#x27;);
	if(typeof d === &#x27;string&#x27;) return d;
	throw &quot;badf&quot;;
}

/* TODO: Everything */
var xlmlregex = /&lt;(\/?)([a-z0-9]*:|)(\w+)[^&gt;]*&gt;/mg;
function parse_xlml_xml(d, opts) {
	var str = xlml_normalize(d);
	var Rn;
	var state = [], tmp;
	var sheets = {}, sheetnames = [], cursheet = {}, sheetname = &quot;&quot;;
	var table = {}, cell = {}, row = {}, dtag, didx;
	var c = 0, r = 0;
	var refguess = {s: {r:1000000, c:1000000}, e: {r:0, c:0} };
	var styles = {}, stag = {};
	var ss = &quot;&quot;, fidx = 0;
	var mergecells = [];
	var Props = {}, Custprops = {}, pidx = 0, cp = {};
	var comments = [], comment = {};
	var cstys = [], csty;
	xlmlregex.lastIndex = 0;
	while((Rn = xlmlregex.exec(str))) switch(Rn[3]) {
		case &#x27;Data&#x27;:
			if(state[state.length-1][1]) break;
			if(Rn[1]===&#x27;/&#x27;) parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length-1][0]==&quot;Comment&quot;?comment:cell, {c:c,r:r}, styles, cstys[c], row, opts);
			else { ss = &quot;&quot;; dtag = xlml_parsexmltag(Rn[0]); didx = Rn.index + Rn[0].length; }
			break;
		case &#x27;Cell&#x27;:
			if(Rn[1]===&#x27;/&#x27;){
				if(comments.length &gt; 0) cell.c = comments;
				if((!opts.sheetRows || opts.sheetRows &gt; r) &amp;&amp; cell.v !== undefined) cursheet[encode_col(c) + encode_row(r)] = cell;
				if(cell.HRef) {
					cell.l = {Target:cell.HRef, tooltip:cell.HRefScreenTip};
					cell.HRef = cell.HRefScreenTip = undefined;
				}
				if(cell.MergeAcross || cell.MergeDown) {
					var cc = c + (parseInt(cell.MergeAcross,10)|0);
					var rr = r + (parseInt(cell.MergeDown,10)|0);
					mergecells.push({s:{c:c,r:r},e:{c:cc,r:rr}});
				}
				++c;
				if(cell.MergeAcross) c += +cell.MergeAcross;
			} else {
				cell = xlml_parsexmltagobj(Rn[0]);
				if(cell.Index) c = +cell.Index - 1;
				if(c &lt; refguess.s.c) refguess.s.c = c;
				if(c &gt; refguess.e.c) refguess.e.c = c;
				if(Rn[0].substr(-2) === &quot;/&gt;&quot;) ++c;
				comments = [];
			}
			break;
		case &#x27;Row&#x27;:
			if(Rn[1]===&#x27;/&#x27; || Rn[0].substr(-2) === &quot;/&gt;&quot;) {
				if(r &lt; refguess.s.r) refguess.s.r = r;
				if(r &gt; refguess.e.r) refguess.e.r = r;
				if(Rn[0].substr(-2) === &quot;/&gt;&quot;) {
					row = xlml_parsexmltag(Rn[0]);
					if(row.Index) r = +row.Index - 1;
				}
				c = 0; ++r;
			} else {
				row = xlml_parsexmltag(Rn[0]);
				if(row.Index) r = +row.Index - 1;
			}
			break;
		case &#x27;Worksheet&#x27;: /* TODO: read range from FullRows/FullColumns */
			if(Rn[1]===&#x27;/&#x27;){
				if((tmp=state.pop())[0]!==Rn[3]) throw &quot;Bad state: &quot;+tmp;
				sheetnames.push(sheetname);
				if(refguess.s.r &lt;= refguess.e.r &amp;&amp; refguess.s.c &lt;= refguess.e.c) cursheet[&quot;!ref&quot;] = encode_range(refguess);
				if(mergecells.length) cursheet[&quot;!merges&quot;] = mergecells;
				sheets[sheetname] = cursheet;
			} else {
				refguess = {s: {r:1000000, c:1000000}, e: {r:0, c:0} };
				r = c = 0;
				state.push([Rn[3], false]);
				tmp = xlml_parsexmltag(Rn[0]);
				sheetname = tmp.Name;
				cursheet = {};
				mergecells = [];
			}
			break;
		case &#x27;Table&#x27;:
			if(Rn[1]===&#x27;/&#x27;){if((tmp=state.pop())[0]!==Rn[3]) throw &quot;Bad state: &quot;+tmp;}
			else if(Rn[0].slice(-2) == &quot;/&gt;&quot;) break;
			else {
				table = xlml_parsexmltag(Rn[0]);
				state.push([Rn[3], false]);
				cstys = [];
			}
			break;

		case &#x27;Style&#x27;:
			if(Rn[1]===&#x27;/&#x27;) process_style_xlml(styles, stag, opts);
			else stag = xlml_parsexmltag(Rn[0]);
			break;

		case &#x27;NumberFormat&#x27;:
			stag.nf = xlml_parsexmltag(Rn[0]).Format || &quot;General&quot;;
			break;

		case &#x27;Column&#x27;:
			if(state[state.length-1][0] !== &#x27;Table&#x27;) break;
			csty = xlml_parsexmltag(Rn[0]);
			cstys[(csty.Index-1||cstys.length)] = csty;
			for(var i = 0; i &lt; +csty.Span; ++i) cstys[cstys.length] = csty;
			break;

		case &#x27;NamedRange&#x27;: break;
		case &#x27;NamedCell&#x27;: break;
		case &#x27;B&#x27;: break;
		case &#x27;I&#x27;: break;
		case &#x27;U&#x27;: break;
		case &#x27;S&#x27;: break;
		case &#x27;Sub&#x27;: break;
		case &#x27;Sup&#x27;: break;
		case &#x27;Span&#x27;: break;
		case &#x27;Border&#x27;: break;
		case &#x27;Alignment&#x27;: break;
		case &#x27;Borders&#x27;: break;
		case &#x27;Font&#x27;:
			if(Rn[0].substr(-2) === &quot;/&gt;&quot;) break;
			else if(Rn[1]===&quot;/&quot;) ss += str.slice(fidx, Rn.index);
			else fidx = Rn.index + Rn[0].length;
			break;
		case &#x27;Interior&#x27;:
			if(!opts.cellStyles) break;
			stag.Interior = xlml_parsexmltag(Rn[0]);
			break;
		case &#x27;Protection&#x27;: break;

		case &#x27;Author&#x27;:
		case &#x27;Title&#x27;:
		case &#x27;Description&#x27;:
		case &#x27;Created&#x27;:
		case &#x27;Keywords&#x27;:
		case &#x27;Subject&#x27;:
		case &#x27;Category&#x27;:
		case &#x27;Company&#x27;:
		case &#x27;LastAuthor&#x27;:
		case &#x27;LastSaved&#x27;:
		case &#x27;LastPrinted&#x27;:
		case &#x27;Version&#x27;:
		case &#x27;Revision&#x27;:
		case &#x27;TotalTime&#x27;:
		case &#x27;HyperlinkBase&#x27;:
		case &#x27;Manager&#x27;:
			if(Rn[0].substr(-2) === &quot;/&gt;&quot;) break;
			else if(Rn[1]===&quot;/&quot;) xlml_set_prop(Props, Rn[3], str.slice(pidx, Rn.index));
			else pidx = Rn.index + Rn[0].length;
			break;
		case &#x27;Paragraphs&#x27;: break;

		case &#x27;Styles&#x27;:
		case &#x27;Workbook&#x27;:
			if(Rn[1]===&#x27;/&#x27;){if((tmp=state.pop())[0]!==Rn[3]) throw &quot;Bad state: &quot;+tmp;}
			else state.push([Rn[3], false]);
			break;

		case &#x27;Comment&#x27;:
			if(Rn[1]===&#x27;/&#x27;){
				if((tmp=state.pop())[0]!==Rn[3]) throw &quot;Bad state: &quot;+tmp;
				xlml_clean_comment(comment);
				comments.push(comment);
			} else {
				state.push([Rn[3], false]);
				tmp = xlml_parsexmltag(Rn[0]);
				comment = {a:tmp.Author};
			}
			break;

		case &#x27;Name&#x27;: break;

		case &#x27;ComponentOptions&#x27;:
		case &#x27;DocumentProperties&#x27;:
		case &#x27;CustomDocumentProperties&#x27;:
		case &#x27;OfficeDocumentSettings&#x27;:
		case &#x27;PivotTable&#x27;:
		case &#x27;PivotCache&#x27;:
		case &#x27;Names&#x27;:
		case &#x27;MapInfo&#x27;:
		case &#x27;PageBreaks&#x27;:
		case &#x27;QueryTable&#x27;:
		case &#x27;DataValidation&#x27;:
		case &#x27;AutoFilter&#x27;:
		case &#x27;Sorting&#x27;:
		case &#x27;Schema&#x27;:
		case &#x27;data&#x27;:
		case &#x27;ConditionalFormatting&#x27;:
		case &#x27;SmartTagType&#x27;:
		case &#x27;SmartTags&#x27;:
		case &#x27;ExcelWorkbook&#x27;:
		case &#x27;WorkbookOptions&#x27;:
		case &#x27;WorksheetOptions&#x27;:
			if(Rn[1]===&#x27;/&#x27;){if((tmp=state.pop())[0]!==Rn[3]) throw &quot;Bad state: &quot;+tmp;}
			else if(Rn[0].charAt(Rn[0].length-2) !== &#x27;/&#x27;) state.push([Rn[3], true]);
			break;

		default:
			var seen = true;
			switch(state[state.length-1][0]) {
				/* OfficeDocumentSettings */
				case &#x27;OfficeDocumentSettings&#x27;: switch(Rn[3]) {
					case &#x27;AllowPNG&#x27;: break;
					case &#x27;RemovePersonalInformation&#x27;: break;
					case &#x27;DownloadComponents&#x27;: break;
					case &#x27;LocationOfComponents&#x27;: break;
					case &#x27;Colors&#x27;: break;
					case &#x27;Color&#x27;: break;
					case &#x27;Index&#x27;: break;
					case &#x27;RGB&#x27;: break;
					case &#x27;PixelsPerInch&#x27;: break;
					case &#x27;TargetScreenSize&#x27;: break;
					case &#x27;ReadOnlyRecommended&#x27;: break;
					default: seen = false;
				} break;

				/* ComponentOptions */
				case &#x27;ComponentOptions&#x27;: switch(Rn[3]) {
					case &#x27;Toolbar&#x27;: break;
					case &#x27;HideOfficeLogo&#x27;: break;
					case &#x27;SpreadsheetAutoFit&#x27;: break;
					case &#x27;Label&#x27;: break;
					case &#x27;Caption&#x27;: break;
					case &#x27;MaxHeight&#x27;: break;
					case &#x27;MaxWidth&#x27;: break;
					case &#x27;NextSheetNumber&#x27;: break;
					default: seen = false;
				} break;

				/* ExcelWorkbook */
				case &#x27;ExcelWorkbook&#x27;: switch(Rn[3]) {
					case &#x27;WindowHeight&#x27;: break;
					case &#x27;WindowWidth&#x27;: break;
					case &#x27;WindowTopX&#x27;: break;
					case &#x27;WindowTopY&#x27;: break;
					case &#x27;TabRatio&#x27;: break;
					case &#x27;ProtectStructure&#x27;: break;
					case &#x27;ProtectWindows&#x27;: break;
					case &#x27;ActiveSheet&#x27;: break;
					case &#x27;DisplayInkNotes&#x27;: break;
					case &#x27;FirstVisibleSheet&#x27;: break;
					case &#x27;SupBook&#x27;: break;
					case &#x27;SheetName&#x27;: break;
					case &#x27;SheetIndex&#x27;: break;
					case &#x27;SheetIndexFirst&#x27;: break;
					case &#x27;SheetIndexLast&#x27;: break;
					case &#x27;Dll&#x27;: break;
					case &#x27;AcceptLabelsInFormulas&#x27;: break;
					case &#x27;DoNotSaveLinkValues&#x27;: break;
					case &#x27;Date1904&#x27;: break;
					case &#x27;Iteration&#x27;: break;
					case &#x27;MaxIterations&#x27;: break;
					case &#x27;MaxChange&#x27;: break;
					case &#x27;Path&#x27;: break;
					case &#x27;Xct&#x27;: break;
					case &#x27;Count&#x27;: break;
					case &#x27;SelectedSheets&#x27;: break;
					case &#x27;Calculation&#x27;: break;
					case &#x27;Uncalced&#x27;: break;
					case &#x27;StartupPrompt&#x27;: break;
					case &#x27;Crn&#x27;: break;
					case &#x27;ExternName&#x27;: break;
					case &#x27;Formula&#x27;: break;
					case &#x27;ColFirst&#x27;: break;
					case &#x27;ColLast&#x27;: break;
					case &#x27;WantAdvise&#x27;: break;
					case &#x27;Boolean&#x27;: break;
					case &#x27;Error&#x27;: break;
					case &#x27;Text&#x27;: break;
					case &#x27;OLE&#x27;: break;
					case &#x27;NoAutoRecover&#x27;: break;
					case &#x27;PublishObjects&#x27;: break;
					case &#x27;DoNotCalculateBeforeSave&#x27;: break;
					case &#x27;Number&#x27;: break;
					case &#x27;RefModeR1C1&#x27;: break;
					case &#x27;EmbedSaveSmartTags&#x27;: break;
					default: seen = false;
				} break;

				/* WorkbookOptions */
				case &#x27;WorkbookOptions&#x27;: switch(Rn[3]) {
					case &#x27;OWCVersion&#x27;: break;
					case &#x27;Height&#x27;: break;
					case &#x27;Width&#x27;: break;
					default: seen = false;
				} break;

				/* WorksheetOptions */
				case &#x27;WorksheetOptions&#x27;: switch(Rn[3]) {
					case &#x27;Unsynced&#x27;: break;
					case &#x27;Visible&#x27;: break;
					case &#x27;Print&#x27;: break;
					case &#x27;Panes&#x27;: break;
					case &#x27;Scale&#x27;: break;
					case &#x27;Pane&#x27;: break;
					case &#x27;Number&#x27;: break;
					case &#x27;Layout&#x27;: break;
					case &#x27;Header&#x27;: break;
					case &#x27;Footer&#x27;: break;
					case &#x27;PageSetup&#x27;: break;
					case &#x27;PageMargins&#x27;: break;
					case &#x27;Selected&#x27;: break;
					case &#x27;ProtectObjects&#x27;: break;
					case &#x27;EnableSelection&#x27;: break;
					case &#x27;ProtectScenarios&#x27;: break;
					case &#x27;ValidPrinterInfo&#x27;: break;
					case &#x27;HorizontalResolution&#x27;: break;
					case &#x27;VerticalResolution&#x27;: break;
					case &#x27;NumberofCopies&#x27;: break;
					case &#x27;ActiveRow&#x27;: break;
					case &#x27;ActiveCol&#x27;: break;
					case &#x27;ActivePane&#x27;: break;
					case &#x27;TopRowVisible&#x27;: break;
					case &#x27;TopRowBottomPane&#x27;: break;
					case &#x27;LeftColumnVisible&#x27;: break;
					case &#x27;LeftColumnRightPane&#x27;: break;
					case &#x27;FitToPage&#x27;: break;
					case &#x27;RangeSelection&#x27;: break;
					case &#x27;PaperSizeIndex&#x27;: break;
					case &#x27;PageLayoutZoom&#x27;: break;
					case &#x27;PageBreakZoom&#x27;: break;
					case &#x27;FilterOn&#x27;: break;
					case &#x27;DoNotDisplayGridlines&#x27;: break;
					case &#x27;SplitHorizontal&#x27;: break;
					case &#x27;SplitVertical&#x27;: break;
					case &#x27;FreezePanes&#x27;: break;
					case &#x27;FrozenNoSplit&#x27;: break;
					case &#x27;FitWidth&#x27;: break;
					case &#x27;FitHeight&#x27;: break;
					case &#x27;CommentsLayout&#x27;: break;
					case &#x27;Zoom&#x27;: break;
					case &#x27;LeftToRight&#x27;: break;
					case &#x27;Gridlines&#x27;: break;
					case &#x27;AllowSort&#x27;: break;
					case &#x27;AllowFilter&#x27;: break;
					case &#x27;AllowInsertRows&#x27;: break;
					case &#x27;AllowDeleteRows&#x27;: break;
					case &#x27;AllowInsertCols&#x27;: break;
					case &#x27;AllowDeleteCols&#x27;: break;
					case &#x27;AllowInsertHyperlinks&#x27;: break;
					case &#x27;AllowFormatCells&#x27;: break;
					case &#x27;AllowSizeCols&#x27;: break;
					case &#x27;AllowSizeRows&#x27;: break;
					case &#x27;NoSummaryRowsBelowDetail&#x27;: break;
					case &#x27;TabColorIndex&#x27;: break;
					case &#x27;DoNotDisplayHeadings&#x27;: break;
					case &#x27;ShowPageLayoutZoom&#x27;: break;
					case &#x27;NoSummaryColumnsRightDetail&#x27;: break;
					case &#x27;BlackAndWhite&#x27;: break;
					case &#x27;DoNotDisplayZeros&#x27;: break;
					case &#x27;DisplayPageBreak&#x27;: break;
					case &#x27;RowColHeadings&#x27;: break;
					case &#x27;DoNotDisplayOutline&#x27;: break;
					case &#x27;NoOrientation&#x27;: break;
					case &#x27;AllowUsePivotTables&#x27;: break;
					case &#x27;ZeroHeight&#x27;: break;
					case &#x27;ViewableRange&#x27;: break;
					case &#x27;Selection&#x27;: break;
					case &#x27;ProtectContents&#x27;: break;
					default: seen = false;
				} break;

				/* PivotTable */
				case &#x27;PivotTable&#x27;: case &#x27;PivotCache&#x27;: switch(Rn[3]) {
					case &#x27;ImmediateItemsOnDrop&#x27;: break;
					case &#x27;ShowPageMultipleItemLabel&#x27;: break;
					case &#x27;CompactRowIndent&#x27;: break;
					case &#x27;Location&#x27;: break;
					case &#x27;PivotField&#x27;: break;
					case &#x27;Orientation&#x27;: break;
					case &#x27;LayoutForm&#x27;: break;
					case &#x27;LayoutSubtotalLocation&#x27;: break;
					case &#x27;LayoutCompactRow&#x27;: break;
					case &#x27;Position&#x27;: break;
					case &#x27;PivotItem&#x27;: break;
					case &#x27;DataType&#x27;: break;
					case &#x27;DataField&#x27;: break;
					case &#x27;SourceName&#x27;: break;
					case &#x27;ParentField&#x27;: break;
					case &#x27;PTLineItems&#x27;: break;
					case &#x27;PTLineItem&#x27;: break;
					case &#x27;CountOfSameItems&#x27;: break;
					case &#x27;Item&#x27;: break;
					case &#x27;ItemType&#x27;: break;
					case &#x27;PTSource&#x27;: break;
					case &#x27;CacheIndex&#x27;: break;
					case &#x27;ConsolidationReference&#x27;: break;
					case &#x27;FileName&#x27;: break;
					case &#x27;Reference&#x27;: break;
					case &#x27;NoColumnGrand&#x27;: break;
					case &#x27;NoRowGrand&#x27;: break;
					case &#x27;BlankLineAfterItems&#x27;: break;
					case &#x27;Hidden&#x27;: break;
					case &#x27;Subtotal&#x27;: break;
					case &#x27;BaseField&#x27;: break;
					case &#x27;MapChildItems&#x27;: break;
					case &#x27;Function&#x27;: break;
					case &#x27;RefreshOnFileOpen&#x27;: break;
					case &#x27;PrintSetTitles&#x27;: break;
					case &#x27;MergeLabels&#x27;: break;
					case &#x27;DefaultVersion&#x27;: break;
					case &#x27;RefreshName&#x27;: break;
					case &#x27;RefreshDate&#x27;: break;
					case &#x27;RefreshDateCopy&#x27;: break;
					case &#x27;VersionLastRefresh&#x27;: break;
					case &#x27;VersionLastUpdate&#x27;: break;
					case &#x27;VersionUpdateableMin&#x27;: break;
					case &#x27;VersionRefreshableMin&#x27;: break;
					case &#x27;Calculation&#x27;: break;
					default: seen = false;
				} break;

				/* PageBreaks */
				case &#x27;PageBreaks&#x27;: switch(Rn[3]) {
					case &#x27;ColBreaks&#x27;: break;
					case &#x27;ColBreak&#x27;: break;
					case &#x27;RowBreaks&#x27;: break;
					case &#x27;RowBreak&#x27;: break;
					case &#x27;ColStart&#x27;: break;
					case &#x27;ColEnd&#x27;: break;
					case &#x27;RowEnd&#x27;: break;
					default: seen = false;
				} break;

				/* AutoFilter */
				case &#x27;AutoFilter&#x27;: switch(Rn[3]) {
					case &#x27;AutoFilterColumn&#x27;: break;
					case &#x27;AutoFilterCondition&#x27;: break;
					case &#x27;AutoFilterAnd&#x27;: break;
					case &#x27;AutoFilterOr&#x27;: break;
					default: seen = false;
				} break;

				/* QueryTable */
				case &#x27;QueryTable&#x27;: switch(Rn[3]) {
					case &#x27;Id&#x27;: break;
					case &#x27;AutoFormatFont&#x27;: break;
					case &#x27;AutoFormatPattern&#x27;: break;
					case &#x27;QuerySource&#x27;: break;
					case &#x27;QueryType&#x27;: break;
					case &#x27;EnableRedirections&#x27;: break;
					case &#x27;RefreshedInXl9&#x27;: break;
					case &#x27;URLString&#x27;: break;
					case &#x27;HTMLTables&#x27;: break;
					case &#x27;Connection&#x27;: break;
					case &#x27;CommandText&#x27;: break;
					case &#x27;RefreshInfo&#x27;: break;
					case &#x27;NoTitles&#x27;: break;
					case &#x27;NextId&#x27;: break;
					case &#x27;ColumnInfo&#x27;: break;
					case &#x27;OverwriteCells&#x27;: break;
					case &#x27;DoNotPromptForFile&#x27;: break;
					case &#x27;TextWizardSettings&#x27;: break;
					case &#x27;Source&#x27;: break;
					case &#x27;Number&#x27;: break;
					case &#x27;Decimal&#x27;: break;
					case &#x27;ThousandSeparator&#x27;: break;
					case &#x27;TrailingMinusNumbers&#x27;: break;
					case &#x27;FormatSettings&#x27;: break;
					case &#x27;FieldType&#x27;: break;
					case &#x27;Delimiters&#x27;: break;
					case &#x27;Tab&#x27;: break;
					case &#x27;Comma&#x27;: break;
					case &#x27;AutoFormatName&#x27;: break;
					case &#x27;VersionLastEdit&#x27;: break;
					case &#x27;VersionLastRefresh&#x27;: break;
					default: seen = false;
				} break;

				/* Sorting */
				case &#x27;Sorting&#x27;:
				/* ConditionalFormatting */
				case &#x27;ConditionalFormatting&#x27;:
				/* DataValidation */
				case &#x27;DataValidation&#x27;: switch(Rn[3]) {
					case &#x27;Range&#x27;: break;
					case &#x27;Type&#x27;: break;
					case &#x27;Min&#x27;: break;
					case &#x27;Max&#x27;: break;
					case &#x27;Sort&#x27;: break;
					case &#x27;Descending&#x27;: break;
					case &#x27;Order&#x27;: break;
					case &#x27;CaseSensitive&#x27;: break;
					case &#x27;Value&#x27;: break;
					case &#x27;ErrorStyle&#x27;: break;
					case &#x27;ErrorMessage&#x27;: break;
					case &#x27;ErrorTitle&#x27;: break;
					case &#x27;CellRangeList&#x27;: break;
					case &#x27;InputMessage&#x27;: break;
					case &#x27;InputTitle&#x27;: break;
					case &#x27;ComboHide&#x27;: break;
					case &#x27;InputHide&#x27;: break;
					case &#x27;Condition&#x27;: break;
					case &#x27;Qualifier&#x27;: break;
					case &#x27;UseBlank&#x27;: break;
					case &#x27;Value1&#x27;: break;
					case &#x27;Value2&#x27;: break;
					case &#x27;Format&#x27;: break;
					default: seen = false;
				} break;

				/* MapInfo (schema) */
				case &#x27;MapInfo&#x27;: case &#x27;Schema&#x27;: case &#x27;data&#x27;: switch(Rn[3]) {
					case &#x27;Map&#x27;: break;
					case &#x27;Entry&#x27;: break;
					case &#x27;Range&#x27;: break;
					case &#x27;XPath&#x27;: break;
					case &#x27;Field&#x27;: break;
					case &#x27;XSDType&#x27;: break;
					case &#x27;FilterOn&#x27;: break;
					case &#x27;Aggregate&#x27;: break;
					case &#x27;ElementType&#x27;: break;
					case &#x27;AttributeType&#x27;: break;
				/* These are from xsd (XML Schema Definition) */
					case &#x27;schema&#x27;:
					case &#x27;element&#x27;:
					case &#x27;complexType&#x27;:
					case &#x27;datatype&#x27;:
					case &#x27;all&#x27;:
					case &#x27;attribute&#x27;:
					case &#x27;extends&#x27;: break;

					case &#x27;row&#x27;: break;
					default: seen = false;
				} break;

				/* SmartTags (can be anything) */
				case &#x27;SmartTags&#x27;: break;

				default: seen = false; break;
			}
			if(seen) break;
			/* CustomDocumentProperties */
			if(!state[state.length-1][1]) throw &#x27;Unrecognized tag: &#x27; + Rn[3] + &quot;|&quot; + state.join(&quot;|&quot;);
			if(state[state.length-1][0]===&#x27;CustomDocumentProperties&#x27;) {
				if(Rn[0].substr(-2) === &quot;/&gt;&quot;) break;
				else if(Rn[1]===&quot;/&quot;) xlml_set_custprop(Custprops, Rn, cp, str.slice(pidx, Rn.index));
				else { cp = Rn; pidx = Rn.index + Rn[0].length; }
				break;
			}
			if(opts.WTF) throw &#x27;Unrecognized tag: &#x27; + Rn[3] + &quot;|&quot; + state.join(&quot;|&quot;);
	}
	var out = {};
	if(!opts.bookSheets &amp;&amp; !opts.bookProps) out.Sheets = sheets;
	out.SheetNames = sheetnames;
	out.SSF = SSF.get_table();
	out.Props = Props;
	out.Custprops = Custprops;
	return out;
}

function parse_xlml(data, opts) {
	fix_read_opts(opts=opts||{});
	switch(opts.type||&quot;base64&quot;) {
		case &quot;base64&quot;: return parse_xlml_xml(Base64.decode(data), opts);
		case &quot;binary&quot;: case &quot;buffer&quot;: case &quot;file&quot;: return parse_xlml_xml(data, opts);
		case &quot;array&quot;: return parse_xlml_xml(data.map(_chr).join(&quot;&quot;), opts);
	}
}

function write_xlml(wb, opts) { }

/* [MS-OLEDS] 2.3.8 CompObjStream */
function parse_compobj(obj) {
	var v = {};
	var o = obj.content;

	/* [MS-OLEDS] 2.3.7 CompObjHeader -- All fields MUST be ignored */
	var l = 28, m;
	m = __lpstr(o, l);
	l += 4 + __readUInt32LE(o,l);
	v.UserType = m;

	/* [MS-OLEDS] 2.3.1 ClipboardFormatOrAnsiString */
	m = __readUInt32LE(o,l); l+= 4;
	switch(m) {
		case 0x00000000: break;
		case 0xffffffff: case 0xfffffffe: l+=4; break;
		default:
			if(m &gt; 0x190) throw new Error(&quot;Unsupported Clipboard: &quot; + m.toString(16));
			l += m;
	}

	m = __lpstr(o, l); l += m.length === 0 ? 0 : 5 + m.length; v.Reserved1 = m;

	if((m = __readUInt32LE(o,l)) !== 0x71b2e9f4) return v;
	throw &quot;Unsupported Unicode Extension&quot;;
}

/* 2.4.58 Continue logic */
function slurp(R, blob, length, opts) {
	var l = length;
	var bufs = [];
	var d = blob.slice(blob.l,blob.l+l);
	if(opts &amp;&amp; opts.enc &amp;&amp; opts.enc.insitu_decrypt) switch(R.n) {
	case &#x27;BOF&#x27;: case &#x27;FilePass&#x27;: case &#x27;FileLock&#x27;: case &#x27;InterfaceHdr&#x27;: case &#x27;RRDInfo&#x27;: case &#x27;RRDHead&#x27;: case &#x27;UsrExcl&#x27;: break;
	default:
		if(d.length === 0) break;
		opts.enc.insitu_decrypt(d);
	}
	bufs.push(d);
	blob.l += l;
	var next = (XLSRecordEnum[__readUInt16LE(blob,blob.l)]);
	while(next != null &amp;&amp; next.n === &#x27;Continue&#x27;) {
		l = __readUInt16LE(blob,blob.l+2);
		bufs.push(blob.slice(blob.l+4,blob.l+4+l));
		blob.l += 4+l;
		next = (XLSRecordEnum[__readUInt16LE(blob, blob.l)]);
	}
	var b = bconcat(bufs);
	prep_blob(b, 0);
	var ll = 0; b.lens = [];
	for(var j = 0; j &lt; bufs.length; ++j) { b.lens.push(ll); ll += bufs[j].length; }
	return R.f(b, b.length, opts);
}

function safe_format_xf(p, opts, date1904) {
	if(!p.XF) return;
	try {
		var fmtid = p.XF.ifmt||0;
		if(p.t === &#x27;e&#x27;) { p.w = p.w || BErr[p.v]; }
		else if(fmtid === 0) {
			if(p.t === &#x27;n&#x27;) {
				if((p.v|0) === p.v) p.w = SSF._general_int(p.v);
				else p.w = SSF._general_num(p.v);
			}
			else p.w = SSF._general(p.v);
		}
		else p.w = SSF.format(fmtid,p.v, {date1904:date1904||false});
		if(opts.cellNF) p.z = SSF._table[fmtid];
	} catch(e) { if(opts.WTF) throw e; }
}

function make_cell(val, ixfe, t) {
	return {v:val, ixfe:ixfe, t:t};
}

// 2.3.2
function parse_workbook(blob, options) {
	var wb = {opts:{}};
	var Sheets = {};
	var out = {};
	var Directory = {};
	var found_sheet = false;
	var range = {};
	var last_formula = null;
	var sst = [];
	var cur_sheet = &quot;&quot;;
	var Preamble = {};
	var lastcell, last_cell, cc, cmnt, rng, rngC, rngR;
	var shared_formulae = {};
	var array_formulae = []; /* TODO: something more clever */
	var temp_val;
	var country;
	var cell_valid = true;
	var XFs = []; /* XF records */
	var palette = [];
	var get_rgb = function getrgb(icv) {
		if(icv &lt; 8) return XLSIcv[icv];
		if(icv &lt; 64) return palette[icv-8] || XLSIcv[icv];
		return XLSIcv[icv];
	};
	var process_cell_style = function pcs(cell, line) {
		var xfd = line.XF.data;
		if(!xfd || !xfd.patternType) return;
		line.s = {};
		line.s.patternType = xfd.patternType;
		var t;
		if((t = rgb2Hex(get_rgb(xfd.icvFore)))) { line.s.fgColor = {rgb:t}; }
		if((t = rgb2Hex(get_rgb(xfd.icvBack)))) { line.s.bgColor = {rgb:t}; }
	};
	var addcell = function addcell(cell, line, options) {
		if(!cell_valid) return;
		if(options.cellStyles &amp;&amp; line.XF &amp;&amp; line.XF.data) process_cell_style(cell, line);
		lastcell = cell;
		last_cell = encode_cell(cell);
		if(range.s) {
			if(cell.r &lt; range.s.r) range.s.r = cell.r;
			if(cell.c &lt; range.s.c) range.s.c = cell.c;
		}
		if(range.e) {
			if(cell.r + 1 &gt; range.e.r) range.e.r = cell.r + 1;
			if(cell.c + 1 &gt; range.e.c) range.e.c = cell.c + 1;
		}
		if(options.sheetRows &amp;&amp; lastcell.r &gt;= options.sheetRows) cell_valid = false;
		else out[last_cell] = line;
	};
	var opts = {
		enc: false, // encrypted
		sbcch: 0, // cch in the preceding SupBook
		snames: [], // sheetnames
		sharedf: shared_formulae, // shared formulae by address
		arrayf: array_formulae, // array formulae array
		rrtabid: [], // RRTabId
		lastuser: &quot;&quot;, // Last User from WriteAccess
		biff: 8, // BIFF version
		codepage: 0, // CP from CodePage record
		winlocked: 0, // fLockWn from WinProtect
		wtf: false
	};
	if(options.password) opts.password = options.password;
	var mergecells = [];
	var objects = [];
	var supbooks = [[]]; // 1-indexed, will hold extern names
	var sbc = 0, sbci = 0, sbcli = 0;
	supbooks.SheetNames = opts.snames;
	supbooks.sharedf = opts.sharedf;
	supbooks.arrayf = opts.arrayf;
	var last_Rn = &#x27;&#x27;;
	var file_depth = 0; /* TODO: make a real stack */

	/* explicit override for some broken writers */
	opts.codepage = 1200;
	set_cp(1200);

	while(blob.l &lt; blob.length - 1) {
		var s = blob.l;
		var RecordType = blob.read_shift(2);
		if(RecordType === 0 &amp;&amp; last_Rn === &#x27;EOF&#x27;) break;
		var length = (blob.l === blob.length ? 0 : blob.read_shift(2)), y;
		var R = XLSRecordEnum[RecordType];
		if(R &amp;&amp; R.f) {
			if(options.bookSheets) {
				if(last_Rn === &#x27;BoundSheet8&#x27; &amp;&amp; R.n !== &#x27;BoundSheet8&#x27;) break;
			}
			last_Rn = R.n;
			if(R.r === 2 || R.r == 12) {
				var rt = blob.read_shift(2); length -= 2;
				if(!opts.enc &amp;&amp; rt !== RecordType) throw &quot;rt mismatch&quot;;
				if(R.r == 12){ blob.l += 10; length -= 10; } // skip FRT
			}
			//console.error(R,blob.l,length,blob.length);
			var val;
			if(R.n === &#x27;EOF&#x27;) val = R.f(blob, length, opts);
			else val = slurp(R, blob, length, opts);
			var Rn = R.n;
			/* BIFF5 overrides */
			if(opts.biff === 5 || opts.biff === 2) switch(Rn) {
				case &#x27;Lbl&#x27;: Rn = &#x27;Label&#x27;; break;
			}
			/* nested switch statements to workaround V8 128 limit */
			switch(Rn) {
				/* Workbook Options */
				case &#x27;Date1904&#x27;: wb.opts.Date1904 = val; break;
				case &#x27;WriteProtect&#x27;: wb.opts.WriteProtect = true; break;
				case &#x27;FilePass&#x27;:
					if(!opts.enc) blob.l = 0;
					opts.enc = val;
					if(opts.WTF) console.error(val);
					if(!options.password) throw new Error(&quot;File is password-protected&quot;);
					if(val.Type !== 0) throw new Error(&quot;Encryption scheme unsupported&quot;);
					if(!val.valid) throw new Error(&quot;Password is incorrect&quot;);
					break;
				case &#x27;WriteAccess&#x27;: opts.lastuser = val; break;
				case &#x27;FileSharing&#x27;: break; //TODO
				case &#x27;CodePage&#x27;:
					/* overrides based on test cases */
					if(val === 0x5212) val = 1200;
					else if(val === 0x8001) val = 1252;
					opts.codepage = val;
					set_cp(val);
					break;
				case &#x27;RRTabId&#x27;: opts.rrtabid = val; break;
				case &#x27;WinProtect&#x27;: opts.winlocked = val; break;
				case &#x27;Template&#x27;: break; // TODO
				case &#x27;RefreshAll&#x27;: wb.opts.RefreshAll = val; break;
				case &#x27;BookBool&#x27;: break; // TODO
				case &#x27;UsesELFs&#x27;: /* if(val) console.error(&quot;Unsupported ELFs&quot;); */ break;
				case &#x27;MTRSettings&#x27;: {
					if(val[0] &amp;&amp; val[1]) throw &quot;Unsupported threads: &quot; + val;
				} break; // TODO: actually support threads
				case &#x27;CalcCount&#x27;: wb.opts.CalcCount = val; break;
				case &#x27;CalcDelta&#x27;: wb.opts.CalcDelta = val; break;
				case &#x27;CalcIter&#x27;: wb.opts.CalcIter = val; break;
				case &#x27;CalcMode&#x27;: wb.opts.CalcMode = val; break;
				case &#x27;CalcPrecision&#x27;: wb.opts.CalcPrecision = val; break;
				case &#x27;CalcSaveRecalc&#x27;: wb.opts.CalcSaveRecalc = val; break;
				case &#x27;CalcRefMode&#x27;: opts.CalcRefMode = val; break; // TODO: implement R1C1
				case &#x27;Uncalced&#x27;: break;
				case &#x27;ForceFullCalculation&#x27;: wb.opts.FullCalc = val; break;
				case &#x27;WsBool&#x27;: break; // TODO
				case &#x27;XF&#x27;: XFs.push(val); break;
				case &#x27;ExtSST&#x27;: break; // TODO
				case &#x27;BookExt&#x27;: break; // TODO
				case &#x27;RichTextStream&#x27;: break;
				case &#x27;BkHim&#x27;: break;

				case &#x27;SupBook&#x27;: supbooks[++sbc] = [val]; sbci = 0; break;
				case &#x27;ExternName&#x27;: supbooks[sbc][++sbci] = val; break;
				case &#x27;Index&#x27;: break; // TODO
				case &#x27;Lbl&#x27;: supbooks[0][++sbcli] = val; break;
				case &#x27;ExternSheet&#x27;: supbooks[sbc] = supbooks[sbc].concat(val); sbci += val.length; break;

				case &#x27;Protect&#x27;: out[&quot;!protect&quot;] = val; break; /* for sheet or book */
				case &#x27;Password&#x27;: if(val !== 0 &amp;&amp; opts.WTF) console.error(&quot;Password verifier: &quot; + val); break;
				case &#x27;Prot4Rev&#x27;: case &#x27;Prot4RevPass&#x27;: break; /*TODO: Revision Control*/

				case &#x27;BoundSheet8&#x27;: {
					Directory[val.pos] = val;
					opts.snames.push(val.name);
				} break;
				case &#x27;EOF&#x27;: {
					if(--file_depth) break;
					if(range.e) {
						out[&quot;!range&quot;] = range;
						if(range.e.r &gt; 0 &amp;&amp; range.e.c &gt; 0) {
							range.e.r--; range.e.c--;
							out[&quot;!ref&quot;] = encode_range(range);
							range.e.r++; range.e.c++;
						}
						if(mergecells.length &gt; 0) out[&quot;!merges&quot;] = mergecells;
						if(objects.length &gt; 0) out[&quot;!objects&quot;] = objects;
					}
					if(cur_sheet === &quot;&quot;) Preamble = out; else Sheets[cur_sheet] = out;
					out = {};
				} break;
				case &#x27;BOF&#x27;: {
					if(opts.biff !== 8);
					else if(val.BIFFVer === 0x0500) opts.biff = 5;
					else if(val.BIFFVer === 0x0002) opts.biff = 2;
					else if(val.BIFFVer === 0x0007) opts.biff = 2;
					if(file_depth++) break;
					cell_valid = true;
					out = {};
					if(opts.biff === 2) {
						if(cur_sheet === &quot;&quot;) cur_sheet = &quot;Sheet1&quot;;
						range = {s:{r:0,c:0},e:{r:0,c:0}};
					}
					else cur_sheet = (Directory[s] || {name:&quot;&quot;}).name;
					mergecells = [];
					objects = [];
				} break;
				case &#x27;Number&#x27;: case &#x27;BIFF2NUM&#x27;: {
					temp_val = {ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.val, t:&#x27;n&#x27;};
					if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({c:val.c, r:val.r}, temp_val, options);
				} break;
				case &#x27;BoolErr&#x27;: {
					temp_val = {ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.val, t:val.t};
					if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({c:val.c, r:val.r}, temp_val, options);
				} break;
				case &#x27;RK&#x27;: {
					temp_val = {ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.rknum, t:&#x27;n&#x27;};
					if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({c:val.c, r:val.r}, temp_val, options);
				} break;
				case &#x27;MulRk&#x27;: {
					for(var j = val.c; j &lt;= val.C; ++j) {
						var ixfe = val.rkrec[j-val.c][0];
						temp_val= {ixfe:ixfe, XF:XFs[ixfe], v:val.rkrec[j-val.c][1], t:&#x27;n&#x27;};
						if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
						addcell({c:j, r:val.r}, temp_val, options);
					}
				} break;
				case &#x27;Formula&#x27;: {
					switch(val.val) {
						case &#x27;String&#x27;: last_formula = val; break;
						case &#x27;Array Formula&#x27;: throw &quot;Array Formula unsupported&quot;;
						default:
							temp_val = {v:val.val, ixfe:val.cell.ixfe, t:val.tt};
							temp_val.XF = XFs[temp_val.ixfe];
							if(options.cellFormula) temp_val.f = &quot;=&quot;+stringify_formula(val.formula,range,val.cell,supbooks, opts);
							if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
							addcell(val.cell, temp_val, options);
							last_formula = val;
					}
				} break;
				case &#x27;String&#x27;: {
					if(last_formula) {
						last_formula.val = val;
						temp_val = {v:last_formula.val, ixfe:last_formula.cell.ixfe, t:&#x27;s&#x27;};
						temp_val.XF = XFs[temp_val.ixfe];
						if(options.cellFormula) temp_val.f = &quot;=&quot;+stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
						if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
						addcell(last_formula.cell, temp_val, options);
						last_formula = null;
					}
				} break;
				case &#x27;Array&#x27;: {
					array_formulae.push(val);
				} break;
				case &#x27;ShrFmla&#x27;: {
					if(!cell_valid) break;
					//if(options.cellFormula) out[last_cell].f = stringify_formula(val[0], range, lastcell, supbooks, opts);
					/* TODO: capture range */
					shared_formulae[encode_cell(last_formula.cell)]= val[0];
				} break;
				case &#x27;LabelSst&#x27;:
					//temp_val={v:sst[val.isst].t, ixfe:val.ixfe, t:&#x27;s&#x27;};
					temp_val=make_cell(sst[val.isst].t, val.ixfe, &#x27;s&#x27;);
					temp_val.XF = XFs[temp_val.ixfe];
					if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({c:val.c, r:val.r}, temp_val, options);
					break;
				case &#x27;Label&#x27;: case &#x27;BIFF2STR&#x27;:
					/* Some writers erroneously write Label */
					temp_val=make_cell(val.val, val.ixfe, &#x27;s&#x27;);
					temp_val.XF = XFs[temp_val.ixfe];
					if(temp_val.XF) safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({c:val.c, r:val.r}, temp_val, options);
					break;
				case &#x27;Dimensions&#x27;: {
					if(file_depth === 1) range = val; /* TODO: stack */
				} break;
				case &#x27;SST&#x27;: {
					sst = val;
				} break;
				case &#x27;Format&#x27;: { /* val = [id, fmt] */
					SSF.load(val[1], val[0]);
				} break;

				case &#x27;MergeCells&#x27;: mergecells = mergecells.concat(val); break;

				case &#x27;Obj&#x27;: objects[val.cmo[0]] = opts.lastobj = val; break;
				case &#x27;TxO&#x27;: opts.lastobj.TxO = val; break;

				case &#x27;HLink&#x27;: {
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC)
							if(out[encode_cell({c:rngC,r:rngR})])
								out[encode_cell({c:rngC,r:rngR})].l = val[1];
				} break;
				case &#x27;HLinkTooltip&#x27;: {
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC)
							if(out[encode_cell({c:rngC,r:rngR})])
								out[encode_cell({c:rngC,r:rngR})].l.tooltip = val[1];
				} break;

				/* Comments */
				case &#x27;Note&#x27;: {
					if(opts.biff &lt;= 5 &amp;&amp; opts.biff &gt;= 2) break; /* TODO: BIFF5 */
					cc = out[encode_cell(val[0])];
					var noteobj = objects[val[2]];
					if(!cc) break;
					if(!cc.c) cc.c = [];
					cmnt = {a:val[1],t:noteobj.TxO.t};
					cc.c.push(cmnt);
				} break;

				default: switch(R.n) { /* nested */
				case &#x27;ClrtClient&#x27;: break;
				case &#x27;XFExt&#x27;: update_xfext(XFs[val.ixfe], val.ext); break;

				case &#x27;NameCmt&#x27;: break;
				case &#x27;Header&#x27;: break; // TODO
				case &#x27;Footer&#x27;: break; // TODO
				case &#x27;HCenter&#x27;: break; // TODO
				case &#x27;VCenter&#x27;: break; // TODO
				case &#x27;Pls&#x27;: break; // TODO
				case &#x27;Setup&#x27;: break; // TODO
				case &#x27;DefColWidth&#x27;: break; // TODO
				case &#x27;GCW&#x27;: break;
				case &#x27;LHRecord&#x27;: break;
				case &#x27;ColInfo&#x27;: break; // TODO
				case &#x27;Row&#x27;: break; // TODO
				case &#x27;DBCell&#x27;: break; // TODO
				case &#x27;MulBlank&#x27;: break; // TODO
				case &#x27;EntExU2&#x27;: break; // TODO
				case &#x27;SxView&#x27;: break; // TODO
				case &#x27;Sxvd&#x27;: break; // TODO
				case &#x27;SXVI&#x27;: break; // TODO
				case &#x27;SXVDEx&#x27;: break; // TODO
				case &#x27;SxIvd&#x27;: break; // TODO
				case &#x27;SXDI&#x27;: break; // TODO
				case &#x27;SXLI&#x27;: break; // TODO
				case &#x27;SXEx&#x27;: break; // TODO
				case &#x27;QsiSXTag&#x27;: break; // TODO
				case &#x27;Selection&#x27;: break;
				case &#x27;Feat&#x27;: break;
				case &#x27;FeatHdr&#x27;: case &#x27;FeatHdr11&#x27;: break;
				case &#x27;Feature11&#x27;: case &#x27;Feature12&#x27;: case &#x27;List12&#x27;: break;
				case &#x27;Blank&#x27;: break;
				case &#x27;Country&#x27;: country = val; break;
				case &#x27;RecalcId&#x27;: break;
				case &#x27;DefaultRowHeight&#x27;: case &#x27;DxGCol&#x27;: break; // TODO: htmlify
				case &#x27;Fbi&#x27;: case &#x27;Fbi2&#x27;: case &#x27;GelFrame&#x27;: break;
				case &#x27;Font&#x27;: break; // TODO
				case &#x27;XFCRC&#x27;: break; // TODO
				case &#x27;Style&#x27;: break; // TODO
				case &#x27;StyleExt&#x27;: break; // TODO
				case &#x27;Palette&#x27;: palette = val; break; // TODO
				case &#x27;Theme&#x27;: break; // TODO
				/* Protection */
				case &#x27;ScenarioProtect&#x27;: break;
				case &#x27;ObjProtect&#x27;: break;

				/* Conditional Formatting */
				case &#x27;CondFmt12&#x27;: break;

				/* Table */
				case &#x27;Table&#x27;: break; // TODO
				case &#x27;TableStyles&#x27;: break; // TODO
				case &#x27;TableStyle&#x27;: break; // TODO
				case &#x27;TableStyleElement&#x27;: break; // TODO

				/* PivotTable */
				case &#x27;SXStreamID&#x27;: break; // TODO
				case &#x27;SXVS&#x27;: break; // TODO
				case &#x27;DConRef&#x27;: break; // TODO
				case &#x27;SXAddl&#x27;: break; // TODO
				case &#x27;DConBin&#x27;: break; // TODO
				case &#x27;DConName&#x27;: break; // TODO
				case &#x27;SXPI&#x27;: break; // TODO
				case &#x27;SxFormat&#x27;: break; // TODO
				case &#x27;SxSelect&#x27;: break; // TODO
				case &#x27;SxRule&#x27;: break; // TODO
				case &#x27;SxFilt&#x27;: break; // TODO
				case &#x27;SxItm&#x27;: break; // TODO
				case &#x27;SxDXF&#x27;: break; // TODO

				/* Scenario Manager */
				case &#x27;ScenMan&#x27;: break;

				/* Data Consolidation */
				case &#x27;DCon&#x27;: break;

				/* Watched Cell */
				case &#x27;CellWatch&#x27;: break;

				/* Print Settings */
				case &#x27;PrintRowCol&#x27;: break;
				case &#x27;PrintGrid&#x27;: break;
				case &#x27;PrintSize&#x27;: break;

				case &#x27;XCT&#x27;: break;
				case &#x27;CRN&#x27;: break;

				case &#x27;Scl&#x27;: {
					//console.log(&quot;Zoom Level:&quot;, val[0]/val[1],val);
				} break;
				case &#x27;SheetExt&#x27;: {

				} break;
				case &#x27;SheetExtOptional&#x27;: {

				} break;

				/* VBA */
				case &#x27;ObNoMacros&#x27;: {

				} break;
				case &#x27;ObProj&#x27;: {

				} break;
				case &#x27;CodeName&#x27;: {

				} break;
				case &#x27;GUIDTypeLib&#x27;: {

				} break;

				case &#x27;WOpt&#x27;: break; // TODO: WTF?
				case &#x27;PhoneticInfo&#x27;: break;

				case &#x27;OleObjectSize&#x27;: break;

				/* Differential Formatting */
				case &#x27;DXF&#x27;: case &#x27;DXFN&#x27;: case &#x27;DXFN12&#x27;: case &#x27;DXFN12List&#x27;: case &#x27;DXFN12NoCB&#x27;: break;

				/* Data Validation */
				case &#x27;Dv&#x27;: case &#x27;DVal&#x27;: break;

				/* Data Series */
				case &#x27;BRAI&#x27;: case &#x27;Series&#x27;: case &#x27;SeriesText&#x27;: break;

				/* Data Connection */
				case &#x27;DConn&#x27;: break;
				case &#x27;DbOrParamQry&#x27;: break;
				case &#x27;DBQueryExt&#x27;: break;

				/* Formatting */
				case &#x27;IFmtRecord&#x27;: break;
				case &#x27;CondFmt&#x27;: case &#x27;CF&#x27;: case &#x27;CF12&#x27;: case &#x27;CFEx&#x27;: break;

				/* Explicitly Ignored */
				case &#x27;Excel9File&#x27;: break;
				case &#x27;Units&#x27;: break;
				case &#x27;InterfaceHdr&#x27;: case &#x27;Mms&#x27;: case &#x27;InterfaceEnd&#x27;: case &#x27;DSF&#x27;: case &#x27;BuiltInFnGroupCount&#x27;:
				/* View Stuff */
				case &#x27;Window1&#x27;: case &#x27;Window2&#x27;: case &#x27;HideObj&#x27;: case &#x27;GridSet&#x27;: case &#x27;Guts&#x27;:
				case &#x27;UserBView&#x27;: case &#x27;UserSViewBegin&#x27;: case &#x27;UserSViewEnd&#x27;:
				case &#x27;Pane&#x27;: break;
				default: switch(R.n) { /* nested */
				/* Chart */
				case &#x27;Dat&#x27;:
				case &#x27;Begin&#x27;: case &#x27;End&#x27;:
				case &#x27;StartBlock&#x27;: case &#x27;EndBlock&#x27;:
				case &#x27;Frame&#x27;: case &#x27;Area&#x27;:
				case &#x27;Axis&#x27;: case &#x27;AxisLine&#x27;: case &#x27;Tick&#x27;: break;
				case &#x27;AxesUsed&#x27;:
				case &#x27;CrtLayout12&#x27;: case &#x27;CrtLayout12A&#x27;: case &#x27;CrtLink&#x27;: case &#x27;CrtLine&#x27;: case &#x27;CrtMlFrt&#x27;: case &#x27;CrtMlFrtContinue&#x27;: break;
				case &#x27;LineFormat&#x27;: case &#x27;AreaFormat&#x27;:
				case &#x27;Chart&#x27;: case &#x27;Chart3d&#x27;: case &#x27;Chart3DBarShape&#x27;: case &#x27;ChartFormat&#x27;: case &#x27;ChartFrtInfo&#x27;: break;
				case &#x27;PlotArea&#x27;: case &#x27;PlotGrowth&#x27;: break;
				case &#x27;SeriesList&#x27;: case &#x27;SerParent&#x27;: case &#x27;SerAuxTrend&#x27;: break;
				case &#x27;DataFormat&#x27;: case &#x27;SerToCrt&#x27;: case &#x27;FontX&#x27;: break;
				case &#x27;CatSerRange&#x27;: case &#x27;AxcExt&#x27;: case &#x27;SerFmt&#x27;: break;
				case &#x27;ShtProps&#x27;: break;
				case &#x27;DefaultText&#x27;: case &#x27;Text&#x27;: case &#x27;CatLab&#x27;: break;
				case &#x27;DataLabExtContents&#x27;: break;
				case &#x27;Legend&#x27;: case &#x27;LegendException&#x27;: break;
				case &#x27;Pie&#x27;: case &#x27;Scatter&#x27;: break;
				case &#x27;PieFormat&#x27;: case &#x27;MarkerFormat&#x27;: break;
				case &#x27;StartObject&#x27;: case &#x27;EndObject&#x27;: break;
				case &#x27;AlRuns&#x27;: case &#x27;ObjectLink&#x27;: break;
				case &#x27;SIIndex&#x27;: break;
				case &#x27;AttachedLabel&#x27;: case &#x27;YMult&#x27;: break;

				/* Chart Group */
				case &#x27;Line&#x27;: case &#x27;Bar&#x27;: break;
				case &#x27;Surf&#x27;: break;

				/* Axis Group */
				case &#x27;AxisParent&#x27;: break;
				case &#x27;Pos&#x27;: break;
				case &#x27;ValueRange&#x27;: break;

				/* Pivot Chart */
				case &#x27;SXViewEx9&#x27;: break; // TODO
				case &#x27;SXViewLink&#x27;: break;
				case &#x27;PivotChartBits&#x27;: break;
				case &#x27;SBaseRef&#x27;: break;
				case &#x27;TextPropsStream&#x27;: break;

				/* Chart Misc */
				case &#x27;LnExt&#x27;: break;
				case &#x27;MkrExt&#x27;: break;
				case &#x27;CrtCoopt&#x27;: break;

				/* Query Table */
				case &#x27;Qsi&#x27;: case &#x27;Qsif&#x27;: case &#x27;Qsir&#x27;: case &#x27;QsiSXTag&#x27;: break;
				case &#x27;TxtQry&#x27;: break;

				/* Filter */
				case &#x27;FilterMode&#x27;: break;
				case &#x27;AutoFilter&#x27;: case &#x27;AutoFilterInfo&#x27;: break;
				case &#x27;AutoFilter12&#x27;: break;
				case &#x27;DropDownObjIds&#x27;: break;
				case &#x27;Sort&#x27;: break;
				case &#x27;SortData&#x27;: break;

				/* Drawing */
				case &#x27;ShapePropsStream&#x27;: break;
				case &#x27;MsoDrawing&#x27;: case &#x27;MsoDrawingGroup&#x27;: case &#x27;MsoDrawingSelection&#x27;: break;
				case &#x27;ImData&#x27;: break;
				/* Pub Stuff */
				case &#x27;WebPub&#x27;: case &#x27;AutoWebPub&#x27;:

				/* Print Stuff */
				case &#x27;RightMargin&#x27;: case &#x27;LeftMargin&#x27;: case &#x27;TopMargin&#x27;: case &#x27;BottomMargin&#x27;:
				case &#x27;HeaderFooter&#x27;: case &#x27;HFPicture&#x27;: case &#x27;PLV&#x27;:
				case &#x27;HorizontalPageBreaks&#x27;: case &#x27;VerticalPageBreaks&#x27;:
				/* Behavioral */
				case &#x27;Backup&#x27;: case &#x27;CompressPictures&#x27;: case &#x27;Compat12&#x27;: break;

				/* Should not Happen */
				case &#x27;Continue&#x27;: case &#x27;ContinueFrt12&#x27;: break;

				/* Future Records */
				case &#x27;FrtFontList&#x27;: case &#x27;FrtWrapper&#x27;: break;

				/* BIFF5 records */
				case &#x27;ExternCount&#x27;: break;
				case &#x27;RString&#x27;: break;
				case &#x27;TabIdConf&#x27;: case &#x27;Radar&#x27;: case &#x27;RadarArea&#x27;: case &#x27;DropBar&#x27;: case &#x27;Intl&#x27;: case &#x27;CoordList&#x27;: case &#x27;SerAuxErrBar&#x27;: break;

				default: switch(R.n) { /* nested */
				/* Miscellaneous */
				case &#x27;SCENARIO&#x27;: case &#x27;DConBin&#x27;: case &#x27;PicF&#x27;: case &#x27;DataLabExt&#x27;:
				case &#x27;Lel&#x27;: case &#x27;BopPop&#x27;: case &#x27;BopPopCustom&#x27;: case &#x27;RealTimeData&#x27;:
				case &#x27;Name&#x27;: break;
				default: if(options.WTF) throw &#x27;Unrecognized Record &#x27; + R.n;
			}}}}
		} else blob.l += length;
	}
	var sheetnamesraw = opts.biff === 2 ? [&#x27;Sheet1&#x27;] : Object.keys(Directory).sort(function(a,b) { return Number(a) - Number(b); }).map(function(x){return Directory[x].name;});
	var sheetnames = sheetnamesraw.slice();
	wb.Directory=sheetnamesraw;
	wb.SheetNames=sheetnamesraw;
	if(!options.bookSheets) wb.Sheets=Sheets;
	wb.Preamble=Preamble;
	wb.Strings = sst;
	wb.SSF = SSF.get_table();
	if(opts.enc) wb.Encryption = opts.enc;
	wb.Metadata = {};
	if(country !== undefined) wb.Metadata.Country = country;
	return wb;
}

function parse_xlscfb(cfb, options) {
if(!options) options = {};
fix_read_opts(options);
reset_cp();
var CompObj, Summary, Workbook;
if(cfb.find) {
	CompObj = cfb.find(&#x27;!CompObj&#x27;);
	Summary = cfb.find(&#x27;!SummaryInformation&#x27;);
	Workbook = cfb.find(&#x27;/Workbook&#x27;);
} else {
	prep_blob(cfb, 0);
	Workbook = {content: cfb};
}

if(!Workbook) Workbook = cfb.find(&#x27;/Book&#x27;);
var CompObjP, SummaryP, WorkbookP;

if(CompObj) CompObjP = parse_compobj(CompObj);
if(options.bookProps &amp;&amp; !options.bookSheets) WorkbookP = {};
else {
	if(Workbook) WorkbookP = parse_workbook(Workbook.content, options, !!Workbook.find);
	else throw new Error(&quot;Cannot find Workbook stream&quot;);
}

if(cfb.find) parse_props(cfb);

var props = {};
for(var y in cfb.Summary) props[y] = cfb.Summary[y];
for(y in cfb.DocSummary) props[y] = cfb.DocSummary[y];
WorkbookP.Props = WorkbookP.Custprops = props; /* TODO: split up properties */
if(options.bookFiles) WorkbookP.cfb = cfb;
WorkbookP.CompObjP = CompObjP;
return WorkbookP;
}

/* TODO: WTF */
function parse_props(cfb) {
	/* [MS-OSHARED] 2.3.3.2.2 Document Summary Information Property Set */
	var DSI = cfb.find(&#x27;!DocumentSummaryInformation&#x27;);
	if(DSI) try { cfb.DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI); } catch(e) {}

	/* [MS-OSHARED] 2.3.3.2.1 Summary Information Property Set*/
	var SI = cfb.find(&#x27;!SummaryInformation&#x27;);
	if(SI) try { cfb.Summary = parse_PropertySetStream(SI, SummaryPIDSI); } catch(e) {}
}

/* [MS-XLSB] 2.3 Record Enumeration */
var XLSBRecordEnum = {
	0x0000: { n:&quot;BrtRowHdr&quot;, f:parse_BrtRowHdr },
	0x0001: { n:&quot;BrtCellBlank&quot;, f:parse_BrtCellBlank },
	0x0002: { n:&quot;BrtCellRk&quot;, f:parse_BrtCellRk },
	0x0003: { n:&quot;BrtCellError&quot;, f:parse_BrtCellError },
	0x0004: { n:&quot;BrtCellBool&quot;, f:parse_BrtCellBool },
	0x0005: { n:&quot;BrtCellReal&quot;, f:parse_BrtCellReal },
	0x0006: { n:&quot;BrtCellSt&quot;, f:parse_BrtCellSt },
	0x0007: { n:&quot;BrtCellIsst&quot;, f:parse_BrtCellIsst },
	0x0008: { n:&quot;BrtFmlaString&quot;, f:parse_BrtFmlaString },
	0x0009: { n:&quot;BrtFmlaNum&quot;, f:parse_BrtFmlaNum },
	0x000A: { n:&quot;BrtFmlaBool&quot;, f:parse_BrtFmlaBool },
	0x000B: { n:&quot;BrtFmlaError&quot;, f:parse_BrtFmlaError },
	0x0010: { n:&quot;BrtFRTArchID$&quot;, f:parse_BrtFRTArchID$ },
	0x0013: { n:&quot;BrtSSTItem&quot;, f:parse_RichStr },
	0x0014: { n:&quot;BrtPCDIMissing&quot;, f:parsenoop },
	0x0015: { n:&quot;BrtPCDINumber&quot;, f:parsenoop },
	0x0016: { n:&quot;BrtPCDIBoolean&quot;, f:parsenoop },
	0x0017: { n:&quot;BrtPCDIError&quot;, f:parsenoop },
	0x0018: { n:&quot;BrtPCDIString&quot;, f:parsenoop },
	0x0019: { n:&quot;BrtPCDIDatetime&quot;, f:parsenoop },
	0x001A: { n:&quot;BrtPCDIIndex&quot;, f:parsenoop },
	0x001B: { n:&quot;BrtPCDIAMissing&quot;, f:parsenoop },
	0x001C: { n:&quot;BrtPCDIANumber&quot;, f:parsenoop },
	0x001D: { n:&quot;BrtPCDIABoolean&quot;, f:parsenoop },
	0x001E: { n:&quot;BrtPCDIAError&quot;, f:parsenoop },
	0x001F: { n:&quot;BrtPCDIAString&quot;, f:parsenoop },
	0x0020: { n:&quot;BrtPCDIADatetime&quot;, f:parsenoop },
	0x0021: { n:&quot;BrtPCRRecord&quot;, f:parsenoop },
	0x0022: { n:&quot;BrtPCRRecordDt&quot;, f:parsenoop },
	0x0023: { n:&quot;BrtFRTBegin&quot;, f:parsenoop },
	0x0024: { n:&quot;BrtFRTEnd&quot;, f:parsenoop },
	0x0025: { n:&quot;BrtACBegin&quot;, f:parsenoop },
	0x0026: { n:&quot;BrtACEnd&quot;, f:parsenoop },
	0x0027: { n:&quot;BrtName&quot;, f:parsenoop },
	0x0028: { n:&quot;BrtIndexRowBlock&quot;, f:parsenoop },
	0x002A: { n:&quot;BrtIndexBlock&quot;, f:parsenoop },
	0x002B: { n:&quot;BrtFont&quot;, f:parse_BrtFont },
	0x002C: { n:&quot;BrtFmt&quot;, f:parse_BrtFmt },
	0x002D: { n:&quot;BrtFill&quot;, f:parsenoop },
	0x002E: { n:&quot;BrtBorder&quot;, f:parsenoop },
	0x002F: { n:&quot;BrtXF&quot;, f:parse_BrtXF },
	0x0030: { n:&quot;BrtStyle&quot;, f:parsenoop },
	0x0031: { n:&quot;BrtCellMeta&quot;, f:parsenoop },
	0x0032: { n:&quot;BrtValueMeta&quot;, f:parsenoop },
	0x0033: { n:&quot;BrtMdb&quot;, f:parsenoop },
	0x0034: { n:&quot;BrtBeginFmd&quot;, f:parsenoop },
	0x0035: { n:&quot;BrtEndFmd&quot;, f:parsenoop },
	0x0036: { n:&quot;BrtBeginMdx&quot;, f:parsenoop },
	0x0037: { n:&quot;BrtEndMdx&quot;, f:parsenoop },
	0x0038: { n:&quot;BrtBeginMdxTuple&quot;, f:parsenoop },
	0x0039: { n:&quot;BrtEndMdxTuple&quot;, f:parsenoop },
	0x003A: { n:&quot;BrtMdxMbrIstr&quot;, f:parsenoop },
	0x003B: { n:&quot;BrtStr&quot;, f:parsenoop },
	0x003C: { n:&quot;BrtColInfo&quot;, f:parsenoop },
	0x003E: { n:&quot;BrtCellRString&quot;, f:parsenoop },
	0x003F: { n:&quot;BrtCalcChainItem$&quot;, f:parse_BrtCalcChainItem$ },
	0x0040: { n:&quot;BrtDVal&quot;, f:parsenoop },
	0x0041: { n:&quot;BrtSxvcellNum&quot;, f:parsenoop },
	0x0042: { n:&quot;BrtSxvcellStr&quot;, f:parsenoop },
	0x0043: { n:&quot;BrtSxvcellBool&quot;, f:parsenoop },
	0x0044: { n:&quot;BrtSxvcellErr&quot;, f:parsenoop },
	0x0045: { n:&quot;BrtSxvcellDate&quot;, f:parsenoop },
	0x0046: { n:&quot;BrtSxvcellNil&quot;, f:parsenoop },
	0x0080: { n:&quot;BrtFileVersion&quot;, f:parsenoop },
	0x0081: { n:&quot;BrtBeginSheet&quot;, f:parsenoop },
	0x0082: { n:&quot;BrtEndSheet&quot;, f:parsenoop },
	0x0083: { n:&quot;BrtBeginBook&quot;, f:parsenoop, p:0 },
	0x0084: { n:&quot;BrtEndBook&quot;, f:parsenoop },
	0x0085: { n:&quot;BrtBeginWsViews&quot;, f:parsenoop },
	0x0086: { n:&quot;BrtEndWsViews&quot;, f:parsenoop },
	0x0087: { n:&quot;BrtBeginBookViews&quot;, f:parsenoop },
	0x0088: { n:&quot;BrtEndBookViews&quot;, f:parsenoop },
	0x0089: { n:&quot;BrtBeginWsView&quot;, f:parsenoop },
	0x008A: { n:&quot;BrtEndWsView&quot;, f:parsenoop },
	0x008B: { n:&quot;BrtBeginCsViews&quot;, f:parsenoop },
	0x008C: { n:&quot;BrtEndCsViews&quot;, f:parsenoop },
	0x008D: { n:&quot;BrtBeginCsView&quot;, f:parsenoop },
	0x008E: { n:&quot;BrtEndCsView&quot;, f:parsenoop },
	0x008F: { n:&quot;BrtBeginBundleShs&quot;, f:parsenoop },
	0x0090: { n:&quot;BrtEndBundleShs&quot;, f:parsenoop },
	0x0091: { n:&quot;BrtBeginSheetData&quot;, f:parsenoop },
	0x0092: { n:&quot;BrtEndSheetData&quot;, f:parsenoop },
	0x0093: { n:&quot;BrtWsProp&quot;, f:parse_BrtWsProp },
	0x0094: { n:&quot;BrtWsDim&quot;, f:parse_BrtWsDim, p:16 },
	0x0097: { n:&quot;BrtPane&quot;, f:parsenoop },
	0x0098: { n:&quot;BrtSel&quot;, f:parsenoop },
	0x0099: { n:&quot;BrtWbProp&quot;, f:parse_BrtWbProp },
	0x009A: { n:&quot;BrtWbFactoid&quot;, f:parsenoop },
	0x009B: { n:&quot;BrtFileRecover&quot;, f:parsenoop },
	0x009C: { n:&quot;BrtBundleSh&quot;, f:parse_BrtBundleSh },
	0x009D: { n:&quot;BrtCalcProp&quot;, f:parsenoop },
	0x009E: { n:&quot;BrtBookView&quot;, f:parsenoop },
	0x009F: { n:&quot;BrtBeginSst&quot;, f:parse_BrtBeginSst },
	0x00A0: { n:&quot;BrtEndSst&quot;, f:parsenoop },
	0x00A1: { n:&quot;BrtBeginAFilter&quot;, f:parsenoop },
	0x00A2: { n:&quot;BrtEndAFilter&quot;, f:parsenoop },
	0x00A3: { n:&quot;BrtBeginFilterColumn&quot;, f:parsenoop },
	0x00A4: { n:&quot;BrtEndFilterColumn&quot;, f:parsenoop },
	0x00A5: { n:&quot;BrtBeginFilters&quot;, f:parsenoop },
	0x00A6: { n:&quot;BrtEndFilters&quot;, f:parsenoop },
	0x00A7: { n:&quot;BrtFilter&quot;, f:parsenoop },
	0x00A8: { n:&quot;BrtColorFilter&quot;, f:parsenoop },
	0x00A9: { n:&quot;BrtIconFilter&quot;, f:parsenoop },
	0x00AA: { n:&quot;BrtTop10Filter&quot;, f:parsenoop },
	0x00AB: { n:&quot;BrtDynamicFilter&quot;, f:parsenoop },
	0x00AC: { n:&quot;BrtBeginCustomFilters&quot;, f:parsenoop },
	0x00AD: { n:&quot;BrtEndCustomFilters&quot;, f:parsenoop },
	0x00AE: { n:&quot;BrtCustomFilter&quot;, f:parsenoop },
	0x00AF: { n:&quot;BrtAFilterDateGroupItem&quot;, f:parsenoop },
	0x00B0: { n:&quot;BrtMergeCell&quot;, f:parse_BrtMergeCell },
	0x00B1: { n:&quot;BrtBeginMergeCells&quot;, f:parsenoop },
	0x00B2: { n:&quot;BrtEndMergeCells&quot;, f:parsenoop },
	0x00B3: { n:&quot;BrtBeginPivotCacheDef&quot;, f:parsenoop },
	0x00B4: { n:&quot;BrtEndPivotCacheDef&quot;, f:parsenoop },
	0x00B5: { n:&quot;BrtBeginPCDFields&quot;, f:parsenoop },
	0x00B6: { n:&quot;BrtEndPCDFields&quot;, f:parsenoop },
	0x00B7: { n:&quot;BrtBeginPCDField&quot;, f:parsenoop },
	0x00B8: { n:&quot;BrtEndPCDField&quot;, f:parsenoop },
	0x00B9: { n:&quot;BrtBeginPCDSource&quot;, f:parsenoop },
	0x00BA: { n:&quot;BrtEndPCDSource&quot;, f:parsenoop },
	0x00BB: { n:&quot;BrtBeginPCDSRange&quot;, f:parsenoop },
	0x00BC: { n:&quot;BrtEndPCDSRange&quot;, f:parsenoop },
	0x00BD: { n:&quot;BrtBeginPCDFAtbl&quot;, f:parsenoop },
	0x00BE: { n:&quot;BrtEndPCDFAtbl&quot;, f:parsenoop },
	0x00BF: { n:&quot;BrtBeginPCDIRun&quot;, f:parsenoop },
	0x00C0: { n:&quot;BrtEndPCDIRun&quot;, f:parsenoop },
	0x00C1: { n:&quot;BrtBeginPivotCacheRecords&quot;, f:parsenoop },
	0x00C2: { n:&quot;BrtEndPivotCacheRecords&quot;, f:parsenoop },
	0x00C3: { n:&quot;BrtBeginPCDHierarchies&quot;, f:parsenoop },
	0x00C4: { n:&quot;BrtEndPCDHierarchies&quot;, f:parsenoop },
	0x00C5: { n:&quot;BrtBeginPCDHierarchy&quot;, f:parsenoop },
	0x00C6: { n:&quot;BrtEndPCDHierarchy&quot;, f:parsenoop },
	0x00C7: { n:&quot;BrtBeginPCDHFieldsUsage&quot;, f:parsenoop },
	0x00C8: { n:&quot;BrtEndPCDHFieldsUsage&quot;, f:parsenoop },
	0x00C9: { n:&quot;BrtBeginExtConnection&quot;, f:parsenoop },
	0x00CA: { n:&quot;BrtEndExtConnection&quot;, f:parsenoop },
	0x00CB: { n:&quot;BrtBeginECDbProps&quot;, f:parsenoop },
	0x00CC: { n:&quot;BrtEndECDbProps&quot;, f:parsenoop },
	0x00CD: { n:&quot;BrtBeginECOlapProps&quot;, f:parsenoop },
	0x00CE: { n:&quot;BrtEndECOlapProps&quot;, f:parsenoop },
	0x00CF: { n:&quot;BrtBeginPCDSConsol&quot;, f:parsenoop },
	0x00D0: { n:&quot;BrtEndPCDSConsol&quot;, f:parsenoop },
	0x00D1: { n:&quot;BrtBeginPCDSCPages&quot;, f:parsenoop },
	0x00D2: { n:&quot;BrtEndPCDSCPages&quot;, f:parsenoop },
	0x00D3: { n:&quot;BrtBeginPCDSCPage&quot;, f:parsenoop },
	0x00D4: { n:&quot;BrtEndPCDSCPage&quot;, f:parsenoop },
	0x00D5: { n:&quot;BrtBeginPCDSCPItem&quot;, f:parsenoop },
	0x00D6: { n:&quot;BrtEndPCDSCPItem&quot;, f:parsenoop },
	0x00D7: { n:&quot;BrtBeginPCDSCSets&quot;, f:parsenoop },
	0x00D8: { n:&quot;BrtEndPCDSCSets&quot;, f:parsenoop },
	0x00D9: { n:&quot;BrtBeginPCDSCSet&quot;, f:parsenoop },
	0x00DA: { n:&quot;BrtEndPCDSCSet&quot;, f:parsenoop },
	0x00DB: { n:&quot;BrtBeginPCDFGroup&quot;, f:parsenoop },
	0x00DC: { n:&quot;BrtEndPCDFGroup&quot;, f:parsenoop },
	0x00DD: { n:&quot;BrtBeginPCDFGItems&quot;, f:parsenoop },
	0x00DE: { n:&quot;BrtEndPCDFGItems&quot;, f:parsenoop },
	0x00DF: { n:&quot;BrtBeginPCDFGRange&quot;, f:parsenoop },
	0x00E0: { n:&quot;BrtEndPCDFGRange&quot;, f:parsenoop },
	0x00E1: { n:&quot;BrtBeginPCDFGDiscrete&quot;, f:parsenoop },
	0x00E2: { n:&quot;BrtEndPCDFGDiscrete&quot;, f:parsenoop },
	0x00E3: { n:&quot;BrtBeginPCDSDTupleCache&quot;, f:parsenoop },
	0x00E4: { n:&quot;BrtEndPCDSDTupleCache&quot;, f:parsenoop },
	0x00E5: { n:&quot;BrtBeginPCDSDTCEntries&quot;, f:parsenoop },
	0x00E6: { n:&quot;BrtEndPCDSDTCEntries&quot;, f:parsenoop },
	0x00E7: { n:&quot;BrtBeginPCDSDTCEMembers&quot;, f:parsenoop },
	0x00E8: { n:&quot;BrtEndPCDSDTCEMembers&quot;, f:parsenoop },
	0x00E9: { n:&quot;BrtBeginPCDSDTCEMember&quot;, f:parsenoop },
	0x00EA: { n:&quot;BrtEndPCDSDTCEMember&quot;, f:parsenoop },
	0x00EB: { n:&quot;BrtBeginPCDSDTCQueries&quot;, f:parsenoop },
	0x00EC: { n:&quot;BrtEndPCDSDTCQueries&quot;, f:parsenoop },
	0x00ED: { n:&quot;BrtBeginPCDSDTCQuery&quot;, f:parsenoop },
	0x00EE: { n:&quot;BrtEndPCDSDTCQuery&quot;, f:parsenoop },
	0x00EF: { n:&quot;BrtBeginPCDSDTCSets&quot;, f:parsenoop },
	0x00F0: { n:&quot;BrtEndPCDSDTCSets&quot;, f:parsenoop },
	0x00F1: { n:&quot;BrtBeginPCDSDTCSet&quot;, f:parsenoop },
	0x00F2: { n:&quot;BrtEndPCDSDTCSet&quot;, f:parsenoop },
	0x00F3: { n:&quot;BrtBeginPCDCalcItems&quot;, f:parsenoop },
	0x00F4: { n:&quot;BrtEndPCDCalcItems&quot;, f:parsenoop },
	0x00F5: { n:&quot;BrtBeginPCDCalcItem&quot;, f:parsenoop },
	0x00F6: { n:&quot;BrtEndPCDCalcItem&quot;, f:parsenoop },
	0x00F7: { n:&quot;BrtBeginPRule&quot;, f:parsenoop },
	0x00F8: { n:&quot;BrtEndPRule&quot;, f:parsenoop },
	0x00F9: { n:&quot;BrtBeginPRFilters&quot;, f:parsenoop },
	0x00FA: { n:&quot;BrtEndPRFilters&quot;, f:parsenoop },
	0x00FB: { n:&quot;BrtBeginPRFilter&quot;, f:parsenoop },
	0x00FC: { n:&quot;BrtEndPRFilter&quot;, f:parsenoop },
	0x00FD: { n:&quot;BrtBeginPNames&quot;, f:parsenoop },
	0x00FE: { n:&quot;BrtEndPNames&quot;, f:parsenoop },
	0x00FF: { n:&quot;BrtBeginPName&quot;, f:parsenoop },
	0x0100: { n:&quot;BrtEndPName&quot;, f:parsenoop },
	0x0101: { n:&quot;BrtBeginPNPairs&quot;, f:parsenoop },
	0x0102: { n:&quot;BrtEndPNPairs&quot;, f:parsenoop },
	0x0103: { n:&quot;BrtBeginPNPair&quot;, f:parsenoop },
	0x0104: { n:&quot;BrtEndPNPair&quot;, f:parsenoop },
	0x0105: { n:&quot;BrtBeginECWebProps&quot;, f:parsenoop },
	0x0106: { n:&quot;BrtEndECWebProps&quot;, f:parsenoop },
	0x0107: { n:&quot;BrtBeginEcWpTables&quot;, f:parsenoop },
	0x0108: { n:&quot;BrtEndECWPTables&quot;, f:parsenoop },
	0x0109: { n:&quot;BrtBeginECParams&quot;, f:parsenoop },
	0x010A: { n:&quot;BrtEndECParams&quot;, f:parsenoop },
	0x010B: { n:&quot;BrtBeginECParam&quot;, f:parsenoop },
	0x010C: { n:&quot;BrtEndECParam&quot;, f:parsenoop },
	0x010D: { n:&quot;BrtBeginPCDKPIs&quot;, f:parsenoop },
	0x010E: { n:&quot;BrtEndPCDKPIs&quot;, f:parsenoop },
	0x010F: { n:&quot;BrtBeginPCDKPI&quot;, f:parsenoop },
	0x0110: { n:&quot;BrtEndPCDKPI&quot;, f:parsenoop },
	0x0111: { n:&quot;BrtBeginDims&quot;, f:parsenoop },
	0x0112: { n:&quot;BrtEndDims&quot;, f:parsenoop },
	0x0113: { n:&quot;BrtBeginDim&quot;, f:parsenoop },
	0x0114: { n:&quot;BrtEndDim&quot;, f:parsenoop },
	0x0115: { n:&quot;BrtIndexPartEnd&quot;, f:parsenoop },
	0x0116: { n:&quot;BrtBeginStyleSheet&quot;, f:parsenoop },
	0x0117: { n:&quot;BrtEndStyleSheet&quot;, f:parsenoop },
	0x0118: { n:&quot;BrtBeginSXView&quot;, f:parsenoop },
	0x0119: { n:&quot;BrtEndSXVI&quot;, f:parsenoop },
	0x011A: { n:&quot;BrtBeginSXVI&quot;, f:parsenoop },
	0x011B: { n:&quot;BrtBeginSXVIs&quot;, f:parsenoop },
	0x011C: { n:&quot;BrtEndSXVIs&quot;, f:parsenoop },
	0x011D: { n:&quot;BrtBeginSXVD&quot;, f:parsenoop },
	0x011E: { n:&quot;BrtEndSXVD&quot;, f:parsenoop },
	0x011F: { n:&quot;BrtBeginSXVDs&quot;, f:parsenoop },
	0x0120: { n:&quot;BrtEndSXVDs&quot;, f:parsenoop },
	0x0121: { n:&quot;BrtBeginSXPI&quot;, f:parsenoop },
	0x0122: { n:&quot;BrtEndSXPI&quot;, f:parsenoop },
	0x0123: { n:&quot;BrtBeginSXPIs&quot;, f:parsenoop },
	0x0124: { n:&quot;BrtEndSXPIs&quot;, f:parsenoop },
	0x0125: { n:&quot;BrtBeginSXDI&quot;, f:parsenoop },
	0x0126: { n:&quot;BrtEndSXDI&quot;, f:parsenoop },
	0x0127: { n:&quot;BrtBeginSXDIs&quot;, f:parsenoop },
	0x0128: { n:&quot;BrtEndSXDIs&quot;, f:parsenoop },
	0x0129: { n:&quot;BrtBeginSXLI&quot;, f:parsenoop },
	0x012A: { n:&quot;BrtEndSXLI&quot;, f:parsenoop },
	0x012B: { n:&quot;BrtBeginSXLIRws&quot;, f:parsenoop },
	0x012C: { n:&quot;BrtEndSXLIRws&quot;, f:parsenoop },
	0x012D: { n:&quot;BrtBeginSXLICols&quot;, f:parsenoop },
	0x012E: { n:&quot;BrtEndSXLICols&quot;, f:parsenoop },
	0x012F: { n:&quot;BrtBeginSXFormat&quot;, f:parsenoop },
	0x0130: { n:&quot;BrtEndSXFormat&quot;, f:parsenoop },
	0x0131: { n:&quot;BrtBeginSXFormats&quot;, f:parsenoop },
	0x0132: { n:&quot;BrtEndSxFormats&quot;, f:parsenoop },
	0x0133: { n:&quot;BrtBeginSxSelect&quot;, f:parsenoop },
	0x0134: { n:&quot;BrtEndSxSelect&quot;, f:parsenoop },
	0x0135: { n:&quot;BrtBeginISXVDRws&quot;, f:parsenoop },
	0x0136: { n:&quot;BrtEndISXVDRws&quot;, f:parsenoop },
	0x0137: { n:&quot;BrtBeginISXVDCols&quot;, f:parsenoop },
	0x0138: { n:&quot;BrtEndISXVDCols&quot;, f:parsenoop },
	0x0139: { n:&quot;BrtEndSXLocation&quot;, f:parsenoop },
	0x013A: { n:&quot;BrtBeginSXLocation&quot;, f:parsenoop },
	0x013B: { n:&quot;BrtEndSXView&quot;, f:parsenoop },
	0x013C: { n:&quot;BrtBeginSXTHs&quot;, f:parsenoop },
	0x013D: { n:&quot;BrtEndSXTHs&quot;, f:parsenoop },
	0x013E: { n:&quot;BrtBeginSXTH&quot;, f:parsenoop },
	0x013F: { n:&quot;BrtEndSXTH&quot;, f:parsenoop },
	0x0140: { n:&quot;BrtBeginISXTHRws&quot;, f:parsenoop },
	0x0141: { n:&quot;BrtEndISXTHRws&quot;, f:parsenoop },
	0x0142: { n:&quot;BrtBeginISXTHCols&quot;, f:parsenoop },
	0x0143: { n:&quot;BrtEndISXTHCols&quot;, f:parsenoop },
	0x0144: { n:&quot;BrtBeginSXTDMPS&quot;, f:parsenoop },
	0x0145: { n:&quot;BrtEndSXTDMPs&quot;, f:parsenoop },
	0x0146: { n:&quot;BrtBeginSXTDMP&quot;, f:parsenoop },
	0x0147: { n:&quot;BrtEndSXTDMP&quot;, f:parsenoop },
	0x0148: { n:&quot;BrtBeginSXTHItems&quot;, f:parsenoop },
	0x0149: { n:&quot;BrtEndSXTHItems&quot;, f:parsenoop },
	0x014A: { n:&quot;BrtBeginSXTHItem&quot;, f:parsenoop },
	0x014B: { n:&quot;BrtEndSXTHItem&quot;, f:parsenoop },
	0x014C: { n:&quot;BrtBeginMetadata&quot;, f:parsenoop },
	0x014D: { n:&quot;BrtEndMetadata&quot;, f:parsenoop },
	0x014E: { n:&quot;BrtBeginEsmdtinfo&quot;, f:parsenoop },
	0x014F: { n:&quot;BrtMdtinfo&quot;, f:parsenoop },
	0x0150: { n:&quot;BrtEndEsmdtinfo&quot;, f:parsenoop },
	0x0151: { n:&quot;BrtBeginEsmdb&quot;, f:parsenoop },
	0x0152: { n:&quot;BrtEndEsmdb&quot;, f:parsenoop },
	0x0153: { n:&quot;BrtBeginEsfmd&quot;, f:parsenoop },
	0x0154: { n:&quot;BrtEndEsfmd&quot;, f:parsenoop },
	0x0155: { n:&quot;BrtBeginSingleCells&quot;, f:parsenoop },
	0x0156: { n:&quot;BrtEndSingleCells&quot;, f:parsenoop },
	0x0157: { n:&quot;BrtBeginList&quot;, f:parsenoop },
	0x0158: { n:&quot;BrtEndList&quot;, f:parsenoop },
	0x0159: { n:&quot;BrtBeginListCols&quot;, f:parsenoop },
	0x015A: { n:&quot;BrtEndListCols&quot;, f:parsenoop },
	0x015B: { n:&quot;BrtBeginListCol&quot;, f:parsenoop },
	0x015C: { n:&quot;BrtEndListCol&quot;, f:parsenoop },
	0x015D: { n:&quot;BrtBeginListXmlCPr&quot;, f:parsenoop },
	0x015E: { n:&quot;BrtEndListXmlCPr&quot;, f:parsenoop },
	0x015F: { n:&quot;BrtListCCFmla&quot;, f:parsenoop },
	0x0160: { n:&quot;BrtListTrFmla&quot;, f:parsenoop },
	0x0161: { n:&quot;BrtBeginExternals&quot;, f:parsenoop },
	0x0162: { n:&quot;BrtEndExternals&quot;, f:parsenoop },
	0x0163: { n:&quot;BrtSupBookSrc&quot;, f:parsenoop },
	0x0165: { n:&quot;BrtSupSelf&quot;, f:parsenoop },
	0x0166: { n:&quot;BrtSupSame&quot;, f:parsenoop },
	0x0167: { n:&quot;BrtSupTabs&quot;, f:parsenoop },
	0x0168: { n:&quot;BrtBeginSupBook&quot;, f:parsenoop },
	0x0169: { n:&quot;BrtPlaceholderName&quot;, f:parsenoop },
	0x016A: { n:&quot;BrtExternSheet&quot;, f:parsenoop },
	0x016B: { n:&quot;BrtExternTableStart&quot;, f:parsenoop },
	0x016C: { n:&quot;BrtExternTableEnd&quot;, f:parsenoop },
	0x016E: { n:&quot;BrtExternRowHdr&quot;, f:parsenoop },
	0x016F: { n:&quot;BrtExternCellBlank&quot;, f:parsenoop },
	0x0170: { n:&quot;BrtExternCellReal&quot;, f:parsenoop },
	0x0171: { n:&quot;BrtExternCellBool&quot;, f:parsenoop },
	0x0172: { n:&quot;BrtExternCellError&quot;, f:parsenoop },
	0x0173: { n:&quot;BrtExternCellString&quot;, f:parsenoop },
	0x0174: { n:&quot;BrtBeginEsmdx&quot;, f:parsenoop },
	0x0175: { n:&quot;BrtEndEsmdx&quot;, f:parsenoop },
	0x0176: { n:&quot;BrtBeginMdxSet&quot;, f:parsenoop },
	0x0177: { n:&quot;BrtEndMdxSet&quot;, f:parsenoop },
	0x0178: { n:&quot;BrtBeginMdxMbrProp&quot;, f:parsenoop },
	0x0179: { n:&quot;BrtEndMdxMbrProp&quot;, f:parsenoop },
	0x017A: { n:&quot;BrtBeginMdxKPI&quot;, f:parsenoop },
	0x017B: { n:&quot;BrtEndMdxKPI&quot;, f:parsenoop },
	0x017C: { n:&quot;BrtBeginEsstr&quot;, f:parsenoop },
	0x017D: { n:&quot;BrtEndEsstr&quot;, f:parsenoop },
	0x017E: { n:&quot;BrtBeginPRFItem&quot;, f:parsenoop },
	0x017F: { n:&quot;BrtEndPRFItem&quot;, f:parsenoop },
	0x0180: { n:&quot;BrtBeginPivotCacheIDs&quot;, f:parsenoop },
	0x0181: { n:&quot;BrtEndPivotCacheIDs&quot;, f:parsenoop },
	0x0182: { n:&quot;BrtBeginPivotCacheID&quot;, f:parsenoop },
	0x0183: { n:&quot;BrtEndPivotCacheID&quot;, f:parsenoop },
	0x0184: { n:&quot;BrtBeginISXVIs&quot;, f:parsenoop },
	0x0185: { n:&quot;BrtEndISXVIs&quot;, f:parsenoop },
	0x0186: { n:&quot;BrtBeginColInfos&quot;, f:parsenoop },
	0x0187: { n:&quot;BrtEndColInfos&quot;, f:parsenoop },
	0x0188: { n:&quot;BrtBeginRwBrk&quot;, f:parsenoop },
	0x0189: { n:&quot;BrtEndRwBrk&quot;, f:parsenoop },
	0x018A: { n:&quot;BrtBeginColBrk&quot;, f:parsenoop },
	0x018B: { n:&quot;BrtEndColBrk&quot;, f:parsenoop },
	0x018C: { n:&quot;BrtBrk&quot;, f:parsenoop },
	0x018D: { n:&quot;BrtUserBookView&quot;, f:parsenoop },
	0x018E: { n:&quot;BrtInfo&quot;, f:parsenoop },
	0x018F: { n:&quot;BrtCUsr&quot;, f:parsenoop },
	0x0190: { n:&quot;BrtUsr&quot;, f:parsenoop },
	0x0191: { n:&quot;BrtBeginUsers&quot;, f:parsenoop },
	0x0193: { n:&quot;BrtEOF&quot;, f:parsenoop },
	0x0194: { n:&quot;BrtUCR&quot;, f:parsenoop },
	0x0195: { n:&quot;BrtRRInsDel&quot;, f:parsenoop },
	0x0196: { n:&quot;BrtRREndInsDel&quot;, f:parsenoop },
	0x0197: { n:&quot;BrtRRMove&quot;, f:parsenoop },
	0x0198: { n:&quot;BrtRREndMove&quot;, f:parsenoop },
	0x0199: { n:&quot;BrtRRChgCell&quot;, f:parsenoop },
	0x019A: { n:&quot;BrtRREndChgCell&quot;, f:parsenoop },
	0x019B: { n:&quot;BrtRRHeader&quot;, f:parsenoop },
	0x019C: { n:&quot;BrtRRUserView&quot;, f:parsenoop },
	0x019D: { n:&quot;BrtRRRenSheet&quot;, f:parsenoop },
	0x019E: { n:&quot;BrtRRInsertSh&quot;, f:parsenoop },
	0x019F: { n:&quot;BrtRRDefName&quot;, f:parsenoop },
	0x01A0: { n:&quot;BrtRRNote&quot;, f:parsenoop },
	0x01A1: { n:&quot;BrtRRConflict&quot;, f:parsenoop },
	0x01A2: { n:&quot;BrtRRTQSIF&quot;, f:parsenoop },
	0x01A3: { n:&quot;BrtRRFormat&quot;, f:parsenoop },
	0x01A4: { n:&quot;BrtRREndFormat&quot;, f:parsenoop },
	0x01A5: { n:&quot;BrtRRAutoFmt&quot;, f:parsenoop },
	0x01A6: { n:&quot;BrtBeginUserShViews&quot;, f:parsenoop },
	0x01A7: { n:&quot;BrtBeginUserShView&quot;, f:parsenoop },
	0x01A8: { n:&quot;BrtEndUserShView&quot;, f:parsenoop },
	0x01A9: { n:&quot;BrtEndUserShViews&quot;, f:parsenoop },
	0x01AA: { n:&quot;BrtArrFmla&quot;, f:parsenoop },
	0x01AB: { n:&quot;BrtShrFmla&quot;, f:parsenoop },
	0x01AC: { n:&quot;BrtTable&quot;, f:parsenoop },
	0x01AD: { n:&quot;BrtBeginExtConnections&quot;, f:parsenoop },
	0x01AE: { n:&quot;BrtEndExtConnections&quot;, f:parsenoop },
	0x01AF: { n:&quot;BrtBeginPCDCalcMems&quot;, f:parsenoop },
	0x01B0: { n:&quot;BrtEndPCDCalcMems&quot;, f:parsenoop },
	0x01B1: { n:&quot;BrtBeginPCDCalcMem&quot;, f:parsenoop },
	0x01B2: { n:&quot;BrtEndPCDCalcMem&quot;, f:parsenoop },
	0x01B3: { n:&quot;BrtBeginPCDHGLevels&quot;, f:parsenoop },
	0x01B4: { n:&quot;BrtEndPCDHGLevels&quot;, f:parsenoop },
	0x01B5: { n:&quot;BrtBeginPCDHGLevel&quot;, f:parsenoop },
	0x01B6: { n:&quot;BrtEndPCDHGLevel&quot;, f:parsenoop },
	0x01B7: { n:&quot;BrtBeginPCDHGLGroups&quot;, f:parsenoop },
	0x01B8: { n:&quot;BrtEndPCDHGLGroups&quot;, f:parsenoop },
	0x01B9: { n:&quot;BrtBeginPCDHGLGroup&quot;, f:parsenoop },
	0x01BA: { n:&quot;BrtEndPCDHGLGroup&quot;, f:parsenoop },
	0x01BB: { n:&quot;BrtBeginPCDHGLGMembers&quot;, f:parsenoop },
	0x01BC: { n:&quot;BrtEndPCDHGLGMembers&quot;, f:parsenoop },
	0x01BD: { n:&quot;BrtBeginPCDHGLGMember&quot;, f:parsenoop },
	0x01BE: { n:&quot;BrtEndPCDHGLGMember&quot;, f:parsenoop },
	0x01BF: { n:&quot;BrtBeginQSI&quot;, f:parsenoop },
	0x01C0: { n:&quot;BrtEndQSI&quot;, f:parsenoop },
	0x01C1: { n:&quot;BrtBeginQSIR&quot;, f:parsenoop },
	0x01C2: { n:&quot;BrtEndQSIR&quot;, f:parsenoop },
	0x01C3: { n:&quot;BrtBeginDeletedNames&quot;, f:parsenoop },
	0x01C4: { n:&quot;BrtEndDeletedNames&quot;, f:parsenoop },
	0x01C5: { n:&quot;BrtBeginDeletedName&quot;, f:parsenoop },
	0x01C6: { n:&quot;BrtEndDeletedName&quot;, f:parsenoop },
	0x01C7: { n:&quot;BrtBeginQSIFs&quot;, f:parsenoop },
	0x01C8: { n:&quot;BrtEndQSIFs&quot;, f:parsenoop },
	0x01C9: { n:&quot;BrtBeginQSIF&quot;, f:parsenoop },
	0x01CA: { n:&quot;BrtEndQSIF&quot;, f:parsenoop },
	0x01CB: { n:&quot;BrtBeginAutoSortScope&quot;, f:parsenoop },
	0x01CC: { n:&quot;BrtEndAutoSortScope&quot;, f:parsenoop },
	0x01CD: { n:&quot;BrtBeginConditionalFormatting&quot;, f:parsenoop },
	0x01CE: { n:&quot;BrtEndConditionalFormatting&quot;, f:parsenoop },
	0x01CF: { n:&quot;BrtBeginCFRule&quot;, f:parsenoop },
	0x01D0: { n:&quot;BrtEndCFRule&quot;, f:parsenoop },
	0x01D1: { n:&quot;BrtBeginIconSet&quot;, f:parsenoop },
	0x01D2: { n:&quot;BrtEndIconSet&quot;, f:parsenoop },
	0x01D3: { n:&quot;BrtBeginDatabar&quot;, f:parsenoop },
	0x01D4: { n:&quot;BrtEndDatabar&quot;, f:parsenoop },
	0x01D5: { n:&quot;BrtBeginColorScale&quot;, f:parsenoop },
	0x01D6: { n:&quot;BrtEndColorScale&quot;, f:parsenoop },
	0x01D7: { n:&quot;BrtCFVO&quot;, f:parsenoop },
	0x01D8: { n:&quot;BrtExternValueMeta&quot;, f:parsenoop },
	0x01D9: { n:&quot;BrtBeginColorPalette&quot;, f:parsenoop },
	0x01DA: { n:&quot;BrtEndColorPalette&quot;, f:parsenoop },
	0x01DB: { n:&quot;BrtIndexedColor&quot;, f:parsenoop },
	0x01DC: { n:&quot;BrtMargins&quot;, f:parsenoop },
	0x01DD: { n:&quot;BrtPrintOptions&quot;, f:parsenoop },
	0x01DE: { n:&quot;BrtPageSetup&quot;, f:parsenoop },
	0x01DF: { n:&quot;BrtBeginHeaderFooter&quot;, f:parsenoop },
	0x01E0: { n:&quot;BrtEndHeaderFooter&quot;, f:parsenoop },
	0x01E1: { n:&quot;BrtBeginSXCrtFormat&quot;, f:parsenoop },
	0x01E2: { n:&quot;BrtEndSXCrtFormat&quot;, f:parsenoop },
	0x01E3: { n:&quot;BrtBeginSXCrtFormats&quot;, f:parsenoop },
	0x01E4: { n:&quot;BrtEndSXCrtFormats&quot;, f:parsenoop },
	0x01E5: { n:&quot;BrtWsFmtInfo&quot;, f:parsenoop },
	0x01E6: { n:&quot;BrtBeginMgs&quot;, f:parsenoop },
	0x01E7: { n:&quot;BrtEndMGs&quot;, f:parsenoop },
	0x01E8: { n:&quot;BrtBeginMGMaps&quot;, f:parsenoop },
	0x01E9: { n:&quot;BrtEndMGMaps&quot;, f:parsenoop },
	0x01EA: { n:&quot;BrtBeginMG&quot;, f:parsenoop },
	0x01EB: { n:&quot;BrtEndMG&quot;, f:parsenoop },
	0x01EC: { n:&quot;BrtBeginMap&quot;, f:parsenoop },
	0x01ED: { n:&quot;BrtEndMap&quot;, f:parsenoop },
	0x01EE: { n:&quot;BrtHLink&quot;, f:parse_BrtHLink },
	0x01EF: { n:&quot;BrtBeginDCon&quot;, f:parsenoop },
	0x01F0: { n:&quot;BrtEndDCon&quot;, f:parsenoop },
	0x01F1: { n:&quot;BrtBeginDRefs&quot;, f:parsenoop },
	0x01F2: { n:&quot;BrtEndDRefs&quot;, f:parsenoop },
	0x01F3: { n:&quot;BrtDRef&quot;, f:parsenoop },
	0x01F4: { n:&quot;BrtBeginScenMan&quot;, f:parsenoop },
	0x01F5: { n:&quot;BrtEndScenMan&quot;, f:parsenoop },
	0x01F6: { n:&quot;BrtBeginSct&quot;, f:parsenoop },
	0x01F7: { n:&quot;BrtEndSct&quot;, f:parsenoop },
	0x01F8: { n:&quot;BrtSlc&quot;, f:parsenoop },
	0x01F9: { n:&quot;BrtBeginDXFs&quot;, f:parsenoop },
	0x01FA: { n:&quot;BrtEndDXFs&quot;, f:parsenoop },
	0x01FB: { n:&quot;BrtDXF&quot;, f:parsenoop },
	0x01FC: { n:&quot;BrtBeginTableStyles&quot;, f:parsenoop },
	0x01FD: { n:&quot;BrtEndTableStyles&quot;, f:parsenoop },
	0x01FE: { n:&quot;BrtBeginTableStyle&quot;, f:parsenoop },
	0x01FF: { n:&quot;BrtEndTableStyle&quot;, f:parsenoop },
	0x0200: { n:&quot;BrtTableStyleElement&quot;, f:parsenoop },
	0x0201: { n:&quot;BrtTableStyleClient&quot;, f:parsenoop },
	0x0202: { n:&quot;BrtBeginVolDeps&quot;, f:parsenoop },
	0x0203: { n:&quot;BrtEndVolDeps&quot;, f:parsenoop },
	0x0204: { n:&quot;BrtBeginVolType&quot;, f:parsenoop },
	0x0205: { n:&quot;BrtEndVolType&quot;, f:parsenoop },
	0x0206: { n:&quot;BrtBeginVolMain&quot;, f:parsenoop },
	0x0207: { n:&quot;BrtEndVolMain&quot;, f:parsenoop },
	0x0208: { n:&quot;BrtBeginVolTopic&quot;, f:parsenoop },
	0x0209: { n:&quot;BrtEndVolTopic&quot;, f:parsenoop },
	0x020A: { n:&quot;BrtVolSubtopic&quot;, f:parsenoop },
	0x020B: { n:&quot;BrtVolRef&quot;, f:parsenoop },
	0x020C: { n:&quot;BrtVolNum&quot;, f:parsenoop },
	0x020D: { n:&quot;BrtVolErr&quot;, f:parsenoop },
	0x020E: { n:&quot;BrtVolStr&quot;, f:parsenoop },
	0x020F: { n:&quot;BrtVolBool&quot;, f:parsenoop },
	0x0210: { n:&quot;BrtBeginCalcChain$&quot;, f:parsenoop },
	0x0211: { n:&quot;BrtEndCalcChain$&quot;, f:parsenoop },
	0x0212: { n:&quot;BrtBeginSortState&quot;, f:parsenoop },
	0x0213: { n:&quot;BrtEndSortState&quot;, f:parsenoop },
	0x0214: { n:&quot;BrtBeginSortCond&quot;, f:parsenoop },
	0x0215: { n:&quot;BrtEndSortCond&quot;, f:parsenoop },
	0x0216: { n:&quot;BrtBookProtection&quot;, f:parsenoop },
	0x0217: { n:&quot;BrtSheetProtection&quot;, f:parsenoop },
	0x0218: { n:&quot;BrtRangeProtection&quot;, f:parsenoop },
	0x0219: { n:&quot;BrtPhoneticInfo&quot;, f:parsenoop },
	0x021A: { n:&quot;BrtBeginECTxtWiz&quot;, f:parsenoop },
	0x021B: { n:&quot;BrtEndECTxtWiz&quot;, f:parsenoop },
	0x021C: { n:&quot;BrtBeginECTWFldInfoLst&quot;, f:parsenoop },
	0x021D: { n:&quot;BrtEndECTWFldInfoLst&quot;, f:parsenoop },
	0x021E: { n:&quot;BrtBeginECTwFldInfo&quot;, f:parsenoop },
	0x0224: { n:&quot;BrtFileSharing&quot;, f:parsenoop },
	0x0225: { n:&quot;BrtOleSize&quot;, f:parsenoop },
	0x0226: { n:&quot;BrtDrawing&quot;, f:parsenoop },
	0x0227: { n:&quot;BrtLegacyDrawing&quot;, f:parsenoop },
	0x0228: { n:&quot;BrtLegacyDrawingHF&quot;, f:parsenoop },
	0x0229: { n:&quot;BrtWebOpt&quot;, f:parsenoop },
	0x022A: { n:&quot;BrtBeginWebPubItems&quot;, f:parsenoop },
	0x022B: { n:&quot;BrtEndWebPubItems&quot;, f:parsenoop },
	0x022C: { n:&quot;BrtBeginWebPubItem&quot;, f:parsenoop },
	0x022D: { n:&quot;BrtEndWebPubItem&quot;, f:parsenoop },
	0x022E: { n:&quot;BrtBeginSXCondFmt&quot;, f:parsenoop },
	0x022F: { n:&quot;BrtEndSXCondFmt&quot;, f:parsenoop },
	0x0230: { n:&quot;BrtBeginSXCondFmts&quot;, f:parsenoop },
	0x0231: { n:&quot;BrtEndSXCondFmts&quot;, f:parsenoop },
	0x0232: { n:&quot;BrtBkHim&quot;, f:parsenoop },
	0x0234: { n:&quot;BrtColor&quot;, f:parsenoop },
	0x0235: { n:&quot;BrtBeginIndexedColors&quot;, f:parsenoop },
	0x0236: { n:&quot;BrtEndIndexedColors&quot;, f:parsenoop },
	0x0239: { n:&quot;BrtBeginMRUColors&quot;, f:parsenoop },
	0x023A: { n:&quot;BrtEndMRUColors&quot;, f:parsenoop },
	0x023C: { n:&quot;BrtMRUColor&quot;, f:parsenoop },
	0x023D: { n:&quot;BrtBeginDVals&quot;, f:parsenoop },
	0x023E: { n:&quot;BrtEndDVals&quot;, f:parsenoop },
	0x0241: { n:&quot;BrtSupNameStart&quot;, f:parsenoop },
	0x0242: { n:&quot;BrtSupNameValueStart&quot;, f:parsenoop },
	0x0243: { n:&quot;BrtSupNameValueEnd&quot;, f:parsenoop },
	0x0244: { n:&quot;BrtSupNameNum&quot;, f:parsenoop },
	0x0245: { n:&quot;BrtSupNameErr&quot;, f:parsenoop },
	0x0246: { n:&quot;BrtSupNameSt&quot;, f:parsenoop },
	0x0247: { n:&quot;BrtSupNameNil&quot;, f:parsenoop },
	0x0248: { n:&quot;BrtSupNameBool&quot;, f:parsenoop },
	0x0249: { n:&quot;BrtSupNameFmla&quot;, f:parsenoop },
	0x024A: { n:&quot;BrtSupNameBits&quot;, f:parsenoop },
	0x024B: { n:&quot;BrtSupNameEnd&quot;, f:parsenoop },
	0x024C: { n:&quot;BrtEndSupBook&quot;, f:parsenoop },
	0x024D: { n:&quot;BrtCellSmartTagProperty&quot;, f:parsenoop },
	0x024E: { n:&quot;BrtBeginCellSmartTag&quot;, f:parsenoop },
	0x024F: { n:&quot;BrtEndCellSmartTag&quot;, f:parsenoop },
	0x0250: { n:&quot;BrtBeginCellSmartTags&quot;, f:parsenoop },
	0x0251: { n:&quot;BrtEndCellSmartTags&quot;, f:parsenoop },
	0x0252: { n:&quot;BrtBeginSmartTags&quot;, f:parsenoop },
	0x0253: { n:&quot;BrtEndSmartTags&quot;, f:parsenoop },
	0x0254: { n:&quot;BrtSmartTagType&quot;, f:parsenoop },
	0x0255: { n:&quot;BrtBeginSmartTagTypes&quot;, f:parsenoop },
	0x0256: { n:&quot;BrtEndSmartTagTypes&quot;, f:parsenoop },
	0x0257: { n:&quot;BrtBeginSXFilters&quot;, f:parsenoop },
	0x0258: { n:&quot;BrtEndSXFilters&quot;, f:parsenoop },
	0x0259: { n:&quot;BrtBeginSXFILTER&quot;, f:parsenoop },
	0x025A: { n:&quot;BrtEndSXFilter&quot;, f:parsenoop },
	0x025B: { n:&quot;BrtBeginFills&quot;, f:parsenoop },
	0x025C: { n:&quot;BrtEndFills&quot;, f:parsenoop },
	0x025D: { n:&quot;BrtBeginCellWatches&quot;, f:parsenoop },
	0x025E: { n:&quot;BrtEndCellWatches&quot;, f:parsenoop },
	0x025F: { n:&quot;BrtCellWatch&quot;, f:parsenoop },
	0x0260: { n:&quot;BrtBeginCRErrs&quot;, f:parsenoop },
	0x0261: { n:&quot;BrtEndCRErrs&quot;, f:parsenoop },
	0x0262: { n:&quot;BrtCrashRecErr&quot;, f:parsenoop },
	0x0263: { n:&quot;BrtBeginFonts&quot;, f:parsenoop },
	0x0264: { n:&quot;BrtEndFonts&quot;, f:parsenoop },
	0x0265: { n:&quot;BrtBeginBorders&quot;, f:parsenoop },
	0x0266: { n:&quot;BrtEndBorders&quot;, f:parsenoop },
	0x0267: { n:&quot;BrtBeginFmts&quot;, f:parsenoop },
	0x0268: { n:&quot;BrtEndFmts&quot;, f:parsenoop },
	0x0269: { n:&quot;BrtBeginCellXFs&quot;, f:parsenoop },
	0x026A: { n:&quot;BrtEndCellXFs&quot;, f:parsenoop },
	0x026B: { n:&quot;BrtBeginStyles&quot;, f:parsenoop },
	0x026C: { n:&quot;BrtEndStyles&quot;, f:parsenoop },
	0x0271: { n:&quot;BrtBigName&quot;, f:parsenoop },
	0x0272: { n:&quot;BrtBeginCellStyleXFs&quot;, f:parsenoop },
	0x0273: { n:&quot;BrtEndCellStyleXFs&quot;, f:parsenoop },
	0x0274: { n:&quot;BrtBeginComments&quot;, f:parsenoop },
	0x0275: { n:&quot;BrtEndComments&quot;, f:parsenoop },
	0x0276: { n:&quot;BrtBeginCommentAuthors&quot;, f:parsenoop },
	0x0277: { n:&quot;BrtEndCommentAuthors&quot;, f:parsenoop },
	0x0278: { n:&quot;BrtCommentAuthor&quot;, f:parse_BrtCommentAuthor },
	0x0279: { n:&quot;BrtBeginCommentList&quot;, f:parsenoop },
	0x027A: { n:&quot;BrtEndCommentList&quot;, f:parsenoop },
	0x027B: { n:&quot;BrtBeginComment&quot;, f:parse_BrtBeginComment},
	0x027C: { n:&quot;BrtEndComment&quot;, f:parsenoop },
	0x027D: { n:&quot;BrtCommentText&quot;, f:parse_BrtCommentText },
	0x027E: { n:&quot;BrtBeginOleObjects&quot;, f:parsenoop },
	0x027F: { n:&quot;BrtOleObject&quot;, f:parsenoop },
	0x0280: { n:&quot;BrtEndOleObjects&quot;, f:parsenoop },
	0x0281: { n:&quot;BrtBeginSxrules&quot;, f:parsenoop },
	0x0282: { n:&quot;BrtEndSxRules&quot;, f:parsenoop },
	0x0283: { n:&quot;BrtBeginActiveXControls&quot;, f:parsenoop },
	0x0284: { n:&quot;BrtActiveX&quot;, f:parsenoop },
	0x0285: { n:&quot;BrtEndActiveXControls&quot;, f:parsenoop },
	0x0286: { n:&quot;BrtBeginPCDSDTCEMembersSortBy&quot;, f:parsenoop },
	0x0288: { n:&quot;BrtBeginCellIgnoreECs&quot;, f:parsenoop },
	0x0289: { n:&quot;BrtCellIgnoreEC&quot;, f:parsenoop },
	0x028A: { n:&quot;BrtEndCellIgnoreECs&quot;, f:parsenoop },
	0x028B: { n:&quot;BrtCsProp&quot;, f:parsenoop },
	0x028C: { n:&quot;BrtCsPageSetup&quot;, f:parsenoop },
	0x028D: { n:&quot;BrtBeginUserCsViews&quot;, f:parsenoop },
	0x028E: { n:&quot;BrtEndUserCsViews&quot;, f:parsenoop },
	0x028F: { n:&quot;BrtBeginUserCsView&quot;, f:parsenoop },
	0x0290: { n:&quot;BrtEndUserCsView&quot;, f:parsenoop },
	0x0291: { n:&quot;BrtBeginPcdSFCIEntries&quot;, f:parsenoop },
	0x0292: { n:&quot;BrtEndPCDSFCIEntries&quot;, f:parsenoop },
	0x0293: { n:&quot;BrtPCDSFCIEntry&quot;, f:parsenoop },
	0x0294: { n:&quot;BrtBeginListParts&quot;, f:parsenoop },
	0x0295: { n:&quot;BrtListPart&quot;, f:parsenoop },
	0x0296: { n:&quot;BrtEndListParts&quot;, f:parsenoop },
	0x0297: { n:&quot;BrtSheetCalcProp&quot;, f:parsenoop },
	0x0298: { n:&quot;BrtBeginFnGroup&quot;, f:parsenoop },
	0x0299: { n:&quot;BrtFnGroup&quot;, f:parsenoop },
	0x029A: { n:&quot;BrtEndFnGroup&quot;, f:parsenoop },
	0x029B: { n:&quot;BrtSupAddin&quot;, f:parsenoop },
	0x029C: { n:&quot;BrtSXTDMPOrder&quot;, f:parsenoop },
	0x029D: { n:&quot;BrtCsProtection&quot;, f:parsenoop },
	0x029F: { n:&quot;BrtBeginWsSortMap&quot;, f:parsenoop },
	0x02A0: { n:&quot;BrtEndWsSortMap&quot;, f:parsenoop },
	0x02A1: { n:&quot;BrtBeginRRSort&quot;, f:parsenoop },
	0x02A2: { n:&quot;BrtEndRRSort&quot;, f:parsenoop },
	0x02A3: { n:&quot;BrtRRSortItem&quot;, f:parsenoop },
	0x02A4: { n:&quot;BrtFileSharingIso&quot;, f:parsenoop },
	0x02A5: { n:&quot;BrtBookProtectionIso&quot;, f:parsenoop },
	0x02A6: { n:&quot;BrtSheetProtectionIso&quot;, f:parsenoop },
	0x02A7: { n:&quot;BrtCsProtectionIso&quot;, f:parsenoop },
	0x02A8: { n:&quot;BrtRangeProtectionIso&quot;, f:parsenoop },
	0x0400: { n:&quot;BrtRwDescent&quot;, f:parsenoop },
	0x0401: { n:&quot;BrtKnownFonts&quot;, f:parsenoop },
	0x0402: { n:&quot;BrtBeginSXTupleSet&quot;, f:parsenoop },
	0x0403: { n:&quot;BrtEndSXTupleSet&quot;, f:parsenoop },
	0x0404: { n:&quot;BrtBeginSXTupleSetHeader&quot;, f:parsenoop },
	0x0405: { n:&quot;BrtEndSXTupleSetHeader&quot;, f:parsenoop },
	0x0406: { n:&quot;BrtSXTupleSetHeaderItem&quot;, f:parsenoop },
	0x0407: { n:&quot;BrtBeginSXTupleSetData&quot;, f:parsenoop },
	0x0408: { n:&quot;BrtEndSXTupleSetData&quot;, f:parsenoop },
	0x0409: { n:&quot;BrtBeginSXTupleSetRow&quot;, f:parsenoop },
	0x040A: { n:&quot;BrtEndSXTupleSetRow&quot;, f:parsenoop },
	0x040B: { n:&quot;BrtSXTupleSetRowItem&quot;, f:parsenoop },
	0x040C: { n:&quot;BrtNameExt&quot;, f:parsenoop },
	0x040D: { n:&quot;BrtPCDH14&quot;, f:parsenoop },
	0x040E: { n:&quot;BrtBeginPCDCalcMem14&quot;, f:parsenoop },
	0x040F: { n:&quot;BrtEndPCDCalcMem14&quot;, f:parsenoop },
	0x0410: { n:&quot;BrtSXTH14&quot;, f:parsenoop },
	0x0411: { n:&quot;BrtBeginSparklineGroup&quot;, f:parsenoop },
	0x0412: { n:&quot;BrtEndSparklineGroup&quot;, f:parsenoop },
	0x0413: { n:&quot;BrtSparkline&quot;, f:parsenoop },
	0x0414: { n:&quot;BrtSXDI14&quot;, f:parsenoop },
	0x0415: { n:&quot;BrtWsFmtInfoEx14&quot;, f:parsenoop },
	0x0416: { n:&quot;BrtBeginConditionalFormatting14&quot;, f:parsenoop },
	0x0417: { n:&quot;BrtEndConditionalFormatting14&quot;, f:parsenoop },
	0x0418: { n:&quot;BrtBeginCFRule14&quot;, f:parsenoop },
	0x0419: { n:&quot;BrtEndCFRule14&quot;, f:parsenoop },
	0x041A: { n:&quot;BrtCFVO14&quot;, f:parsenoop },
	0x041B: { n:&quot;BrtBeginDatabar14&quot;, f:parsenoop },
	0x041C: { n:&quot;BrtBeginIconSet14&quot;, f:parsenoop },
	0x041D: { n:&quot;BrtDVal14&quot;, f:parsenoop },
	0x041E: { n:&quot;BrtBeginDVals14&quot;, f:parsenoop },
	0x041F: { n:&quot;BrtColor14&quot;, f:parsenoop },
	0x0420: { n:&quot;BrtBeginSparklines&quot;, f:parsenoop },
	0x0421: { n:&quot;BrtEndSparklines&quot;, f:parsenoop },
	0x0422: { n:&quot;BrtBeginSparklineGroups&quot;, f:parsenoop },
	0x0423: { n:&quot;BrtEndSparklineGroups&quot;, f:parsenoop },
	0x0425: { n:&quot;BrtSXVD14&quot;, f:parsenoop },
	0x0426: { n:&quot;BrtBeginSxview14&quot;, f:parsenoop },
	0x0427: { n:&quot;BrtEndSxview14&quot;, f:parsenoop },
	0x042A: { n:&quot;BrtBeginPCD14&quot;, f:parsenoop },
	0x042B: { n:&quot;BrtEndPCD14&quot;, f:parsenoop },
	0x042C: { n:&quot;BrtBeginExtConn14&quot;, f:parsenoop },
	0x042D: { n:&quot;BrtEndExtConn14&quot;, f:parsenoop },
	0x042E: { n:&quot;BrtBeginSlicerCacheIDs&quot;, f:parsenoop },
	0x042F: { n:&quot;BrtEndSlicerCacheIDs&quot;, f:parsenoop },
	0x0430: { n:&quot;BrtBeginSlicerCacheID&quot;, f:parsenoop },
	0x0431: { n:&quot;BrtEndSlicerCacheID&quot;, f:parsenoop },
	0x0433: { n:&quot;BrtBeginSlicerCache&quot;, f:parsenoop },
	0x0434: { n:&quot;BrtEndSlicerCache&quot;, f:parsenoop },
	0x0435: { n:&quot;BrtBeginSlicerCacheDef&quot;, f:parsenoop },
	0x0436: { n:&quot;BrtEndSlicerCacheDef&quot;, f:parsenoop },
	0x0437: { n:&quot;BrtBeginSlicersEx&quot;, f:parsenoop },
	0x0438: { n:&quot;BrtEndSlicersEx&quot;, f:parsenoop },
	0x0439: { n:&quot;BrtBeginSlicerEx&quot;, f:parsenoop },
	0x043A: { n:&quot;BrtEndSlicerEx&quot;, f:parsenoop },
	0x043B: { n:&quot;BrtBeginSlicer&quot;, f:parsenoop },
	0x043C: { n:&quot;BrtEndSlicer&quot;, f:parsenoop },
	0x043D: { n:&quot;BrtSlicerCachePivotTables&quot;, f:parsenoop },
	0x043E: { n:&quot;BrtBeginSlicerCacheOlapImpl&quot;, f:parsenoop },
	0x043F: { n:&quot;BrtEndSlicerCacheOlapImpl&quot;, f:parsenoop },
	0x0440: { n:&quot;BrtBeginSlicerCacheLevelsData&quot;, f:parsenoop },
	0x0441: { n:&quot;BrtEndSlicerCacheLevelsData&quot;, f:parsenoop },
	0x0442: { n:&quot;BrtBeginSlicerCacheLevelData&quot;, f:parsenoop },
	0x0443: { n:&quot;BrtEndSlicerCacheLevelData&quot;, f:parsenoop },
	0x0444: { n:&quot;BrtBeginSlicerCacheSiRanges&quot;, f:parsenoop },
	0x0445: { n:&quot;BrtEndSlicerCacheSiRanges&quot;, f:parsenoop },
	0x0446: { n:&quot;BrtBeginSlicerCacheSiRange&quot;, f:parsenoop },
	0x0447: { n:&quot;BrtEndSlicerCacheSiRange&quot;, f:parsenoop },
	0x0448: { n:&quot;BrtSlicerCacheOlapItem&quot;, f:parsenoop },
	0x0449: { n:&quot;BrtBeginSlicerCacheSelections&quot;, f:parsenoop },
	0x044A: { n:&quot;BrtSlicerCacheSelection&quot;, f:parsenoop },
	0x044B: { n:&quot;BrtEndSlicerCacheSelections&quot;, f:parsenoop },
	0x044C: { n:&quot;BrtBeginSlicerCacheNative&quot;, f:parsenoop },
	0x044D: { n:&quot;BrtEndSlicerCacheNative&quot;, f:parsenoop },
	0x044E: { n:&quot;BrtSlicerCacheNativeItem&quot;, f:parsenoop },
	0x044F: { n:&quot;BrtRangeProtection14&quot;, f:parsenoop },
	0x0450: { n:&quot;BrtRangeProtectionIso14&quot;, f:parsenoop },
	0x0451: { n:&quot;BrtCellIgnoreEC14&quot;, f:parsenoop },
	0x0457: { n:&quot;BrtList14&quot;, f:parsenoop },
	0x0458: { n:&quot;BrtCFIcon&quot;, f:parsenoop },
	0x0459: { n:&quot;BrtBeginSlicerCachesPivotCacheIDs&quot;, f:parsenoop },
	0x045A: { n:&quot;BrtEndSlicerCachesPivotCacheIDs&quot;, f:parsenoop },
	0x045B: { n:&quot;BrtBeginSlicers&quot;, f:parsenoop },
	0x045C: { n:&quot;BrtEndSlicers&quot;, f:parsenoop },
	0x045D: { n:&quot;BrtWbProp14&quot;, f:parsenoop },
	0x045E: { n:&quot;BrtBeginSXEdit&quot;, f:parsenoop },
	0x045F: { n:&quot;BrtEndSXEdit&quot;, f:parsenoop },
	0x0460: { n:&quot;BrtBeginSXEdits&quot;, f:parsenoop },
	0x0461: { n:&quot;BrtEndSXEdits&quot;, f:parsenoop },
	0x0462: { n:&quot;BrtBeginSXChange&quot;, f:parsenoop },
	0x0463: { n:&quot;BrtEndSXChange&quot;, f:parsenoop },
	0x0464: { n:&quot;BrtBeginSXChanges&quot;, f:parsenoop },
	0x0465: { n:&quot;BrtEndSXChanges&quot;, f:parsenoop },
	0x0466: { n:&quot;BrtSXTupleItems&quot;, f:parsenoop },
	0x0468: { n:&quot;BrtBeginSlicerStyle&quot;, f:parsenoop },
	0x0469: { n:&quot;BrtEndSlicerStyle&quot;, f:parsenoop },
	0x046A: { n:&quot;BrtSlicerStyleElement&quot;, f:parsenoop },
	0x046B: { n:&quot;BrtBeginStyleSheetExt14&quot;, f:parsenoop },
	0x046C: { n:&quot;BrtEndStyleSheetExt14&quot;, f:parsenoop },
	0x046D: { n:&quot;BrtBeginSlicerCachesPivotCacheID&quot;, f:parsenoop },
	0x046E: { n:&quot;BrtEndSlicerCachesPivotCacheID&quot;, f:parsenoop },
	0x046F: { n:&quot;BrtBeginConditionalFormattings&quot;, f:parsenoop },
	0x0470: { n:&quot;BrtEndConditionalFormattings&quot;, f:parsenoop },
	0x0471: { n:&quot;BrtBeginPCDCalcMemExt&quot;, f:parsenoop },
	0x0472: { n:&quot;BrtEndPCDCalcMemExt&quot;, f:parsenoop },
	0x0473: { n:&quot;BrtBeginPCDCalcMemsExt&quot;, f:parsenoop },
	0x0474: { n:&quot;BrtEndPCDCalcMemsExt&quot;, f:parsenoop },
	0x0475: { n:&quot;BrtPCDField14&quot;, f:parsenoop },
	0x0476: { n:&quot;BrtBeginSlicerStyles&quot;, f:parsenoop },
	0x0477: { n:&quot;BrtEndSlicerStyles&quot;, f:parsenoop },
	0x0478: { n:&quot;BrtBeginSlicerStyleElements&quot;, f:parsenoop },
	0x0479: { n:&quot;BrtEndSlicerStyleElements&quot;, f:parsenoop },
	0x047A: { n:&quot;BrtCFRuleExt&quot;, f:parsenoop },
	0x047B: { n:&quot;BrtBeginSXCondFmt14&quot;, f:parsenoop },
	0x047C: { n:&quot;BrtEndSXCondFmt14&quot;, f:parsenoop },
	0x047D: { n:&quot;BrtBeginSXCondFmts14&quot;, f:parsenoop },
	0x047E: { n:&quot;BrtEndSXCondFmts14&quot;, f:parsenoop },
	0x0480: { n:&quot;BrtBeginSortCond14&quot;, f:parsenoop },
	0x0481: { n:&quot;BrtEndSortCond14&quot;, f:parsenoop },
	0x0482: { n:&quot;BrtEndDVals14&quot;, f:parsenoop },
	0x0483: { n:&quot;BrtEndIconSet14&quot;, f:parsenoop },
	0x0484: { n:&quot;BrtEndDatabar14&quot;, f:parsenoop },
	0x0485: { n:&quot;BrtBeginColorScale14&quot;, f:parsenoop },
	0x0486: { n:&quot;BrtEndColorScale14&quot;, f:parsenoop },
	0x0487: { n:&quot;BrtBeginSxrules14&quot;, f:parsenoop },
	0x0488: { n:&quot;BrtEndSxrules14&quot;, f:parsenoop },
	0x0489: { n:&quot;BrtBeginPRule14&quot;, f:parsenoop },
	0x048A: { n:&quot;BrtEndPRule14&quot;, f:parsenoop },
	0x048B: { n:&quot;BrtBeginPRFilters14&quot;, f:parsenoop },
	0x048C: { n:&quot;BrtEndPRFilters14&quot;, f:parsenoop },
	0x048D: { n:&quot;BrtBeginPRFilter14&quot;, f:parsenoop },
	0x048E: { n:&quot;BrtEndPRFilter14&quot;, f:parsenoop },
	0x048F: { n:&quot;BrtBeginPRFItem14&quot;, f:parsenoop },
	0x0490: { n:&quot;BrtEndPRFItem14&quot;, f:parsenoop },
	0x0491: { n:&quot;BrtBeginCellIgnoreECs14&quot;, f:parsenoop },
	0x0492: { n:&quot;BrtEndCellIgnoreECs14&quot;, f:parsenoop },
	0x0493: { n:&quot;BrtDxf14&quot;, f:parsenoop },
	0x0494: { n:&quot;BrtBeginDxF14s&quot;, f:parsenoop },
	0x0495: { n:&quot;BrtEndDxf14s&quot;, f:parsenoop },
	0x0499: { n:&quot;BrtFilter14&quot;, f:parsenoop },
	0x049A: { n:&quot;BrtBeginCustomFilters14&quot;, f:parsenoop },
	0x049C: { n:&quot;BrtCustomFilter14&quot;, f:parsenoop },
	0x049D: { n:&quot;BrtIconFilter14&quot;, f:parsenoop },
	0x049E: { n:&quot;BrtPivotCacheConnectionName&quot;, f:parsenoop },
	0x0800: { n:&quot;BrtBeginDecoupledPivotCacheIDs&quot;, f:parsenoop },
	0x0801: { n:&quot;BrtEndDecoupledPivotCacheIDs&quot;, f:parsenoop },
	0x0802: { n:&quot;BrtDecoupledPivotCacheID&quot;, f:parsenoop },
	0x0803: { n:&quot;BrtBeginPivotTableRefs&quot;, f:parsenoop },
	0x0804: { n:&quot;BrtEndPivotTableRefs&quot;, f:parsenoop },
	0x0805: { n:&quot;BrtPivotTableRef&quot;, f:parsenoop },
	0x0806: { n:&quot;BrtSlicerCacheBookPivotTables&quot;, f:parsenoop },
	0x0807: { n:&quot;BrtBeginSxvcells&quot;, f:parsenoop },
	0x0808: { n:&quot;BrtEndSxvcells&quot;, f:parsenoop },
	0x0809: { n:&quot;BrtBeginSxRow&quot;, f:parsenoop },
	0x080A: { n:&quot;BrtEndSxRow&quot;, f:parsenoop },
	0x080C: { n:&quot;BrtPcdCalcMem15&quot;, f:parsenoop },
	0x0813: { n:&quot;BrtQsi15&quot;, f:parsenoop },
	0x0814: { n:&quot;BrtBeginWebExtensions&quot;, f:parsenoop },
	0x0815: { n:&quot;BrtEndWebExtensions&quot;, f:parsenoop },
	0x0816: { n:&quot;BrtWebExtension&quot;, f:parsenoop },
	0x0817: { n:&quot;BrtAbsPath15&quot;, f:parsenoop },
	0x0818: { n:&quot;BrtBeginPivotTableUISettings&quot;, f:parsenoop },
	0x0819: { n:&quot;BrtEndPivotTableUISettings&quot;, f:parsenoop },
	0x081B: { n:&quot;BrtTableSlicerCacheIDs&quot;, f:parsenoop },
	0x081C: { n:&quot;BrtTableSlicerCacheID&quot;, f:parsenoop },
	0x081D: { n:&quot;BrtBeginTableSlicerCache&quot;, f:parsenoop },
	0x081E: { n:&quot;BrtEndTableSlicerCache&quot;, f:parsenoop },
	0x081F: { n:&quot;BrtSxFilter15&quot;, f:parsenoop },
	0x0820: { n:&quot;BrtBeginTimelineCachePivotCacheIDs&quot;, f:parsenoop },
	0x0821: { n:&quot;BrtEndTimelineCachePivotCacheIDs&quot;, f:parsenoop },
	0x0822: { n:&quot;BrtTimelineCachePivotCacheID&quot;, f:parsenoop },
	0x0823: { n:&quot;BrtBeginTimelineCacheIDs&quot;, f:parsenoop },
	0x0824: { n:&quot;BrtEndTimelineCacheIDs&quot;, f:parsenoop },
	0x0825: { n:&quot;BrtBeginTimelineCacheID&quot;, f:parsenoop },
	0x0826: { n:&quot;BrtEndTimelineCacheID&quot;, f:parsenoop },
	0x0827: { n:&quot;BrtBeginTimelinesEx&quot;, f:parsenoop },
	0x0828: { n:&quot;BrtEndTimelinesEx&quot;, f:parsenoop },
	0x0829: { n:&quot;BrtBeginTimelineEx&quot;, f:parsenoop },
	0x082A: { n:&quot;BrtEndTimelineEx&quot;, f:parsenoop },
	0x082B: { n:&quot;BrtWorkBookPr15&quot;, f:parsenoop },
	0x082C: { n:&quot;BrtPCDH15&quot;, f:parsenoop },
	0x082D: { n:&quot;BrtBeginTimelineStyle&quot;, f:parsenoop },
	0x082E: { n:&quot;BrtEndTimelineStyle&quot;, f:parsenoop },
	0x082F: { n:&quot;BrtTimelineStyleElement&quot;, f:parsenoop },
	0x0830: { n:&quot;BrtBeginTimelineStylesheetExt15&quot;, f:parsenoop },
	0x0831: { n:&quot;BrtEndTimelineStylesheetExt15&quot;, f:parsenoop },
	0x0832: { n:&quot;BrtBeginTimelineStyles&quot;, f:parsenoop },
	0x0833: { n:&quot;BrtEndTimelineStyles&quot;, f:parsenoop },
	0x0834: { n:&quot;BrtBeginTimelineStyleElements&quot;, f:parsenoop },
	0x0835: { n:&quot;BrtEndTimelineStyleElements&quot;, f:parsenoop },
	0x0836: { n:&quot;BrtDxf15&quot;, f:parsenoop },
	0x0837: { n:&quot;BrtBeginDxfs15&quot;, f:parsenoop },
	0x0838: { n:&quot;brtEndDxfs15&quot;, f:parsenoop },
	0x0839: { n:&quot;BrtSlicerCacheHideItemsWithNoData&quot;, f:parsenoop },
	0x083A: { n:&quot;BrtBeginItemUniqueNames&quot;, f:parsenoop },
	0x083B: { n:&quot;BrtEndItemUniqueNames&quot;, f:parsenoop },
	0x083C: { n:&quot;BrtItemUniqueName&quot;, f:parsenoop },
	0x083D: { n:&quot;BrtBeginExtConn15&quot;, f:parsenoop },
	0x083E: { n:&quot;BrtEndExtConn15&quot;, f:parsenoop },
	0x083F: { n:&quot;BrtBeginOledbPr15&quot;, f:parsenoop },
	0x0840: { n:&quot;BrtEndOledbPr15&quot;, f:parsenoop },
	0x0841: { n:&quot;BrtBeginDataFeedPr15&quot;, f:parsenoop },
	0x0842: { n:&quot;BrtEndDataFeedPr15&quot;, f:parsenoop },
	0x0843: { n:&quot;BrtTextPr15&quot;, f:parsenoop },
	0x0844: { n:&quot;BrtRangePr15&quot;, f:parsenoop },
	0x0845: { n:&quot;BrtDbCommand15&quot;, f:parsenoop },
	0x0846: { n:&quot;BrtBeginDbTables15&quot;, f:parsenoop },
	0x0847: { n:&quot;BrtEndDbTables15&quot;, f:parsenoop },
	0x0848: { n:&quot;BrtDbTable15&quot;, f:parsenoop },
	0x0849: { n:&quot;BrtBeginDataModel&quot;, f:parsenoop },
	0x084A: { n:&quot;BrtEndDataModel&quot;, f:parsenoop },
	0x084B: { n:&quot;BrtBeginModelTables&quot;, f:parsenoop },
	0x084C: { n:&quot;BrtEndModelTables&quot;, f:parsenoop },
	0x084D: { n:&quot;BrtModelTable&quot;, f:parsenoop },
	0x084E: { n:&quot;BrtBeginModelRelationships&quot;, f:parsenoop },
	0x084F: { n:&quot;BrtEndModelRelationships&quot;, f:parsenoop },
	0x0850: { n:&quot;BrtModelRelationship&quot;, f:parsenoop },
	0x0851: { n:&quot;BrtBeginECTxtWiz15&quot;, f:parsenoop },
	0x0852: { n:&quot;BrtEndECTxtWiz15&quot;, f:parsenoop },
	0x0853: { n:&quot;BrtBeginECTWFldInfoLst15&quot;, f:parsenoop },
	0x0854: { n:&quot;BrtEndECTWFldInfoLst15&quot;, f:parsenoop },
	0x0855: { n:&quot;BrtBeginECTWFldInfo15&quot;, f:parsenoop },
	0x0856: { n:&quot;BrtFieldListActiveItem&quot;, f:parsenoop },
	0x0857: { n:&quot;BrtPivotCacheIdVersion&quot;, f:parsenoop },
	0x0858: { n:&quot;BrtSXDI15&quot;, f:parsenoop },
	0xFFFF: { n:&quot;&quot;, f:parsenoop }
};

var evert_RE = evert_key(XLSBRecordEnum, &#x27;n&#x27;);

/* [MS-XLS] 2.3 Record Enumeration */
var XLSRecordEnum = {
	0x0003: { n:&quot;BIFF2NUM&quot;, f:parse_BIFF2NUM },
	0x0004: { n:&quot;BIFF2STR&quot;, f:parse_BIFF2STR },
	0x0006: { n:&quot;Formula&quot;, f:parse_Formula },
	0x0009: { n:&#x27;BOF&#x27;, f:parse_BOF },
	0x000a: { n:&#x27;EOF&#x27;, f:parse_EOF },
	0x000c: { n:&quot;CalcCount&quot;, f:parse_CalcCount },
	0x000d: { n:&quot;CalcMode&quot;, f:parse_CalcMode },
	0x000e: { n:&quot;CalcPrecision&quot;, f:parse_CalcPrecision },
	0x000f: { n:&quot;CalcRefMode&quot;, f:parse_CalcRefMode },
	0x0010: { n:&quot;CalcDelta&quot;, f:parse_CalcDelta },
	0x0011: { n:&quot;CalcIter&quot;, f:parse_CalcIter },
	0x0012: { n:&quot;Protect&quot;, f:parse_Protect },
	0x0013: { n:&quot;Password&quot;, f:parse_Password },
	0x0014: { n:&quot;Header&quot;, f:parse_Header },
	0x0015: { n:&quot;Footer&quot;, f:parse_Footer },
	0x0017: { n:&quot;ExternSheet&quot;, f:parse_ExternSheet },
	0x0018: { n:&quot;Lbl&quot;, f:parse_Lbl },
	0x0019: { n:&quot;WinProtect&quot;, f:parse_WinProtect },
	0x001a: { n:&quot;VerticalPageBreaks&quot;, f:parse_VerticalPageBreaks },
	0x001b: { n:&quot;HorizontalPageBreaks&quot;, f:parse_HorizontalPageBreaks },
	0x001c: { n:&quot;Note&quot;, f:parse_Note },
	0x001d: { n:&quot;Selection&quot;, f:parse_Selection },
	0x0022: { n:&quot;Date1904&quot;, f:parse_Date1904 },
	0x0023: { n:&quot;ExternName&quot;, f:parse_ExternName },
	0x0026: { n:&quot;LeftMargin&quot;, f:parse_LeftMargin },
	0x0027: { n:&quot;RightMargin&quot;, f:parse_RightMargin },
	0x0028: { n:&quot;TopMargin&quot;, f:parse_TopMargin },
	0x0029: { n:&quot;BottomMargin&quot;, f:parse_BottomMargin },
	0x002a: { n:&quot;PrintRowCol&quot;, f:parse_PrintRowCol },
	0x002b: { n:&quot;PrintGrid&quot;, f:parse_PrintGrid },
	0x002f: { n:&quot;FilePass&quot;, f:parse_FilePass },
	0x0031: { n:&quot;Font&quot;, f:parse_Font },
	0x0033: { n:&quot;PrintSize&quot;, f:parse_PrintSize },
	0x003c: { n:&quot;Continue&quot;, f:parse_Continue },
	0x003d: { n:&quot;Window1&quot;, f:parse_Window1 },
	0x0040: { n:&quot;Backup&quot;, f:parse_Backup },
	0x0041: { n:&quot;Pane&quot;, f:parse_Pane },
	0x0042: { n:&#x27;CodePage&#x27;, f:parse_CodePage },
	0x004d: { n:&quot;Pls&quot;, f:parse_Pls },
	0x0050: { n:&quot;DCon&quot;, f:parse_DCon },
	0x0051: { n:&quot;DConRef&quot;, f:parse_DConRef },
	0x0052: { n:&quot;DConName&quot;, f:parse_DConName },
	0x0055: { n:&quot;DefColWidth&quot;, f:parse_DefColWidth },
	0x0059: { n:&quot;XCT&quot;, f:parse_XCT },
	0x005a: { n:&quot;CRN&quot;, f:parse_CRN },
	0x005b: { n:&quot;FileSharing&quot;, f:parse_FileSharing },
	0x005c: { n:&#x27;WriteAccess&#x27;, f:parse_WriteAccess },
	0x005d: { n:&quot;Obj&quot;, f:parse_Obj },
	0x005e: { n:&quot;Uncalced&quot;, f:parse_Uncalced },
	0x005f: { n:&quot;CalcSaveRecalc&quot;, f:parse_CalcSaveRecalc },
	0x0060: { n:&quot;Template&quot;, f:parse_Template },
	0x0061: { n:&quot;Intl&quot;, f:parse_Intl },
	0x0063: { n:&quot;ObjProtect&quot;, f:parse_ObjProtect },
	0x007d: { n:&quot;ColInfo&quot;, f:parse_ColInfo },
	0x0080: { n:&quot;Guts&quot;, f:parse_Guts },
	0x0081: { n:&quot;WsBool&quot;, f:parse_WsBool },
	0x0082: { n:&quot;GridSet&quot;, f:parse_GridSet },
	0x0083: { n:&quot;HCenter&quot;, f:parse_HCenter },
	0x0084: { n:&quot;VCenter&quot;, f:parse_VCenter },
	0x0085: { n:&#x27;BoundSheet8&#x27;, f:parse_BoundSheet8 },
	0x0086: { n:&quot;WriteProtect&quot;, f:parse_WriteProtect },
	0x008c: { n:&quot;Country&quot;, f:parse_Country },
	0x008d: { n:&quot;HideObj&quot;, f:parse_HideObj },
	0x0090: { n:&quot;Sort&quot;, f:parse_Sort },
	0x0092: { n:&quot;Palette&quot;, f:parse_Palette },
	0x0097: { n:&quot;Sync&quot;, f:parse_Sync },
	0x0098: { n:&quot;LPr&quot;, f:parse_LPr },
	0x0099: { n:&quot;DxGCol&quot;, f:parse_DxGCol },
	0x009a: { n:&quot;FnGroupName&quot;, f:parse_FnGroupName },
	0x009b: { n:&quot;FilterMode&quot;, f:parse_FilterMode },
	0x009c: { n:&quot;BuiltInFnGroupCount&quot;, f:parse_BuiltInFnGroupCount },
	0x009d: { n:&quot;AutoFilterInfo&quot;, f:parse_AutoFilterInfo },
	0x009e: { n:&quot;AutoFilter&quot;, f:parse_AutoFilter },
	0x00a0: { n:&quot;Scl&quot;, f:parse_Scl },
	0x00a1: { n:&quot;Setup&quot;, f:parse_Setup },
	0x00ae: { n:&quot;ScenMan&quot;, f:parse_ScenMan },
	0x00af: { n:&quot;SCENARIO&quot;, f:parse_SCENARIO },
	0x00b0: { n:&quot;SxView&quot;, f:parse_SxView },
	0x00b1: { n:&quot;Sxvd&quot;, f:parse_Sxvd },
	0x00b2: { n:&quot;SXVI&quot;, f:parse_SXVI },
	0x00b4: { n:&quot;SxIvd&quot;, f:parse_SxIvd },
	0x00b5: { n:&quot;SXLI&quot;, f:parse_SXLI },
	0x00b6: { n:&quot;SXPI&quot;, f:parse_SXPI },
	0x00b8: { n:&quot;DocRoute&quot;, f:parse_DocRoute },
	0x00b9: { n:&quot;RecipName&quot;, f:parse_RecipName },
	0x00bd: { n:&quot;MulRk&quot;, f:parse_MulRk },
	0x00be: { n:&quot;MulBlank&quot;, f:parse_MulBlank },
	0x00c1: { n:&#x27;Mms&#x27;, f:parse_Mms },
	0x00c5: { n:&quot;SXDI&quot;, f:parse_SXDI },
	0x00c6: { n:&quot;SXDB&quot;, f:parse_SXDB },
	0x00c7: { n:&quot;SXFDB&quot;, f:parse_SXFDB },
	0x00c8: { n:&quot;SXDBB&quot;, f:parse_SXDBB },
	0x00c9: { n:&quot;SXNum&quot;, f:parse_SXNum },
	0x00ca: { n:&quot;SxBool&quot;, f:parse_SxBool },
	0x00cb: { n:&quot;SxErr&quot;, f:parse_SxErr },
	0x00cc: { n:&quot;SXInt&quot;, f:parse_SXInt },
	0x00cd: { n:&quot;SXString&quot;, f:parse_SXString },
	0x00ce: { n:&quot;SXDtr&quot;, f:parse_SXDtr },
	0x00cf: { n:&quot;SxNil&quot;, f:parse_SxNil },
	0x00d0: { n:&quot;SXTbl&quot;, f:parse_SXTbl },
	0x00d1: { n:&quot;SXTBRGIITM&quot;, f:parse_SXTBRGIITM },
	0x00d2: { n:&quot;SxTbpg&quot;, f:parse_SxTbpg },
	0x00d3: { n:&quot;ObProj&quot;, f:parse_ObProj },
	0x00d5: { n:&quot;SXStreamID&quot;, f:parse_SXStreamID },
	0x00d7: { n:&quot;DBCell&quot;, f:parse_DBCell },
	0x00d8: { n:&quot;SXRng&quot;, f:parse_SXRng },
	0x00d9: { n:&quot;SxIsxoper&quot;, f:parse_SxIsxoper },
	0x00da: { n:&quot;BookBool&quot;, f:parse_BookBool },
	0x00dc: { n:&quot;DbOrParamQry&quot;, f:parse_DbOrParamQry },
	0x00dd: { n:&quot;ScenarioProtect&quot;, f:parse_ScenarioProtect },
	0x00de: { n:&quot;OleObjectSize&quot;, f:parse_OleObjectSize },
	0x00e0: { n:&quot;XF&quot;, f:parse_XF },
	0x00e1: { n:&#x27;InterfaceHdr&#x27;, f:parse_InterfaceHdr },
	0x00e2: { n:&#x27;InterfaceEnd&#x27;, f:parse_InterfaceEnd },
	0x00e3: { n:&quot;SXVS&quot;, f:parse_SXVS },
	0x00e5: { n:&quot;MergeCells&quot;, f:parse_MergeCells },
	0x00e9: { n:&quot;BkHim&quot;, f:parse_BkHim },
	0x00eb: { n:&quot;MsoDrawingGroup&quot;, f:parse_MsoDrawingGroup },
	0x00ec: { n:&quot;MsoDrawing&quot;, f:parse_MsoDrawing },
	0x00ed: { n:&quot;MsoDrawingSelection&quot;, f:parse_MsoDrawingSelection },
	0x00ef: { n:&quot;PhoneticInfo&quot;, f:parse_PhoneticInfo },
	0x00f0: { n:&quot;SxRule&quot;, f:parse_SxRule },
	0x00f1: { n:&quot;SXEx&quot;, f:parse_SXEx },
	0x00f2: { n:&quot;SxFilt&quot;, f:parse_SxFilt },
	0x00f4: { n:&quot;SxDXF&quot;, f:parse_SxDXF },
	0x00f5: { n:&quot;SxItm&quot;, f:parse_SxItm },
	0x00f6: { n:&quot;SxName&quot;, f:parse_SxName },
	0x00f7: { n:&quot;SxSelect&quot;, f:parse_SxSelect },
	0x00f8: { n:&quot;SXPair&quot;, f:parse_SXPair },
	0x00f9: { n:&quot;SxFmla&quot;, f:parse_SxFmla },
	0x00fb: { n:&quot;SxFormat&quot;, f:parse_SxFormat },
	0x00fc: { n:&quot;SST&quot;, f:parse_SST },
	0x00fd: { n:&quot;LabelSst&quot;, f:parse_LabelSst },
	0x00ff: { n:&quot;ExtSST&quot;, f:parse_ExtSST },
	0x0100: { n:&quot;SXVDEx&quot;, f:parse_SXVDEx },
	0x0103: { n:&quot;SXFormula&quot;, f:parse_SXFormula },
	0x0122: { n:&quot;SXDBEx&quot;, f:parse_SXDBEx },
	0x0137: { n:&quot;RRDInsDel&quot;, f:parse_RRDInsDel },
	0x0138: { n:&quot;RRDHead&quot;, f:parse_RRDHead },
	0x013b: { n:&quot;RRDChgCell&quot;, f:parse_RRDChgCell },
	0x013d: { n:&quot;RRTabId&quot;, f:parse_RRTabId },
	0x013e: { n:&quot;RRDRenSheet&quot;, f:parse_RRDRenSheet },
	0x013f: { n:&quot;RRSort&quot;, f:parse_RRSort },
	0x0140: { n:&quot;RRDMove&quot;, f:parse_RRDMove },
	0x014a: { n:&quot;RRFormat&quot;, f:parse_RRFormat },
	0x014b: { n:&quot;RRAutoFmt&quot;, f:parse_RRAutoFmt },
	0x014d: { n:&quot;RRInsertSh&quot;, f:parse_RRInsertSh },
	0x014e: { n:&quot;RRDMoveBegin&quot;, f:parse_RRDMoveBegin },
	0x014f: { n:&quot;RRDMoveEnd&quot;, f:parse_RRDMoveEnd },
	0x0150: { n:&quot;RRDInsDelBegin&quot;, f:parse_RRDInsDelBegin },
	0x0151: { n:&quot;RRDInsDelEnd&quot;, f:parse_RRDInsDelEnd },
	0x0152: { n:&quot;RRDConflict&quot;, f:parse_RRDConflict },
	0x0153: { n:&quot;RRDDefName&quot;, f:parse_RRDDefName },
	0x0154: { n:&quot;RRDRstEtxp&quot;, f:parse_RRDRstEtxp },
	0x015f: { n:&quot;LRng&quot;, f:parse_LRng },
	0x0160: { n:&quot;UsesELFs&quot;, f:parse_UsesELFs },
	0x0161: { n:&quot;DSF&quot;, f:parse_DSF },
	0x0191: { n:&quot;CUsr&quot;, f:parse_CUsr },
	0x0192: { n:&quot;CbUsr&quot;, f:parse_CbUsr },
	0x0193: { n:&quot;UsrInfo&quot;, f:parse_UsrInfo },
	0x0194: { n:&quot;UsrExcl&quot;, f:parse_UsrExcl },
	0x0195: { n:&quot;FileLock&quot;, f:parse_FileLock },
	0x0196: { n:&quot;RRDInfo&quot;, f:parse_RRDInfo },
	0x0197: { n:&quot;BCUsrs&quot;, f:parse_BCUsrs },
	0x0198: { n:&quot;UsrChk&quot;, f:parse_UsrChk },
	0x01a9: { n:&quot;UserBView&quot;, f:parse_UserBView },
	0x01aa: { n:&quot;UserSViewBegin&quot;, f:parse_UserSViewBegin },
	0x01ab: { n:&quot;UserSViewEnd&quot;, f:parse_UserSViewEnd },
	0x01ac: { n:&quot;RRDUserView&quot;, f:parse_RRDUserView },
	0x01ad: { n:&quot;Qsi&quot;, f:parse_Qsi },
	0x01ae: { n:&quot;SupBook&quot;, f:parse_SupBook },
	0x01af: { n:&quot;Prot4Rev&quot;, f:parse_Prot4Rev },
	0x01b0: { n:&quot;CondFmt&quot;, f:parse_CondFmt },
	0x01b1: { n:&quot;CF&quot;, f:parse_CF },
	0x01b2: { n:&quot;DVal&quot;, f:parse_DVal },
	0x01b5: { n:&quot;DConBin&quot;, f:parse_DConBin },
	0x01b6: { n:&quot;TxO&quot;, f:parse_TxO },
	0x01b7: { n:&quot;RefreshAll&quot;, f:parse_RefreshAll },
	0x01b8: { n:&quot;HLink&quot;, f:parse_HLink },
	0x01b9: { n:&quot;Lel&quot;, f:parse_Lel },
	0x01ba: { n:&quot;CodeName&quot;, f:parse_XLSCodeName },
	0x01bb: { n:&quot;SXFDBType&quot;, f:parse_SXFDBType },
	0x01bc: { n:&quot;Prot4RevPass&quot;, f:parse_Prot4RevPass },
	0x01bd: { n:&quot;ObNoMacros&quot;, f:parse_ObNoMacros },
	0x01be: { n:&quot;Dv&quot;, f:parse_Dv },
	0x01c0: { n:&quot;Excel9File&quot;, f:parse_Excel9File },
	0x01c1: { n:&quot;RecalcId&quot;, f:parse_RecalcId, r:2},
	0x01c2: { n:&quot;EntExU2&quot;, f:parse_EntExU2 },
	0x0200: { n:&quot;Dimensions&quot;, f:parse_Dimensions },
	0x0201: { n:&quot;Blank&quot;, f:parse_Blank },
	0x0203: { n:&quot;Number&quot;, f:parse_Number },
	0x0204: { n:&quot;Label&quot;, f:parse_Label },
	0x0205: { n:&quot;BoolErr&quot;, f:parse_BoolErr },
	0x0207: { n:&quot;String&quot;, f:parse_String },
	0x0208: { n:&#x27;Row&#x27;, f:parse_Row },
	0x020b: { n:&quot;Index&quot;, f:parse_Index },
	0x0221: { n:&quot;Array&quot;, f:parse_Array },
	0x0225: { n:&quot;DefaultRowHeight&quot;, f:parse_DefaultRowHeight },
	0x0236: { n:&quot;Table&quot;, f:parse_Table },
	0x023e: { n:&quot;Window2&quot;, f:parse_Window2 },
	0x027e: { n:&quot;RK&quot;, f:parse_RK },
	0x0293: { n:&quot;Style&quot;, f:parse_Style },
	0x0418: { n:&quot;BigName&quot;, f:parse_BigName },
	0x041e: { n:&quot;Format&quot;, f:parse_Format },
	0x043c: { n:&quot;ContinueBigName&quot;, f:parse_ContinueBigName },
	0x04bc: { n:&quot;ShrFmla&quot;, f:parse_ShrFmla },
	0x0800: { n:&quot;HLinkTooltip&quot;, f:parse_HLinkTooltip },
	0x0801: { n:&quot;WebPub&quot;, f:parse_WebPub },
	0x0802: { n:&quot;QsiSXTag&quot;, f:parse_QsiSXTag },
	0x0803: { n:&quot;DBQueryExt&quot;, f:parse_DBQueryExt },
	0x0804: { n:&quot;ExtString&quot;, f:parse_ExtString },
	0x0805: { n:&quot;TxtQry&quot;, f:parse_TxtQry },
	0x0806: { n:&quot;Qsir&quot;, f:parse_Qsir },
	0x0807: { n:&quot;Qsif&quot;, f:parse_Qsif },
	0x0808: { n:&quot;RRDTQSIF&quot;, f:parse_RRDTQSIF },
	0x0809: { n:&#x27;BOF&#x27;, f:parse_BOF },
	0x080a: { n:&quot;OleDbConn&quot;, f:parse_OleDbConn },
	0x080b: { n:&quot;WOpt&quot;, f:parse_WOpt },
	0x080c: { n:&quot;SXViewEx&quot;, f:parse_SXViewEx },
	0x080d: { n:&quot;SXTH&quot;, f:parse_SXTH },
	0x080e: { n:&quot;SXPIEx&quot;, f:parse_SXPIEx },
	0x080f: { n:&quot;SXVDTEx&quot;, f:parse_SXVDTEx },
	0x0810: { n:&quot;SXViewEx9&quot;, f:parse_SXViewEx9 },
	0x0812: { n:&quot;ContinueFrt&quot;, f:parse_ContinueFrt },
	0x0813: { n:&quot;RealTimeData&quot;, f:parse_RealTimeData },
	0x0850: { n:&quot;ChartFrtInfo&quot;, f:parse_ChartFrtInfo },
	0x0851: { n:&quot;FrtWrapper&quot;, f:parse_FrtWrapper },
	0x0852: { n:&quot;StartBlock&quot;, f:parse_StartBlock },
	0x0853: { n:&quot;EndBlock&quot;, f:parse_EndBlock },
	0x0854: { n:&quot;StartObject&quot;, f:parse_StartObject },
	0x0855: { n:&quot;EndObject&quot;, f:parse_EndObject },
	0x0856: { n:&quot;CatLab&quot;, f:parse_CatLab },
	0x0857: { n:&quot;YMult&quot;, f:parse_YMult },
	0x0858: { n:&quot;SXViewLink&quot;, f:parse_SXViewLink },
	0x0859: { n:&quot;PivotChartBits&quot;, f:parse_PivotChartBits },
	0x085a: { n:&quot;FrtFontList&quot;, f:parse_FrtFontList },
	0x0862: { n:&quot;SheetExt&quot;, f:parse_SheetExt },
	0x0863: { n:&quot;BookExt&quot;, f:parse_BookExt, r:12},
	0x0864: { n:&quot;SXAddl&quot;, f:parse_SXAddl },
	0x0865: { n:&quot;CrErr&quot;, f:parse_CrErr },
	0x0866: { n:&quot;HFPicture&quot;, f:parse_HFPicture },
	0x0867: { n:&#x27;FeatHdr&#x27;, f:parse_FeatHdr },
	0x0868: { n:&quot;Feat&quot;, f:parse_Feat },
	0x086a: { n:&quot;DataLabExt&quot;, f:parse_DataLabExt },
	0x086b: { n:&quot;DataLabExtContents&quot;, f:parse_DataLabExtContents },
	0x086c: { n:&quot;CellWatch&quot;, f:parse_CellWatch },
	0x0871: { n:&quot;FeatHdr11&quot;, f:parse_FeatHdr11 },
	0x0872: { n:&quot;Feature11&quot;, f:parse_Feature11 },
	0x0874: { n:&quot;DropDownObjIds&quot;, f:parse_DropDownObjIds },
	0x0875: { n:&quot;ContinueFrt11&quot;, f:parse_ContinueFrt11 },
	0x0876: { n:&quot;DConn&quot;, f:parse_DConn },
	0x0877: { n:&quot;List12&quot;, f:parse_List12 },
	0x0878: { n:&quot;Feature12&quot;, f:parse_Feature12 },
	0x0879: { n:&quot;CondFmt12&quot;, f:parse_CondFmt12 },
	0x087a: { n:&quot;CF12&quot;, f:parse_CF12 },
	0x087b: { n:&quot;CFEx&quot;, f:parse_CFEx },
	0x087c: { n:&quot;XFCRC&quot;, f:parse_XFCRC, r:12 },
	0x087d: { n:&quot;XFExt&quot;, f:parse_XFExt, r:12 },
	0x087e: { n:&quot;AutoFilter12&quot;, f:parse_AutoFilter12 },
	0x087f: { n:&quot;ContinueFrt12&quot;, f:parse_ContinueFrt12 },
	0x0884: { n:&quot;MDTInfo&quot;, f:parse_MDTInfo },
	0x0885: { n:&quot;MDXStr&quot;, f:parse_MDXStr },
	0x0886: { n:&quot;MDXTuple&quot;, f:parse_MDXTuple },
	0x0887: { n:&quot;MDXSet&quot;, f:parse_MDXSet },
	0x0888: { n:&quot;MDXProp&quot;, f:parse_MDXProp },
	0x0889: { n:&quot;MDXKPI&quot;, f:parse_MDXKPI },
	0x088a: { n:&quot;MDB&quot;, f:parse_MDB },
	0x088b: { n:&quot;PLV&quot;, f:parse_PLV },
	0x088c: { n:&quot;Compat12&quot;, f:parse_Compat12, r:12 },
	0x088d: { n:&quot;DXF&quot;, f:parse_DXF },
	0x088e: { n:&quot;TableStyles&quot;, f:parse_TableStyles, r:12 },
	0x088f: { n:&quot;TableStyle&quot;, f:parse_TableStyle },
	0x0890: { n:&quot;TableStyleElement&quot;, f:parse_TableStyleElement },
	0x0892: { n:&quot;StyleExt&quot;, f:parse_StyleExt },
	0x0893: { n:&quot;NamePublish&quot;, f:parse_NamePublish },
	0x0894: { n:&quot;NameCmt&quot;, f:parse_NameCmt },
	0x0895: { n:&quot;SortData&quot;, f:parse_SortData },
	0x0896: { n:&quot;Theme&quot;, f:parse_Theme, r:12 },
	0x0897: { n:&quot;GUIDTypeLib&quot;, f:parse_GUIDTypeLib },
	0x0898: { n:&quot;FnGrp12&quot;, f:parse_FnGrp12 },
	0x0899: { n:&quot;NameFnGrp12&quot;, f:parse_NameFnGrp12 },
	0x089a: { n:&quot;MTRSettings&quot;, f:parse_MTRSettings, r:12 },
	0x089b: { n:&quot;CompressPictures&quot;, f:parse_CompressPictures },
	0x089c: { n:&quot;HeaderFooter&quot;, f:parse_HeaderFooter },
	0x089d: { n:&quot;CrtLayout12&quot;, f:parse_CrtLayout12 },
	0x089e: { n:&quot;CrtMlFrt&quot;, f:parse_CrtMlFrt },
	0x089f: { n:&quot;CrtMlFrtContinue&quot;, f:parse_CrtMlFrtContinue },
	0x08a3: { n:&quot;ForceFullCalculation&quot;, f:parse_ForceFullCalculation },
	0x08a4: { n:&quot;ShapePropsStream&quot;, f:parse_ShapePropsStream },
	0x08a5: { n:&quot;TextPropsStream&quot;, f:parse_TextPropsStream },
	0x08a6: { n:&quot;RichTextStream&quot;, f:parse_RichTextStream },
	0x08a7: { n:&quot;CrtLayout12A&quot;, f:parse_CrtLayout12A },
	0x1001: { n:&quot;Units&quot;, f:parse_Units },
	0x1002: { n:&quot;Chart&quot;, f:parse_Chart },
	0x1003: { n:&quot;Series&quot;, f:parse_Series },
	0x1006: { n:&quot;DataFormat&quot;, f:parse_DataFormat },
	0x1007: { n:&quot;LineFormat&quot;, f:parse_LineFormat },
	0x1009: { n:&quot;MarkerFormat&quot;, f:parse_MarkerFormat },
	0x100a: { n:&quot;AreaFormat&quot;, f:parse_AreaFormat },
	0x100b: { n:&quot;PieFormat&quot;, f:parse_PieFormat },
	0x100c: { n:&quot;AttachedLabel&quot;, f:parse_AttachedLabel },
	0x100d: { n:&quot;SeriesText&quot;, f:parse_SeriesText },
	0x1014: { n:&quot;ChartFormat&quot;, f:parse_ChartFormat },
	0x1015: { n:&quot;Legend&quot;, f:parse_Legend },
	0x1016: { n:&quot;SeriesList&quot;, f:parse_SeriesList },
	0x1017: { n:&quot;Bar&quot;, f:parse_Bar },
	0x1018: { n:&quot;Line&quot;, f:parse_Line },
	0x1019: { n:&quot;Pie&quot;, f:parse_Pie },
	0x101a: { n:&quot;Area&quot;, f:parse_Area },
	0x101b: { n:&quot;Scatter&quot;, f:parse_Scatter },
	0x101c: { n:&quot;CrtLine&quot;, f:parse_CrtLine },
	0x101d: { n:&quot;Axis&quot;, f:parse_Axis },
	0x101e: { n:&quot;Tick&quot;, f:parse_Tick },
	0x101f: { n:&quot;ValueRange&quot;, f:parse_ValueRange },
	0x1020: { n:&quot;CatSerRange&quot;, f:parse_CatSerRange },
	0x1021: { n:&quot;AxisLine&quot;, f:parse_AxisLine },
	0x1022: { n:&quot;CrtLink&quot;, f:parse_CrtLink },
	0x1024: { n:&quot;DefaultText&quot;, f:parse_DefaultText },
	0x1025: { n:&quot;Text&quot;, f:parse_Text },
	0x1026: { n:&quot;FontX&quot;, f:parse_FontX },
	0x1027: { n:&quot;ObjectLink&quot;, f:parse_ObjectLink },
	0x1032: { n:&quot;Frame&quot;, f:parse_Frame },
	0x1033: { n:&quot;Begin&quot;, f:parse_Begin },
	0x1034: { n:&quot;End&quot;, f:parse_End },
	0x1035: { n:&quot;PlotArea&quot;, f:parse_PlotArea },
	0x103a: { n:&quot;Chart3d&quot;, f:parse_Chart3d },
	0x103c: { n:&quot;PicF&quot;, f:parse_PicF },
	0x103d: { n:&quot;DropBar&quot;, f:parse_DropBar },
	0x103e: { n:&quot;Radar&quot;, f:parse_Radar },
	0x103f: { n:&quot;Surf&quot;, f:parse_Surf },
	0x1040: { n:&quot;RadarArea&quot;, f:parse_RadarArea },
	0x1041: { n:&quot;AxisParent&quot;, f:parse_AxisParent },
	0x1043: { n:&quot;LegendException&quot;, f:parse_LegendException },
	0x1044: { n:&quot;ShtProps&quot;, f:parse_ShtProps },
	0x1045: { n:&quot;SerToCrt&quot;, f:parse_SerToCrt },
	0x1046: { n:&quot;AxesUsed&quot;, f:parse_AxesUsed },
	0x1048: { n:&quot;SBaseRef&quot;, f:parse_SBaseRef },
	0x104a: { n:&quot;SerParent&quot;, f:parse_SerParent },
	0x104b: { n:&quot;SerAuxTrend&quot;, f:parse_SerAuxTrend },
	0x104e: { n:&quot;IFmtRecord&quot;, f:parse_IFmtRecord },
	0x104f: { n:&quot;Pos&quot;, f:parse_Pos },
	0x1050: { n:&quot;AlRuns&quot;, f:parse_AlRuns },
	0x1051: { n:&quot;BRAI&quot;, f:parse_BRAI },
	0x105b: { n:&quot;SerAuxErrBar&quot;, f:parse_SerAuxErrBar },
	0x105c: { n:&quot;ClrtClient&quot;, f:parse_ClrtClient },
	0x105d: { n:&quot;SerFmt&quot;, f:parse_SerFmt },
	0x105f: { n:&quot;Chart3DBarShape&quot;, f:parse_Chart3DBarShape },
	0x1060: { n:&quot;Fbi&quot;, f:parse_Fbi },
	0x1061: { n:&quot;BopPop&quot;, f:parse_BopPop },
	0x1062: { n:&quot;AxcExt&quot;, f:parse_AxcExt },
	0x1063: { n:&quot;Dat&quot;, f:parse_Dat },
	0x1064: { n:&quot;PlotGrowth&quot;, f:parse_PlotGrowth },
	0x1065: { n:&quot;SIIndex&quot;, f:parse_SIIndex },
	0x1066: { n:&quot;GelFrame&quot;, f:parse_GelFrame },
	0x1067: { n:&quot;BopPopCustom&quot;, f:parse_BopPopCustom },
	0x1068: { n:&quot;Fbi2&quot;, f:parse_Fbi2 },

	/* These are specified in an older version of the spec */
	0x0016: { n:&quot;ExternCount&quot;, f:parsenoop },
	0x007e: { n:&quot;RK&quot;, f:parsenoop }, /* Not necessarily same as 0x027e */
	0x007f: { n:&quot;ImData&quot;, f:parsenoop },
	0x0087: { n:&quot;Addin&quot;, f:parsenoop },
	0x0088: { n:&quot;Edg&quot;, f:parsenoop },
	0x0089: { n:&quot;Pub&quot;, f:parsenoop },
	0x0091: { n:&quot;Sub&quot;, f:parsenoop },
	0x0094: { n:&quot;LHRecord&quot;, f:parsenoop },
	0x0095: { n:&quot;LHNGraph&quot;, f:parsenoop },
	0x0096: { n:&quot;Sound&quot;, f:parsenoop },
	0x00a9: { n:&quot;CoordList&quot;, f:parsenoop },
	0x00ab: { n:&quot;GCW&quot;, f:parsenoop },
	0x00bc: { n:&quot;ShrFmla&quot;, f:parsenoop }, /* Not necessarily same as 0x04bc */
	0x00c2: { n:&quot;AddMenu&quot;, f:parsenoop },
	0x00c3: { n:&quot;DelMenu&quot;, f:parsenoop },
	0x00d6: { n:&quot;RString&quot;, f:parsenoop },
	0x00df: { n:&quot;UDDesc&quot;, f:parsenoop },
	0x00ea: { n:&quot;TabIdConf&quot;, f:parsenoop },
	0x0162: { n:&quot;XL5Modify&quot;, f:parsenoop },
	0x01a5: { n:&quot;FileSharing2&quot;, f:parsenoop },
	0x0218: { n:&quot;Name&quot;, f:parsenoop },
	0x0223: { n:&quot;ExternName&quot;, f:parse_ExternName },
	0x0231: { n:&quot;Font&quot;, f:parsenoop },
	0x0406: { n:&quot;Formula&quot;, f:parse_Formula },
	0x086d: { n:&quot;FeatInfo&quot;, f:parsenoop },
	0x0873: { n:&quot;FeatInfo11&quot;, f:parsenoop },
	0x0881: { n:&quot;SXAddl12&quot;, f:parsenoop },
	0x08c0: { n:&quot;AutoWebPub&quot;, f:parsenoop },
	0x08c1: { n:&quot;ListObj&quot;, f:parsenoop },
	0x08c2: { n:&quot;ListField&quot;, f:parsenoop },
	0x08c3: { n:&quot;ListDV&quot;, f:parsenoop },
	0x08c4: { n:&quot;ListCondFmt&quot;, f:parsenoop },
	0x08c5: { n:&quot;ListCF&quot;, f:parsenoop },
	0x08c6: { n:&quot;FMQry&quot;, f:parsenoop },
	0x08c7: { n:&quot;FMSQry&quot;, f:parsenoop },
	0x08c8: { n:&quot;PLV&quot;, f:parsenoop }, /* supposedly PLV for Excel 11 */
	0x08c9: { n:&quot;LnExt&quot;, f:parsenoop },
	0x08ca: { n:&quot;MkrExt&quot;, f:parsenoop },
	0x08cb: { n:&quot;CrtCoopt&quot;, f:parsenoop },

	0x0000: {}
};


/* Helper function to call out to ODS parser */
function parse_ods(zip, opts) {
	if(typeof module !== &quot;undefined&quot; &amp;&amp; typeof require !== &#x27;undefined&#x27; &amp;&amp; typeof ODS === &#x27;undefined&#x27;) ODS = require(&#x27;./od&#x27; + &#x27;s&#x27;);
	if(typeof ODS === &#x27;undefined&#x27; || !ODS.parse_ods) throw new Error(&quot;Unsupported ODS&quot;);
	return ODS.parse_ods(zip, opts);
}
function fix_opts_func(defaults) {
	return function fix_opts(opts) {
		for(var i = 0; i != defaults.length; ++i) {
			var d = defaults[i];
			if(opts[d[0]] === undefined) opts[d[0]] = d[1];
			if(d[2] === &#x27;n&#x27;) opts[d[0]] = Number(opts[d[0]]);
		}
	};
}

var fix_read_opts = fix_opts_func([
	[&#x27;cellNF&#x27;, false], /* emit cell number format string as .z */
	[&#x27;cellHTML&#x27;, true], /* emit html string as .h */
	[&#x27;cellFormula&#x27;, true], /* emit formulae as .f */
	[&#x27;cellStyles&#x27;, false], /* emits style/theme as .s */
	[&#x27;cellDates&#x27;, false], /* emit date cells with type &#x60;d&#x60; */

	[&#x27;sheetStubs&#x27;, false], /* emit empty cells */
	[&#x27;sheetRows&#x27;, 0, &#x27;n&#x27;], /* read n rows (0 = read all rows) */

	[&#x27;bookDeps&#x27;, false], /* parse calculation chains */
	[&#x27;bookSheets&#x27;, false], /* only try to get sheet names (no Sheets) */
	[&#x27;bookProps&#x27;, false], /* only try to get properties (no Sheets) */
	[&#x27;bookFiles&#x27;, false], /* include raw file structure (keys, files, cfb) */
	[&#x27;bookVBA&#x27;, false], /* include vba raw data (vbaraw) */

	[&#x27;password&#x27;,&#x27;&#x27;], /* password */
	[&#x27;WTF&#x27;, false] /* WTF mode (throws errors) */
]);


var fix_write_opts = fix_opts_func([
	[&#x27;cellDates&#x27;, false], /* write date cells with type &#x60;d&#x60; */

	[&#x27;bookSST&#x27;, false], /* Generate Shared String Table */

	[&#x27;bookType&#x27;, &#x27;xlsx&#x27;], /* Type of workbook (xlsx/m/b) */

	[&#x27;WTF&#x27;, false] /* WTF mode (throws errors) */
]);
function safe_parse_wbrels(wbrels, sheets) {
	if(!wbrels) return 0;
	try {
		wbrels = sheets.map(function pwbr(w) { return [w.name, wbrels[&#x27;!id&#x27;][w.id].Target]; });
	} catch(e) { return null; }
	return !wbrels || wbrels.length === 0 ? null : wbrels;
}

function safe_parse_ws(zip, path, relsPath, sheet, sheetRels, sheets, opts) {
	try {
		sheetRels[sheet]=parse_rels(getzipdata(zip, relsPath, true), path);
		sheets[sheet]=parse_ws(getzipdata(zip, path),path,opts,sheetRels[sheet]);
	} catch(e) { if(opts.WTF) throw e; }
}

var nodirs = function nodirs(x){return x.substr(-1) != &#x27;/&#x27;;};
function parse_zip(zip, opts) {
	make_ssf(SSF);
	opts = opts || {};
	fix_read_opts(opts);
	reset_cp();

	/* OpenDocument Part 3 Section 2.2.1 OpenDocument Package */
	if(safegetzipfile(zip, &#x27;META-INF/manifest.xml&#x27;)) return parse_ods(zip, opts);

	var entries = keys(zip.files).filter(nodirs).sort();
	var dir = parse_ct(getzipdata(zip, &#x27;[Content_Types].xml&#x27;), opts);
	var xlsb = false;
	var sheets, binname;
	if(dir.workbooks.length === 0) {
		binname = &quot;xl/workbook.xml&quot;;
		if(getzipdata(zip,binname, true)) dir.workbooks.push(binname);
	}
	if(dir.workbooks.length === 0) {
		binname = &quot;xl/workbook.bin&quot;;
		if(!getzipfile(zip,binname,true)) throw new Error(&quot;Could not find workbook&quot;);
		dir.workbooks.push(binname);
		xlsb = true;
	}
	if(dir.workbooks[0].substr(-3) == &quot;bin&quot;) xlsb = true;
	if(xlsb) set_cp(1200);

	if(!opts.bookSheets &amp;&amp; !opts.bookProps) {
		strs = [];
		if(dir.sst) strs=parse_sst(getzipdata(zip, dir.sst.replace(/^\//,&#x27;&#x27;)), dir.sst, opts);

		styles = {};
		if(dir.style) styles = parse_sty(getzipdata(zip, dir.style.replace(/^\//,&#x27;&#x27;)),dir.style, opts);

		themes = {};
		if(opts.cellStyles &amp;&amp; dir.themes.length) themes = parse_theme(getzipdata(zip, dir.themes[0].replace(/^\//,&#x27;&#x27;), true),dir.themes[0], opts);
	}

	var wb = parse_wb(getzipdata(zip, dir.workbooks[0].replace(/^\//,&#x27;&#x27;)), dir.workbooks[0], opts);

	var props = {}, propdata = &quot;&quot;;

	if(dir.coreprops.length !== 0) {
		propdata = getzipdata(zip, dir.coreprops[0].replace(/^\//,&#x27;&#x27;), true);
		if(propdata) props = parse_core_props(propdata);
		if(dir.extprops.length !== 0) {
			propdata = getzipdata(zip, dir.extprops[0].replace(/^\//,&#x27;&#x27;), true);
			if(propdata) parse_ext_props(propdata, props);
		}
	}

	var custprops = {};
	if(!opts.bookSheets || opts.bookProps) {
		if (dir.custprops.length !== 0) {
			propdata = getzipdata(zip, dir.custprops[0].replace(/^\//,&#x27;&#x27;), true);
			if(propdata) custprops = parse_cust_props(propdata, opts);
		}
	}

	var out = {};
	if(opts.bookSheets || opts.bookProps) {
		if(props.Worksheets &amp;&amp; props.SheetNames.length &gt; 0) sheets=props.SheetNames;
		else if(wb.Sheets) sheets = wb.Sheets.map(function pluck(x){ return x.name; });
		if(opts.bookProps) { out.Props = props; out.Custprops = custprops; }
		if(typeof sheets !== &#x27;undefined&#x27;) out.SheetNames = sheets;
		if(opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
	}
	sheets = {};

	var deps = {};
	if(opts.bookDeps &amp;&amp; dir.calcchain) deps=parse_cc(getzipdata(zip, dir.calcchain.replace(/^\//,&#x27;&#x27;)),dir.calcchain,opts);

	var i=0;
	var sheetRels = {};
	var path, relsPath;
	if(!props.Worksheets) {
		var wbsheets = wb.Sheets;
		props.Worksheets = wbsheets.length;
		props.SheetNames = [];
		for(var j = 0; j != wbsheets.length; ++j) {
			props.SheetNames[j] = wbsheets[j].name;
		}
	}

	var wbext = xlsb ? &quot;bin&quot; : &quot;xml&quot;;
	var wbrelsfile = &#x27;xl/_rels/workbook.&#x27; + wbext + &#x27;.rels&#x27;;
	var wbrels = parse_rels(getzipdata(zip, wbrelsfile, true), wbrelsfile);
	if(wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
	/* Numbers iOS hack */
	var nmode = (getzipdata(zip,&quot;xl/worksheets/sheet.xml&quot;,true))?1:0;
	for(i = 0; i != props.Worksheets; ++i) {
		if(wbrels) path = &#x27;xl/&#x27; + (wbrels[i][1]).replace(/[\/]?xl\//, &quot;&quot;);
		else {
			path = &#x27;xl/worksheets/sheet&#x27;+(i+1-nmode)+&quot;.&quot; + wbext;
			path = path.replace(/sheet0\./,&quot;sheet.&quot;);
		}
		relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, &quot;$1/_rels/$3.rels&quot;);
		safe_parse_ws(zip, path, relsPath, props.SheetNames[i], sheetRels, sheets, opts);
	}

	if(dir.comments) parse_comments(zip, dir.comments, sheets, sheetRels, opts);

	out = {
		Directory: dir,
		Workbook: wb,
		Props: props,
		Custprops: custprops,
		Deps: deps,
		Sheets: sheets,
		SheetNames: props.SheetNames,
		Strings: strs,
		Styles: styles,
		Themes: themes,
		SSF: SSF.get_table()
	};
	if(opts.bookFiles) {
		out.keys = entries;
		out.files = zip.files;
	}
	if(opts.bookVBA) {
		if(dir.vba.length &gt; 0) out.vbaraw = getzipdata(zip,dir.vba[0],true);
		else if(dir.defaults.bin === &#x27;application/vnd.ms-office.vbaProject&#x27;) out.vbaraw = getzipdata(zip,&#x27;xl/vbaProject.bin&#x27;,true);
	}
	return out;
}
function add_rels(rels, rId, f, type, relobj) {
	if(!relobj) relobj = {};
	if(!rels[&#x27;!id&#x27;]) rels[&#x27;!id&#x27;] = {};
	relobj.Id = &#x27;rId&#x27; + rId;
	relobj.Type = type;
	relobj.Target = f;
	if(rels[&#x27;!id&#x27;][relobj.Id]) throw new Error(&quot;Cannot rewrite rId &quot; + rId);
	rels[&#x27;!id&#x27;][relobj.Id] = relobj;
	rels[(&#x27;/&#x27; + relobj.Target).replace(&quot;//&quot;,&quot;/&quot;)] = relobj;
}

function write_zip(wb, opts) {
	if(wb &amp;&amp; !wb.SSF) {
		wb.SSF = SSF.get_table();
	}
	if(wb &amp;&amp; wb.SSF) {
		make_ssf(SSF); SSF.load_table(wb.SSF);
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;
	}
	opts.rels = {}; opts.wbrels = {};
	opts.Strings = []; opts.Strings.Count = 0; opts.Strings.Unique = 0;
	var wbext = opts.bookType == &quot;xlsb&quot; ? &quot;bin&quot; : &quot;xml&quot;;
	var ct = { workbooks: [], sheets: [], calcchains: [], themes: [], styles: [],
		coreprops: [], extprops: [], custprops: [], strs:[], comments: [], vba: [],
		TODO:[], rels:[], xmlns: &quot;&quot; };
	fix_write_opts(opts = opts || {});
	var zip = new jszip();
	var f = &quot;&quot;, rId = 0;

	opts.cellXfs = [];
	get_cell_style(opts.cellXfs, {}, {revssf:{&quot;General&quot;:0}});

	f = &quot;docProps/core.xml&quot;;
	zip.file(f, write_core_props(wb.Props, opts));
	ct.coreprops.push(f);
	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);

	f = &quot;docProps/app.xml&quot;;
	if(!wb.Props) wb.Props = {};
	wb.Props.SheetNames = wb.SheetNames;
	wb.Props.Worksheets = wb.SheetNames.length;
	zip.file(f, write_ext_props(wb.Props, opts));
	ct.extprops.push(f);
	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);

	if(wb.Custprops !== wb.Props &amp;&amp; keys(wb.Custprops||{}).length &gt; 0) {
		f = &quot;docProps/custom.xml&quot;;
		zip.file(f, write_cust_props(wb.Custprops, opts));
		ct.custprops.push(f);
		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
	}

	f = &quot;xl/workbook.&quot; + wbext;
	zip.file(f, write_wb(wb, f, opts));
	ct.workbooks.push(f);
	add_rels(opts.rels, 1, f, RELS.WB);

	for(rId=1;rId &lt;= wb.SheetNames.length; ++rId) {
		f = &quot;xl/worksheets/sheet&quot; + rId + &quot;.&quot; + wbext;
		zip.file(f, write_ws(rId-1, f, opts, wb));
		ct.sheets.push(f);
		add_rels(opts.wbrels, rId, &quot;worksheets/sheet&quot; + rId + &quot;.&quot; + wbext, RELS.WS);
	}

	if(opts.Strings != null &amp;&amp; opts.Strings.length &gt; 0) {
		f = &quot;xl/sharedStrings.&quot; + wbext;
		zip.file(f, write_sst(opts.Strings, f, opts));
		ct.strs.push(f);
		add_rels(opts.wbrels, ++rId, &quot;sharedStrings.&quot; + wbext, RELS.SST);
	}

	/* TODO: something more intelligent with themes */

	f = &quot;xl/theme/theme1.xml&quot;;
	zip.file(f, write_theme());
	ct.themes.push(f);
	add_rels(opts.wbrels, ++rId, &quot;theme/theme1.xml&quot;, RELS.THEME);

	/* TODO: something more intelligent with styles */

	f = &quot;xl/styles.&quot; + wbext;
	zip.file(f, write_sty(wb, f, opts));
	ct.styles.push(f);
	add_rels(opts.wbrels, ++rId, &quot;styles.&quot; + wbext, RELS.STY);

	zip.file(&quot;[Content_Types].xml&quot;, write_ct(ct, opts));
	zip.file(&#x27;_rels/.rels&#x27;, write_rels(opts.rels));
	zip.file(&#x27;xl/_rels/workbook.&#x27; + wbext + &#x27;.rels&#x27;, write_rels(opts.wbrels));
	return zip;
}
function firstbyte(f,o) {
	switch((o||{}).type || &quot;base64&quot;) {
		case &#x27;buffer&#x27;: return f[0];
		case &#x27;base64&#x27;: return Base64.decode(f.substr(0,12)).charCodeAt(0);
		case &#x27;binary&#x27;: return f.charCodeAt(0);
		case &#x27;array&#x27;: return f[0];
		default: throw new Error(&quot;Unrecognized type &quot; + o.type);
	}
}

function read_zip(data, opts) {
	var zip, d = data;
	var o = opts||{};
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? &quot;buffer&quot; : &quot;base64&quot;;
	switch(o.type) {
		case &quot;base64&quot;: zip = new jszip(d, { base64:true }); break;
		case &quot;binary&quot;: case &quot;array&quot;: zip = new jszip(d, { base64:false }); break;
		case &quot;buffer&quot;: zip = new jszip(d); break;
		case &quot;file&quot;: zip=new jszip(d=_fs.readFileSync(data)); break;
		default: throw new Error(&quot;Unrecognized type &quot; + o.type);
	}
	return parse_zip(zip, o);
}

function readSync(data, opts) {
	var zip, d = data, isfile = false, n;
	var o = opts||{};
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? &quot;buffer&quot; : &quot;base64&quot;;
	if(o.type == &quot;file&quot;) { isfile = true; o.type = &quot;buffer&quot;; d = _fs.readFileSync(data); }
	switch((n = firstbyte(d, o))) {
		case 0xD0:
			if(isfile) o.type = &quot;file&quot;;
			return parse_xlscfb(CFB.read(data, o), o);
		case 0x09: return parse_xlscfb(s2a(o.type === &#x27;base64&#x27; ? Base64.decode(data) : data), o);
		case 0x3C: return parse_xlml(d, o);
		case 0x50:
			if(isfile) o.type = &quot;file&quot;;
			return read_zip(data, opts);
		default: throw new Error(&quot;Unsupported file &quot; + n);
	}
}

function readFileSync(data, opts) {
	var o = opts||{}; o.type = &#x27;file&#x27;;
	return readSync(data, o);
}
function write_zip_type(wb, opts) {
	var o = opts||{};
	var z = write_zip(wb, o);
	switch(o.type) {
		case &quot;base64&quot;: return z.generate({type:&quot;base64&quot;});
		case &quot;binary&quot;: return z.generate({type:&quot;string&quot;});
		case &quot;buffer&quot;: return z.generate({type:&quot;nodebuffer&quot;});
		case &quot;file&quot;: return _fs.writeFileSync(o.file, z.generate({type:&quot;nodebuffer&quot;}));
		default: throw new Error(&quot;Unrecognized type &quot; + o.type);
	}
}

function writeSync(wb, opts) {
	var o = opts||{};
	switch(o.bookType) {
		case &#x27;xml&#x27;: return write_xlml(wb, o);
		default: return write_zip_type(wb, o);
	}
}

function writeFileSync(wb, filename, opts) {
	var o = opts||{}; o.type = &#x27;file&#x27;;
	o.file = filename;
	switch(o.file.substr(-5).toLowerCase()) {
		case &#x27;.xlsx&#x27;: o.bookType = &#x27;xlsx&#x27;; break;
		case &#x27;.xlsm&#x27;: o.bookType = &#x27;xlsm&#x27;; break;
		case &#x27;.xlsb&#x27;: o.bookType = &#x27;xlsb&#x27;; break;
	default: switch(o.file.substr(-4).toLowerCase()) {
		case &#x27;.xls&#x27;: o.bookType = &#x27;xls&#x27;; break;
		case &#x27;.xml&#x27;: o.bookType = &#x27;xml&#x27;; break;
	}}
	return writeSync(wb, o);
}

function decode_row(rowstr) { return parseInt(unfix_row(rowstr),10) - 1; }
function encode_row(row) { return &quot;&quot; + (row + 1); }
function fix_row(cstr) { return cstr.replace(/([A-Z]|^)(\d+)$/,&quot;$1$$$2&quot;); }
function unfix_row(cstr) { return cstr.replace(/\$(\d+)$/,&quot;$1&quot;); }

function decode_col(colstr) { var c = unfix_col(colstr), d = 0, i = 0; for(; i !== c.length; ++i) d = 26*d + c.charCodeAt(i) - 64; return d - 1; }
function encode_col(col) { var s=&quot;&quot;; for(++col; col; col=Math.floor((col-1)/26)) s = String.fromCharCode(((col-1)%26) + 65) + s; return s; }
function fix_col(cstr) { return cstr.replace(/^([A-Z])/,&quot;$$$1&quot;); }
function unfix_col(cstr) { return cstr.replace(/^\$([A-Z])/,&quot;$1&quot;); }

function split_cell(cstr) { return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/,&quot;$1,$2&quot;).split(&quot;,&quot;); }
function decode_cell(cstr) { var splt = split_cell(cstr); return { c:decode_col(splt[0]), r:decode_row(splt[1]) }; }
function encode_cell(cell) { return encode_col(cell.c) + encode_row(cell.r); }
function fix_cell(cstr) { return fix_col(fix_row(cstr)); }
function unfix_cell(cstr) { return unfix_col(unfix_row(cstr)); }
function decode_range(range) { var x =range.split(&quot;:&quot;).map(decode_cell); return {s:x[0],e:x[x.length-1]}; }
function encode_range(cs,ce) {
	if(ce === undefined || typeof ce === &#x27;number&#x27;) return encode_range(cs.s, cs.e);
	if(typeof cs !== &#x27;string&#x27;) cs = encode_cell(cs); if(typeof ce !== &#x27;string&#x27;) ce = encode_cell(ce);
	return cs == ce ? cs : cs + &quot;:&quot; + ce;
}

function safe_decode_range(range) {
	var o = {s:{c:0,r:0},e:{c:0,r:0}};
	var idx = 0, i = 0, cc = 0;
	var len = range.length;
	for(idx = 0; i &lt; len; ++i) {
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;
		idx = 26*idx + cc;
	}
	o.s.c = --idx;

	for(idx = 0; i &lt; len; ++i) {
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;
		idx = 10*idx + cc;
	}
	o.s.r = --idx;

	if(i === len || range.charCodeAt(++i) === 58) { o.e.c=o.s.c; o.e.r=o.s.r; return o; }

	for(idx = 0; i != len; ++i) {
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;
		idx = 26*idx + cc;
	}
	o.e.c = --idx;

	for(idx = 0; i != len; ++i) {
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;
		idx = 10*idx + cc;
	}
	o.e.r = --idx;
	return o;
}

function safe_format_cell(cell, v) {
	if(cell.z !== undefined) try { return (cell.w = SSF.format(cell.z, v)); } catch(e) { }
	if(!cell.XF) return v;
	try { return (cell.w = SSF.format(cell.XF.ifmt||0, v)); } catch(e) { return &#x27;&#x27;+v; }
}

function format_cell(cell, v) {
	if(cell == null || cell.t == null) return &quot;&quot;;
	if(cell.w !== undefined) return cell.w;
	if(v === undefined) return safe_format_cell(cell, cell.v);
	return safe_format_cell(cell, v);
}

function sheet_to_json(sheet, opts){
	var val, row, range, header = 0, offset = 1, r, hdr = [], isempty, R, C, v;
	var o = opts != null ? opts : {};
	var raw = o.raw;
	if(sheet == null || sheet[&quot;!ref&quot;] == null) return [];
	range = o.range !== undefined ? o.range : sheet[&quot;!ref&quot;];
	if(o.header === 1) header = 1;
	else if(o.header === &quot;A&quot;) header = 2;
	else if(Array.isArray(o.header)) header = 3;
	switch(typeof range) {
		case &#x27;string&#x27;: r = safe_decode_range(range); break;
		case &#x27;number&#x27;: r = safe_decode_range(sheet[&quot;!ref&quot;]); r.s.r = range; break;
		default: r = range;
	}
	if(header &gt; 0) offset = 0;
	var rr = encode_row(r.s.r);
	var cols = new Array(r.e.c-r.s.c+1);
	var out = new Array(r.e.r-r.s.r-offset+1);
	var outi = 0;
	for(C = r.s.c; C &lt;= r.e.c; ++C) {
		cols[C] = encode_col(C);
		val = sheet[cols[C] + rr];
		switch(header) {
			case 1: hdr[C] = C; break;
			case 2: hdr[C] = cols[C]; break;
			case 3: hdr[C] = o.header[C - r.s.c]; break;
			default:
				if(val === undefined) continue;
				hdr[C] = format_cell(val);
		}
	}

	for (R = r.s.r + offset; R &lt;= r.e.r; ++R) {
		rr = encode_row(R);
		isempty = true;
		if(header === 1) row = [];
		else {
			row = {};
			if(Object.defineProperty) Object.defineProperty(row, &#x27;__rowNum__&#x27;, {value:R, enumerable:false});
			else row.__rowNum__ = R;
		}
		for (C = r.s.c; C &lt;= r.e.c; ++C) {
			val = sheet[cols[C] + rr];
			if(val === undefined || val.t === undefined) continue;
			v = val.v;
			switch(val.t){
				case &#x27;e&#x27;: continue;
				case &#x27;s&#x27;: break;
				case &#x27;b&#x27;: case &#x27;n&#x27;: break;
				default: throw &#x27;unrecognized type &#x27; + val.t;
			}
			if(v !== undefined) {
				row[hdr[C]] = raw ? v : format_cell(val,v);
				isempty = false;
			}
		}
		if(isempty === false || header === 1) out[outi++] = row;
	}
	out.length = outi;
	return out;
}

function sheet_to_row_object_array(sheet, opts) { return sheet_to_json(sheet, opts != null ? opts : {}); }

function sheet_to_csv(sheet, opts) {
	var out = &quot;&quot;, txt = &quot;&quot;, qreg = /&quot;/g;
	var o = opts == null ? {} : opts;
	if(sheet == null || sheet[&quot;!ref&quot;] == null) return &quot;&quot;;
	var r = safe_decode_range(sheet[&quot;!ref&quot;]);
	var FS = o.FS !== undefined ? o.FS : &quot;,&quot;, fs = FS.charCodeAt(0);
	var RS = o.RS !== undefined ? o.RS : &quot;\n&quot;, rs = RS.charCodeAt(0);
	var row = &quot;&quot;, rr = &quot;&quot;, cols = [];
	var i = 0, cc = 0, val;
	var R = 0, C = 0;
	for(C = r.s.c; C &lt;= r.e.c; ++C) cols[C] = encode_col(C);
	for(R = r.s.r; R &lt;= r.e.r; ++R) {
		row = &quot;&quot;;
		rr = encode_row(R);
		for(C = r.s.c; C &lt;= r.e.c; ++C) {
			val = sheet[cols[C] + rr];
			txt = val !== undefined ? &#x27;&#x27;+format_cell(val) : &quot;&quot;;
			for(i = 0, cc = 0; i !== txt.length; ++i) if((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34) {
				txt = &quot;\&quot;&quot; + txt.replace(qreg, &#x27;&quot;&quot;&#x27;) + &quot;\&quot;&quot;; break; }
			row += (C === r.s.c ? &quot;&quot; : FS) + txt;
		}
		out += row + RS;
	}
	return out;
}
var make_csv = sheet_to_csv;

function sheet_to_formulae(sheet) {
	var cmds, y = &quot;&quot;, x, val=&quot;&quot;;
	if(sheet == null || sheet[&quot;!ref&quot;] == null) return &quot;&quot;;
	var r = safe_decode_range(sheet[&#x27;!ref&#x27;]), rr = &quot;&quot;, cols = [], C;
	cmds = new Array((r.e.r-r.s.r+1)*(r.e.c-r.s.c+1));
	var i = 0;
	for(C = r.s.c; C &lt;= r.e.c; ++C) cols[C] = encode_col(C);
	for(var R = r.s.r; R &lt;= r.e.r; ++R) {
		rr = encode_row(R);
		for(C = r.s.c; C &lt;= r.e.c; ++C) {
			y = cols[C] + rr;
			x = sheet[y];
			val = &quot;&quot;;
			if(x === undefined) continue;
			if(x.f != null) val = x.f;
			else if(x.w !== undefined) val = &quot;&#x27;&quot; + x.w;
			else if(x.v === undefined) continue;
			else val = &quot;&quot;+x.v;
			cmds[i++] = y + &quot;=&quot; + val;
		}
	}
	cmds.length = i;
	return cmds;
}

var utils = {
	encode_col: encode_col,
	encode_row: encode_row,
	encode_cell: encode_cell,
	encode_range: encode_range,
	decode_col: decode_col,
	decode_row: decode_row,
	split_cell: split_cell,
	decode_cell: decode_cell,
	decode_range: decode_range,
	format_cell: format_cell,
	get_formulae: sheet_to_formulae,
	make_csv: sheet_to_csv,
	make_json: sheet_to_json,
	make_formulae: sheet_to_formulae,
	sheet_to_csv: sheet_to_csv,
	sheet_to_json: sheet_to_json,
	sheet_to_formulae: sheet_to_formulae,
	sheet_to_row_object_array: sheet_to_row_object_array
};
XLSX.parse_xlscfb = parse_xlscfb;
XLSX.parse_zip = parse_zip;
XLSX.read = readSync; //xlsread
XLSX.readFile = readFileSync; //readFile
XLSX.readFileSync = readFileSync;
XLSX.write = writeSync;
XLSX.writeFile = writeFileSync;
XLSX.writeFileSync = writeFileSync;
XLSX.utils = utils;
XLSX.CFB = CFB;
XLSX.SSF = SSF;
})(typeof exports !== &#x27;undefined&#x27; ? exports : XLSX);
var XLS = XLSX;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
